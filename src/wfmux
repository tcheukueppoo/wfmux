#!/bin/dash

#set -x
set -ue

readonly PROGRAM=${0##*/}

readonly ESC_ALT_SCREEN='\033[?1049h'
readonly ESC_NORMAL_SCREEN='\033[?1049l'
readonly ESC_HIDE_CUR='\033[?25l'
readonly ESC_SHOW_CUR='\033[?25h'
readonly ESC_CLEAR_SCREEN='\033[2J'
readonly ESC_BOLD='\033[1m'
readonly ESC_UNDERLINE='\033[4m'
readonly ESC_RED='\033[31m'
readonly ESC_UNSET_ANSI='\033[0m'

readonly CONFIG_DIR=${XDG_CONFIG_HOME:-"$HOME/.config"}
readonly WFMUX_CONFIG_DIR="${CONFIG_DIR%%/}/wfmux"
readonly COMMANDS="$WFMUX_CONFIG_DIR/commands"
readonly CACHE_DIR=${XDG_CACHE_HOME:-"$HOME/.cache"}
readonly CACHE="${CACHE_DIR%%/}/wfmux"
readonly SESSION_DIR="${CACHE_DIR%%/}/wfmux/sessions"
readonly TMUX_CONF="$HOME/.tmux.conf"

mkdir -p "$CONFIG_DIR" "$CACHE_DIR" "$CACHE" "$SESSION_DIR" "$WFMUX_CONFIG_DIR"

# Large size
readonly WFMUX_LS=$(cat <<EOF
                                ┌────────────
                                │
                                │                                            ┌───────
                                │                             ┌───┐          │
            ┌──┐                │                             │   │          │
            │  │                │                             │   │          │
            │  │           ┌────┼─────┬─────┬──────┬──┐       │   │    ┌─────┘
            │  │     ┌─    │    │     │     │      │  │       │   │    │
────────────┘  │     │     │    │     │     │      │  │       │   └────┼─────┐
               │     │     │    │     │     │      │  │       │        │     │
               │     │     │    │     │     └────  │  └───────┘        │     │
               ├─────┴─────┘    │     │            └──                 │     │
               │                │    ─┘                                │     │
               │                │            ──────────────────────────┘     │
               │                └─                                           │
         ──────┘                                                             │
                                                                             │
EOF
)

# Medium size
readonly WFMUX_MS=$(cat <<EOF
                     ┌─────                           ┌───
                     │                                │
        ┌─┐          │                      ┌──┐      │
        │ │       ┌──┼───┬───┬───┬────┐     │  │  ┌───┘
        │ │   ┌─  │  │   │   │   │    │     │  │  │
────────┘ │   │   │  │   │   │   │    │     │  └──┼───┐
          │   │   │  │   │   │   │    │     │     │   │
          ├───┴───┘  │  ─┘   └─  │    └─────┘     │   │
          │          └─          └──              │   │
          │                              ─────────┘   │
       ───┘                                           │
EOF
)

# Small size
readonly WFMUX_SS='WFMUX'

readonly WFMUX=$(cat<<EOL

     ┌──────────────┤ WFMUX
    ┌┴────────────────────────────────────────┐
    │                                         │
    ├─ Input a name for a new tmux session    │
    ├─ Input f⟨return⟩ to select a project    │
    ├─ Input ⟨return⟩ to drop to the terminal │
    │                                         │
    └─────────────────────────────────────────┘
EOL
)

WFMUX_CONFIG="$WFMUX_CONFIG_DIR/wfmux.conf"
WFMUX_OPS=$(cat<<END
open
tmux
dump
select
explore
nsession
switch
view
awatcher
dwatcher
ewatcher
rwatcher
push
fpush
commit
acommit
branch
ops
END
)

# Default configuration if external config file does not exist
COLOR=4
SUCCESS="\033[1;3${COLOR}m"

TOK=tok
GITLAB_TOK_NAME=gitlab_token_name

WATCHER='entr'
WATCHER_TEMPLATES="$HOME/.config/wfmux/commands"
FILE_MANAGER='lf'

WIN_ATTR_OTHERS='20x20+10+20'
WIN_ATTR_FILE_SELECTOR='20x20+10+20'
WIN_ATTR_INPUT_BOX='20x20+10+20'

TBIND_OPS='='
TBIND_EXPLORE='BSpace'
TBIND_SELECT='Enter'

MENU='fzf --multi --margin=25%'

PROJECT_DIRS=$(cat <<END
$HOME/projects
$HOME/oprojects
END
)

USE_XDG_OPEN=false
PROGRAMS=$(cat <<END
tty=true,text=vim '#f'
tty=true,directory=lf '#f'
tty=true,video=ffplay -hide_banner -loop 0 '#f'
tty=true,audio=ffplay -hide_banner -loop 0 '#f'
tty=false,pdf=zathura '#f'
tty=false,image=feh '#f'
END
)

usage () {
   cat <<END
Build an awesome dev workflow using tmux, fzf, nnn, and entr.

Usage: wfmux [ ( -c | --config ) CONF ] OPT_NAME
       wfmux [ -h | --help ]

Options:
     -h, --help         print this help message.
     -c, --config CONF  load CONF configuration file.

OPT_NAME:
    new          fuzzyly select a project and open a new tmux session.
    nsession     create a new project tmux session while in a tmux session.
    switch       switch between project sessions
    explore      open your favorite file manager on a popup tmux pane.
    open         fuzzyly select a file to open provided that they exist
                 a recently used tmux session which carries the name of your
                 project.   
    commit       add to the index and commit changes to local repository.
    acommit      replace the tip of the current branch by creating a new commit
    push         push to the remote repositories.
    fpush        force-push to the remote repositories.
    branch       fuzzyly switch between branches of your local repository.
    dump         dump wfmux's tmux configuration to stdout.
    tmux         update wfmux's tmux configuration at ~/.tmux.conf.
    ops          a wrapper to the above operations.
    dwatcher     disable a watcher from the watcher list
    ewatcher     enable a watcher from the watcher list
    awatcher     Add a new watcher to a project's watcher list.
    rwatcher     Remove a new watcher to a project's watcher list.
    view         Fancy view of the concerned running project watcher.

END
   exit $1
}

die () {
   printf "$PROGRAM: $*\n" >&2
   exit 1
}

main () {
   test $# -eq 0 && usage 1

   opt_name=
   while [ $# -ne 0 ] ; do
      case $1 in
         -h|--help)
            usage 0
            ;;
         -c|--config)
            test $# -eq 1 && WFMUX_CONFIG=$2 || usage 1
            if ! test -e "$WFMUX_CONFIG" ; then
               die "Config file '$WFMUX_CONFIG' does not exist."
            fi
            shift
            ;;
         -*)
            die "Unknown option '$1', please try \`$PROGRAM --help'."
            ;;
         *)
            test -n "$opt_name" && usage 1
            opt_name=$1
            if ! printf "$WFMUX_OPS" | grep -q "^$opt_name$" ; then
               die "Unknown wfmux operation: $opt_name."
            fi
            ;;
      esac
      shift
   done

   test -f "$WFMUX_CONFIG" && {
      test -r "$WFMUX_CONFIG" || die "No permission to read '$WFMUX_CONFIG'."
      . "$WFMUX_CONFIG"       || die "Non-zero exit status when sourcing config ."
   }

   check_config_variables
   eval "opt_wfmux_$opt_name"
}

## Check if variables are unset or null and if set then check if
## the data matches our expectations we won't have to rely on
## `set -u`, we would want to output a custom error message if
## one of these variables aren't sane.
check_config_variables () {
   is_set=
   var=
   conf_error=" ('$WFMUX_CONFIG'):"

   for var in USE_XDG_OPEN WATCHER MENU FILE_MANAGER WIN_ATTR_OTHERS \
              WIN_ATTR_INPUT_BOX WIN_ATTR_FILE_SELECTOR PROJECT_DIRS  \
              TBIND_OPS TBIND_SELECT TBIND_EXPLORE ; do

      eval "is_set=\${$var:+true}"
      test -z "$is_set" && die "$conf_error: '$var' isn't defined."
   done

   _val_error () {
      die "$conf_error: Invalid value assigned to '$1'."
   }

   ## Check if we've got sane values
   {
      expr "$COLOR"        : '[0-9]$'       || _val_error COLOR
      expr "$USE_XDG_OPEN" : 'true\|false$' || _val_error USE_XDG_OPEN

      num_re='\([0-9]\|[1-9][0-9]\+\)'
      attr_re="${num_re}x${num_re}+${num_re}+${num_re}$"

      for var in WIN_ATTR_OTHERS        \
                 WIN_ATTR_FILE_SELECTOR  \
                 WIN_ATTR_INPUT_BOX ; do
         val=$(eval 'printf "$'$var'"')

         expr "$val" : "$attr_re" || _val_error $var
      done

      for cmd in FILE_MANAGER WATCHER MENU ; do
         eval 'command' '-v' "\${$cmd}"
         test $? -ne 0 && die "$conf_error: Command '$cmd' not found."
      done
   } >/dev/null

   OIFS=$IFS IFS='
'
   project_dirs=
   for path in $PROJECT_DIRS ; do

      if ! rpath=$(realpath -e "$path" 2>/dev/null) ; then
         die "$conf_error: '$path' does not exist."
      fi

      test -d "$rpath" || die "$conf_error: '$rpath' is not a directory."
      test -r "$rpath" || die "$conf_error: cannot list contents of '$rpath'."

      project_dirs="${project_dirs}${rpath}\n"
   done

   IFS=$OIFS
   PROJECT_DIRS=$(printf "$project_dirs")
}

display_dashboard () {
   awk_max='BEGIN { len = 0 }
            {
               nlen = length($0)
               if (nlen > len)
                  len = nlen
            }
            END { print len }'

   # Dashboard message, explains how to use wfmux on tmux.
   _dashboard_msg () {
      cat <<END
The following are tmux bindings related to wfmux.

M-$TBIND_SELECT: fuzzyly open project files
M-$TBIND_EXPLORE: open file manager
M-$TBIND_OPS: fuzzyly select other wfmux operations

input any key to exit dashboard
END
   }

   _tty_print () {
      printf "\033[$1;$2f$3" >/dev/tty
   }

   # Save initial terminal setting, will set back after exiting dashboard
   init_stty=`stty -g`
   stty -cooked -echo time 0 min 1
   printf "${ESC_ALT_SCREEN}${ESC_HIDE_CUR}${ESC_CLEAR_SCREEN}"

   {
      term_h= term_w=
      while [ 1 ] ; do
         new_size=`stty -F /dev/tty size`
         if test "$new_size" = "$term_h $term_w" ; then
            sleep 1
            continue
         fi

         term_h=$(printf "$new_size\n" | cut -d' ' -f1)
         term_w=$(printf "$new_size\n" | cut -d' ' -f2)
         if test $term_h -lt 32 || test $term_w -lt 97 ; then
            _size=SS
         elif test $term_h -lt 43 || test $term_w -lt 155 ; then
            _size=MS
         else
            _size=LS
         fi
         eval 'wfmux_h=$(printf "$WFMUX_'$_size'" | wc -l)
               wfmux_w=$(printf "$WFMUX_'$_size'" | awk "$awk_max")'

         wfmux_h=$(expr $wfmux_h + `_dashboard_msg | wc -l`)

         x=$((($term_w - $wfmux_w) / 2))
         y=$((($term_h - $wfmux_h) / 2))

         msg_w=$(_dashboard_msg | awk "$awk_max")
         if test $msg_w -gt $wfmux_w ; then
            msg_x=$(($x - ($msg_w - $wfmux_w) / 2))
         else
            msg_x=$(($x + ($wfmux_w - $msg_w) / 2))
         fi

         printf "${ESC_CLEAR_SCREEN}${SUCCESS}${ESC_BOLD}"

         IFS='
'
         for line in $(eval 'printf "$WFMUX_'$_size'"') ; do
            _tty_print $y $x "$line"
            y=$(($y + 1))
         done

         printf "$ESC_UNSET_ANSI"
         for line in `_dashboard_msg` ; do
            y=$(($y + 1))
            _tty_print "$y" "$msg_x" "$line"
         done
      done
   } &

   # Get key from the standard input
   dd if=/dev/tty count=1 bs=1 >/dev/null 2>&1

   kill -KILL $! || :

   stty "$init_stty"
   printf "$ESC_UNSET_ANSI$ESC_SHOW_CUR"
   tput clear
}

tmux_cur_session () {
   tmux list-sessions -F '#S:#{session_activity}' | sort -b -t: -k2,2n | tail -n1 | cut -d: -f1
}

tmux_cur_pty () {
   tmux list-clients -F '#S:#{client_tty}' | grep -F "$(tmux_cur_session):" | cut -d: -f2
}

tmux_message () {
   tmux display-message -d 1000 "$1"
}

shrink_project_dirs () {
   shrinked_dirs=$PROJECT_DIRS

   for n in $(seq `printf "$shrinked_dirs\n" | wc -l`) ; do
      path=$(printf "$shrinked_dirs" | sed -ne "${n}p")

      # Check if it's already resolved.
      expr "$path" : / >/dev/null || continue

      name=${path#/}
      name=${name%%/*}

      # Check if $path is the only one.
      test $(printf "$shrinked_dirs" | grep "^/$name/" | wc -l) -eq 1 && continue

      path=${path#/*/}
      shrinked_dirs=$(printf "$shrinked_dirs" | sed -e "s#^/$name/#*/#")

      # Shrink more
      OIFS=$IFS IFS=/
      for name in $path ; do
         test $(printf "$shrinked_dirs" | grep "^\*/$name/" | wc -l) -eq 1 && continue

         _shrinked_dirs=$(printf "$shrinked_dirs" | sed -e "s#^\*/$name/#*/#")

         a=$(printf "$_shrinked_dirs" | sed -e 's/\*/.../')
         b=$(printf "$a" | sort -u)
         test ${#a} -ne ${#b} && break

         shrinked_dirs=$_shrinked_dirs
      done
      IFS=$OIFS

      shrinked_dirs=$(printf "$shrinked_dirs" | sed -e 's/\*/.../')
   done

   printf "$shrinked_dirs\n"
}

get_project_list () {
   line=1
   shrinked_dirs=`shrink_project_dirs`

   IFS='
'
   for dir in $PROJECT_DIRS ; do
      cd "$dir"

      for file in * ; do
         test -d "$file" || continue
         test -x "$file" || continue

         shrinked_dir=$(printf "$shrinked_dirs" | sed -ne "${line}p")
         printf "[%d]:%s/%s\n" $line "$shrinked_dir" "$file"
      done

      line=$(($line + 1))
   done
}

new_session () {
   project=$(get_project_list | eval "$MENU")
   test -z "$project" && return

   line=${project%%]*}
   line=${line#[}
   project_ddir=$(printf "$PROJECT_DIRS" | sed -ne "${line}p")
   project_name=$(basename "$project")
   project_dir="$project_ddir/$project_name"

   cd -L "$project_dir"

   test -d .git && {
      touch .gitignore
      grep -q -- .wfmux .gitignore || {
         printf '.wfmux\n' >>.gitignore
         git add .gitignore && git commit -m 'Update .gitignore'
      } 
   }

   if test -d .wfmux      \
   && test -x .wfmux       \
   && test -s .wfmux/name   \
   && expr "$(cat .wfmux/name)" : "$project_name-.\\{6\\}$" >/dev/null ; then
      session_name=`cat .wfmux/name`
   else
      mkdir -p .wfmux
      touch .wfmux/name
      session_name=`mktemp -u $project_name-XXXXXX`
      printf "$session_name" >>.wfmux/name
      printf '.git\n' >>.wfmux/ignore
   fi

   if [ -z "${TMUX:-}" ] ; then
      tmux has-session -t "$session_name" 2>/dev/null || {
         start_watchers "$project_dir"
         display_dashboard
         tmux new-session -s "$session_name" -d
      }
      exec tmux attach-session -t "$session_name"
   else
      pty=`tmux_cur_pty`
      tmux has-session -t "$session_name" 2>/dev/null || tmux new-session -s "$session_name" -d
      tmux switch-client -c "$pty" -t "$session_name"
   fi
}

# Create a new project tmux session while in an existing session, similer to `opt_open'
opt_wfmux_nsession () { new_session; }

start_watchers () {
   project_dir=$1
   watch_config="$project_dir/.wfmux/watch"

   ! test -s "$watch_config" && return

   mkdir -p "$project_dir/.wfmux/fifos"

   cat "$watch_config" | grep '^s+' | while read watcher ; do
      watcher_name=$(printf "$watcher" | sed -ne 's/^s+.\[\([^:]]\+\)\]:.*/\1/p')
      is_oneshot=$(printf "$watcher"   | sed -ne 's/^s+\(0\|1\).*/\1/p')
      watcher_cmd=$(printf "$watcher"  | sed -ne 's/^[^:]*:\(.\+\)/\1/;s/^[ \t]*//;s/[ \t]*$//p')

      if test -z "$watcher_name"  \
      || test -z "$is_oneshot"     \
      || test -z "$watcher_cmd" ; then
         die "failed to parse watcher: $watch_config'."
      fi

      start_watcher "$project_dir" $watcher_name $is_oneshot "$watcher_cmd"
   done
}

# Select a project and open a tmux session
opt_wfmux_new () {
   session_name= input=

   if tmux list-sessions >/dev/null 2>&1 ; then
      printf "Choose an existing session to attach\n\n"
      tmux list-sessions | awk '{print "["NR"] "$0}'
   fi

   printf "$WFMUX\n"
   read -p '⟩⟩ ' input
   tput clear

   test -z "$input" && return

   if expr "$input" : '\(F\|f\)$' >/dev/null ; then
      new_session
   elif expr "$input" : '\([0-9]\|[1-9][0-9]\+\)$' >/dev/null ; then
      session_name=$(tmux list-sessions -F '#S' | sed -n "${input}p")
      test -n "$session_name" && tmux attach-session -t "$session_name"
   else
      tmux new-session -s "$(printf "$input")"
   fi
}

set_whxy () {
   window_attribute=$1

   y=$(printf "$window_attribute" | sed -e 's/^.*+\([0-9]\+\)$/\1/')
   x=$(printf "$window_attribute" | sed -e 's/^.*+\([0-9]\+\)+.*/\1/')
   w=$(printf "$window_attribute" | sed -e 's/^\([0-9]\+\)x.*/\1/')
   h=$(printf "$window_attribute" | sed -e 's/^.*x\([0-9]\+\).*/\1/')
}

dump_config () {
   set_whxy $WIN_ATTR_FILE_SELECTOR
   cat <<END
unbind M-$TBIND_SELECT
bind   M-$TBIND_SELECT if-shell "command -v wfmux" {
   display-popup -w $w          \\
                 -h $h           \\
                 -x $x            \\
                 -y $y             \\
                 -E "/home/kueppo/projects/wfmux/src/wfmux select"
}
END

   set_whxy $WIN_ATTR_OTHERS
   cat <<END
unbind M-$TBIND_EXPLORE
bind   M-$TBIND_EXPLORE if-shell "command -v wfmux" {
   display-popup -w $w           \\
                 -h $h            \\
                 -x $x             \\
                 -y $y              \\
                 -E "wfmux explore"
}

unbind M-$TBIND_OPS
bind   M-$TBIND_OPS if-shell "command -v wfmux" {
   display-popup -w $w       \\
                 -h $h        \\
                 -x $x         \\
                 -y $y          \\
                 -E "wfmux ops"
}
END
}

opt_wfmux_dump () { dump_config; }
opt_wfmux_tmux () { dump_config >>"$TMUX_CONF"; }

get_project_dir () {
   test -z "$1" && return

   session_name=$1
   project_name=$(printf "$session_name" | sed -ne 's/^\([^-]\+\)-.\{6\}$/\1/p')
   test -z "$project_name" && return

   OIFS=$IFS IFS='
'
   for dir in $PROJECT_DIRS ; do
      project_dir="$dir/$project_name"

      test -d "$project_dir"       \
         && test -x "$project_dir"  \
         && cd -L "$project_dir"     \
         || continue

      if test -f ".wfmux/name" \
      && test $session_name = "$(cat .wfmux/name)" ; then
         printf "$project_dir\n"
      fi
   done

   IFS=$OIFS
}

opt_wfmux_switch () {
   test -z "${TMUX:-}" && die "wfmux must run in a tmux session"

   wfmux_sessions= IFS='
'
   for session in `tmux list-sessions -F '#S'` ; do
      test -z "$(get_project_dir "$session")" && continue
      wfmux_sessions="${wfmux_sessions}${session}\n"
   done

   test -z "$wfmux_sessions" && return
   session=$(printf "$wfmux_sessions" | eval "$MENU")

   if [ -n "$session" ] ; then
      tmux switch-client -c "$(tmux_cur_pty)" -t "$session"
   fi
}

## Open tui file manager
opt_wfmux_explore () {
   test -z "${TMUX:-}" && die "wfmux must run in a tmux session."

   project_dir=`get_project_dir "$(tmux_cur_session)"`

   if [ -z "$project_dir" ] ; then
      tmux_message "This is not a wfmux tmux session"
      tmux display-popup -C
   else 
      eval "$FILE_MANAGER" "$project_dir"
   fi
}

get_project_files () {
   ignore=
   project_dir=$1

   cd -L "$project_dir"

   if test -s .wfmux/ignore ; then
      IFS='
'
      for pattern in `cat .wfmux/ignore` ; do
         ignore="${ignore}${ignore:+ -or}"
         ignore="${ignore} -name '${pattern}'"
      done
   fi

   if test -n "$ignore" ; then
      eval find . '\(' "$ignore" '\)' -prune -or -type f -print
   else
      find . -type f -print
   fi
}

get_filetype () {
   file=$1

   if command -v xdg-mime >/dev/null ; then
      filetype=$(xdg-mime query filetype "$file")
   elif command -v file >/dev/null ; then
      filetype=$(file --mime-type "$file")
      filetype=${filetype##*: }
   else
      tmux-message "Couldn't determine the file type of '$file'."
      return
   fi

   expr "$filetype" : application >/dev/null  \
      && filetype=${filetype##*/}              \
      || filetype=${filetype%%/*}

   printf "$filetype"
}

nohup () {
   { trap '' HUP; eval "$@"; } &
}

## Select a project file to open
opt_wfmux_open () {
   test -z "${TMUX:-}" && die "wfmux must run in a tmux session."

   project_dir=`get_project_dir "$(tmux_cur_session)"`

   if test -z "$project_dir" ; then
      tmux_message "This is not a wfmux tmux session"
      tmux display-popup -C
      exit 1
   fi

   files=$(get_project_files "$project_dir" | eval "$MENU")

   IFS='
'
   for file in $files ; do

      if test "$USE_XDG_OPEN" = true ; then

         command -v xdg-open >/dev/null || {
            tmux_message "xdg-utils package not installed."
            tmux display-popup -C
            exit 1
         }

         cmd="xdg-open '$file'"
      else
         filetype=`get_filetype "$file"`
         test -z "$filetype" && continue

         esc_file=$(printf "$file" | sed -e 's|/|\\/|')
         data=$(printf "$PROGRAMS" | sed -ne "/^tty=\(true\|false\),$filetype=/p")

         test -z "$data" && {
            tmux_message "Unable to open '$file'."
            continue
         }

         use_tty=${data%,$filetype=*}
         use_tty=${use_tty#tty=}
         cmd=$(printf "${data#*,$filetype=}" | sed -e 's|\([^\\]\)#f|\1%s|;s|\\#|#|g;p')

         bin=${cmd%% *}
         command -v "$bin" >/dev/null || {
            tmux_message "Unable to open '$file', $bin: not found."
            continue
         }
      fi

      wfmux_run_cmd "$cmd" $use_tty
   done
}

wfmux_run_cmd () {
   cmd=$1 use_tty=$2

   test $use_tty = false && {
      nohup "$cmd" >/dev/null 2>&1
      return 0
   }

   fmt='#{pane_current_command}:#P:#{pane_active}'
   panes=$(tmux list-panes -F "$fmt")

   idle_panes=$(printf "$panes" | sed -ne "s/^$SHELL:\(.\+\)$/\1/p")

   # Run the command in an idle pane if possible
   test -n "$idle_panes" && {
      target=$(printf "$idle_panes" | grep ':1$')
      target=${target%:1}

      test -z $target && {
         target=$(printf "$idle_panes" | sort -t: -k1,1n | head -n1)
         target=${target%:0}
      }

      tmux send-keys -t "$target" "$cmd" C-m
      return 0
   }
   
   # Spawn a new pane in the current window to run the command
   # if there only one pane in the current window
   test $(printf "$panes" | wc -l) -eq 1 && {
      tmux split-window -h "$command"
      return 0
   }

   # In the worst case, run it in a new window.
   tmux new-window "$cmd"
}

opt_commit () {
   __commit
}

opt_acommit () {
   __commit true
}

__commit () {
   editor=$(printf "$PROGRAMS" | sed -ne 's/^[ \t]*text:[ \t]\+\(\w*\)$/\1/p')

   editor=${editor:-$EDITOR}
   editor=${editor:-vim}

   { command -v git       || return
     command -v "$editor" || return
   } >/dev/null

   project_dir=`__get_project_dir`

   if [ -n "$project_dir" ] ; then
      cd "$project_dir"
      if [ $? = 0 ] ; then
         amend=${1:-false}

         git add .
         if [ "$amend" = false ] ; then
            tempfile=`mktemp /tmp/.git_XXXXXX`

            $editor "$tempfile"
            # Let git abord if we did not commit with a commit message
            # than trying to introduce a `du'-like command
            git commit --message "$(cat "$tempfile")"
            rm -f "$tempfile"
         else
            git commit --amend
         fi
      fi
   fi
}

opt_branch () {
   command -v git >/dev/null || return

   local project_dir=`__get_project_dir`

   cd "$project_dir"
   if [ $? = 0 ]
   then
      local branch

      printf "%s\n" "$MENU" | grep -q '^fzf' && MENU="$MENU --print-query"
      branch=$(git branch --all | sed -e 's|^\(\*\?\) *\(.*\)$|\2\1|; s|^\(\([^/]\+/\)\+\)\(.\+\)$|\3|' | awk '/\*$/{ dup = substr($0, 1, length($0) - 1) }; $0 != dup{ print }' | sort | uniq | eval "$MENU" | tail -n1)
      branch=${branch%*}
      if [ -n "$branch" ]
      then
         # Check if the current working branch is clean(nothing to commit)
         git status | tail -n1 | grep -q '^nothing to commit' 
         if [ $? -eq 0 ]
         then
            git checkout "$branch" || git checkout -b "$branch"
         fi
      fi
   fi
}

__input_to_exit () {
   printf "\nPress anything to quit!"
   stty -echo -cooked && dd if=/dev/tty count=1 bs=1 >/dev/null 2>&1
}

opt_push  () { __push;         }
opt_fpush () { __push --force; }

__push () {
   { command -v git    || return
     command -v "$TOK" || return
   } >/dev/null

   project_dir=`__get_project_dir`
   test -n "$project_dir" && project_name=$(basename "$project_dir")

   if [ -n "$project_name" ] ; then
      cd "$project_dir"
      if [ $? -eq 0 ] ; then
         username=
         remotes=$(printf "$WFMUX_REMOTE" | eval "$MENU")
         session_path="$SESSION_DIR/$(tmux_cur_session)"

         if [ -s "$session_path/user" ]
         then
            username=$(cat "$session_path/user")
         else
            username=$(printf "$WFMUX_USERS" | eval "$MENU")
            printf "$username" >"$session_path/user"
         fi

         if [ -n "$remotes" ]; then
            force=${1:---force}
            proto=https
            branch=$(git branch | sed -ne 's|^\* \(.\+\)|\1|p')
            git_config=$(cat .git/config)

            printf "%s\n" "$remotes" | while read remote ; do
               my_tok=$(eval "$TOK '${remote%%.*}'")

               case $remote in
                  codeberg.org|github.com|github.com) proto=https ;;
                  *) proto=https ;;
               esac
               test "$remote" = "gitlab.com" && my_tok="$GITLAB_TOK_NAME:$my_tok"

               printf "Pushing to $remote/$username  ";
               {
                  i=0
                  set -- − \\ \| /
                  while true; do 
                     sleep 0.2
                     i=$(($i+1))
                     eval "printf \"\b\$$(($(($i%4))+1))\""
                  done
               } &

               local failed=No
               git push "$force" --set-upstream "$proto://$my_tok@$remote/$username/$project_name.git" "$branch" >/dev/null 2>&1 || failed=Yes
               kill -KILL $!

               test x"$failed" = x"Yes" && c="${ESC_RED}Failed" || c="${SUCCESS}Done"
               printf "\b$c$ESC_UNSET_ANSI\n"
            done

            # To avoid saving tokens!
            printf "$git_config" > .git/config
            __input_to_exit
         fi
      fi
   fi
}

start_watcher () {
   project_session=$2 one_shot=${1%%(*} cmd=${1#?(*)} watcher_name=${1%%)*}

   watcher_name=${1#?(}

   # You will be seeing the std(out|err) of watchers via named-pipes
   local fifo="$project_session/fifos/$watcher_name.fifo"

   test -p "$fifo" || mkfifo "$fifo"
   { 
      trap '' HUP
      if [ $one_shot = 1 ] ; then
         # for self restarting programs(e.g framework developement server)
         eval "$cmd"
      else
         cat "$project_session/watch" \
         | sed -ne "/^s+0\[$watcher_name\]:/,/^e\[$watcher_name\]/p" \
         | tail -n +2 \
         | sed '$d' \
         | case $WATCHER in
            entr) entr -nr "$cmd" ;;
            *) : ;;
           esac >"$fifo"
      fi
   } >"$fifo" 2>&1 &

   printf "$!" >"$project_session/$watcher_name.pid"
}

# Add a new watcher to the watcher list
opt_awatcher () {
   watcher_name=
   watch_config="$SESSION_DIR/`tmux_cur_session`/watch"
   project_dir=`__get_project_dir`

   printf "Give a name to your watcher: "
   read watcher_name

   printf "One shot(Y/n)? "
   read one_shot

   if [ -n "$watcher_name" ] ; then
      # Check if this name already exists in the watcher list
      test -f "$watch_config" && cat "$watch_config" | grep -q "^s[-+][01]:\[$watcher_name\]" && return

      __get_files() {
         local args=$(printf "$IGNORE" | sed -e '${ s/\(.*\)/-name "\1"/; q; };1,${ s/\(.*\)/-name "\1" -or /; }' | tr '\n' ' ')
          eval "find '$project_dir' \( $args \) -prune -or -type f -print | sed -e 's,^$project_dir/,,' | $MENU"
      }

      files=`__get_files`
      if [ -n "$files" ]; then
         printf "$ESC_UNDERLINE"

         if [ -r "$COMMANDS" ]; then
            case $one_shot in
            y | Y)
               local cmd=$(cat "$COMMANDS" | grep -v '^[\t ]*\(#.*\)\?$' | eval "$MENU")
               cat <<EOF
s+0[$watcher_name]: $cmd
$files
e[$watcher_name]
EOF
               ;;
            *)
               cat <<-EOF
s+1[$watcher_name]: $cmd
e[$watcher_name]
EOF
               ;;
            esac >>"$watch_config"
            printf "$SUCCESS"
            printf "'$watcher_name' was successfully added to the list of watchers\n"
         else
            printf "$ESC_RED"
            printf "Could not find the list of commands.\n" >&2
            printf "these commands should be located at '$COMMANDS'\n" >&2
         fi
         printf "${ESC_UNSET_ANSI}${ESC_UNSET_ANSI}"

         __input_to_exit
      fi
   fi
}

# remove watchers from the watcher list
opt_rwatcher () {
   cur_session=`tmux_cur_session`
   [ -z "$cur_session" ] && return

   project_session="$SESSION_DIR/$cur_session"
   watch_config="$project_session/watch"

   test -r "$watch_config" -a -s "$watch_config" || return

   watcher_names=$(cat "$watch_config" | sed -ne 's/^s[-+]\[\(\w*\)\]:.*$/\1/p')
   if [ -n "$watcher_names" ]; then
      watcher_name=$(printf "$watcher_names" | eval "$MENU")

      if [ -n "$watcher_name" ]; then
         printf "$ESC_UNDERLINE"
         cat "$watch_config" | grep -q "^e\[$watcher_name\]"

         if [ $? -eq 0 ]; then
            sed -i "/^s..\[$watcher_name\]:/,/^e\[$watcher_name\]/d" "$watch_config"
            if [ $? -eq 0 ]; then
               if [ -r "$project_session/fifos/$watcher_name.pid" ] ; then
                  pid=$(cat "$project_session/fifos/$watcher_name.pid")
                  kill -KILL "$pid" >/dev/null 2>&1
               fi
               printf "$SUCCESS"
               printf "Watcher '$watcher_name' successfully deleted\n"
            else
               printf "$ESC_RED"
               printf "Could not delete watcher\n"
            fi
         else
            printf "$ESC_RED"
            printf "could not find scope of definition of '$watcher_name'\n"
         fi
         printf "${ESC_UNSET_ANSI}${ESC_UNSET_ANSI}"
      fi
   else
      printf "you do not have any watcher\n"
   fi

   __input_to_exit
}

__ed_watcher () {
   watch_config="$1/watch"

   if [ -r "$watch_config" -a -s "$watch_config" ] ; then
      watcher_names=$(cat "$watch_config" | sed -ne 's/^s[-+][01]\[\(\w*\)\]:.*$/\1/p')

      if [ -n "$watcher_names" ] ; then
         watcher_name=$(printf "$watcher_names" | eval "$MENU")
         if [ -n "$watcher_name" ] ; then
            sed -ie "s/^s.\(.\[$watcher_name\]\)/^s$2\1/" "$watch_config"
         fi
      else
         printf "No watcher were found\n"
      fi
   fi
}

# Enable watchers, should be runned within an existing wfmux tmux session.
# This operation sets on watchers to be runned upon session startup.
opt_ewatcher () {
   cur_session=`tmux_cur_session`
   project_session="$SESSION_DIR/$cur_session"
   watch_file="$project_session/watch"

   [ -z "$cur_session" ] && return

   printf "$ESC_UNDERLINE"

   watcher_name=$(__ed_watcher "$watch_file" +)
   if [ $? -eq 0 ] ; then
      pid_file="$project_session/fifos/$watcher_name.pid"

      if ! test -s "$pid_file" ||
         ! ps a | grep -q "^[\t ]\+$(cat "$pid_file")" ; then
         pairs=$(cat "$watch_file" | sed -ne 's/^s+\(.\)\[\(.*\)\]: *\(.\+\) *$/\1(\2)\3/p')
         __start_watcher "$pairs" "$project_session"
      fi

      printf "$SUCCESS"
      printf "Watcher '$watcher_name' enabled.\n"
      printf "${ESC_UNSET_ANSI}${ESC_UNSET_ANSI}"
   else
      printf "$ESC_RED"
      printf "Could not enable watcher '$watcher_name'\n"
   fi
   printf "${ESC_UNSET_ANSI}${ESC_UNSET_ANSI}"

   __input_to_exit
}

# Disable watchers, should be runned within an existing wfmux tmux session.
# This operation sets off watchers so that they cannot run when a new wfmux
# tmux session is initiated either via `opt_open' or `opt_nsession'
opt_rwatchers () {
   cur_session=`tmux_cur_session`
   project_session="$SESSION_DIR/$cur_session"
   watch_file="$project_session/watch"

   [ -z "$cur_session" ] && return

   printf "$ESC_UNDERLINE"

   watcher_name=$(__ed_watcher "$watch_file" -)
   if [ $? -eq 0 ] ; then
      printf "$SUCCESS"
      printf "Watcher '$watcher_name' disabled.\n"
      printf "${ESC_UNSET_ANSI}${ESC_UNSET_ANSI}"
   else
      printf "$ESC_RED"
      printf "Could not disable watcher '$watcher_name'\n"
   fi
   printf "${ESC_UNSET_ANSI}${ESC_UNSET_ANSI}"

   __input_to_exit
}

# Fancy view of all watchers belonging to the project
# Definition of the view
#             --[ project_name ]--
#    PID:          not running(red), running($COLOR)
#    WATCHER_NAME: disable(red), enabled($COLOR)
#    o/m         : o, not monitored by $runner otherwise m
#
#    WATCHER_NAME   PID    o/m  COMMAND
#    watcher_name_1 pid_1  o    command_1
#    watcher_name_2 pid_2  m    command_2
#    watcher_name_3 pid_3  m    command_3
opt_view () {
   i= j= project_name=`__get_project_dir` project_session=`tmux_cur_session`

   test -z "$project_name" && return
   project_name=`basename "$project_name"`

   printf "${ESC_UNDERLINE}${SUCCESS}${project_name}${ESC_UNSET_ANSI}${ESC_UNSET_ANSI}\n"
   printf "${ESC_BOLD}PID${ESC_UNSET_ANSI}:          shotdown(${ESC_RED}red${ESC_UNSET_ANSI}), running(${SUCCESS}this color${ESC_UNSET_ANSI})\n"
   printf "${ESC_BOLD}WATCHER_NAME${ESC_UNSET_ANSI}: disable(${ESC_RED}red${ESC_UNSET_ANSI}), enabled(${SUCCESS}this color${ESC_UNSET_ANSI})\n"
   printf "${ESC_BOLD}O/M${ESC_UNSET_ANSI}         : ${ESC_BOLD}O${ESC_UNSET_ANSI} = oneshot, ${ESC_BOLD}M${ESC_UNSET_ANSI} = not oneshot\n\n"

   watcher_file="$SESSION_DIR/$project_session/watch"
   while read watcher ; do
      watcher=$(printf "$watcher" | sed -ne "s///p")
      _name=$(printf "$watcher" | awk 'BEGIN{RS="";FS="\n"};{print $1}')
      pid_file="$SESSION_DIR/$project_session/$_name/pid"
      test -s "$pid_file" && _pid=$(cat "$pid_file") || _pid=X
   
      test ${#pid}  -gt $j && j=${#pid}
      test ${#name} -gt $i && i=${#name}

      pid=${pid}${pid:+"\n"}$_pid
      name=${name}${name:+"\n"}$_name
      stat=${stat}${stat:+"\n"}$(printf "$watcher" | awk 'BEGIN{RS="";FS="\n"};{print $2}')
      shot=${shot}${shot:+"\n"}$(printf "$watcher" | awk 'BEGIN{RS="";FS="\n"};{print $3}')
      comm=${comm}${comm:+"\n"}$(printf "$watcher" | awk 'BEGIN{RS="";FS="\n"};{print $4}')
   done <"$watcher_file"

   printf "%${i}s |%${j}s |%-4s |%s\n" "WATCHER_NAME" "PID" "O/M" "COMMAND"
   printf "%${i}s |%${j}s |%-4s |%s\n" "" "" "" ""

   while [ 1 ] ; do
      test ${#name} -eq 0 && break
      printf "%${i}s |%${j}s |%-4s |%s\n" "$_name" "$_pid" "$_stat" "$_comm"
   done
}

opt_ksession () {
   :;
}

# Cycle through std(out&stderr) of watchers
opt_cycle () {
   cur_session=`tmux_cur_session`
   project_fifos="$SESSION_DIR/$cur_session/fifos"

   watcher_name=
   test -z "$cur_session" && return

   cd "$project_fifo"
   if [ $? -eq 0 ] ; then
      for fifo in * ; do
         watcher_name=${fifo%.fifo}
         if [ -n "$watcher_name" ] ; then
            {
               printf "${SUCCESS}${watcher_name}${ESC_UNSET_ANSI}${ESC_BOLD}\n"
               cat "$fifo"
            } | less --RAW-CONTROL-CHARS
            printf "$ESC_UNSET_ANSI"
         fi
      done
   fi
}

load_plugins () { :; }

# Wrap all operations, plugins appear here
opt_ops () {
   test -z "${TMUX:-}" && return

   opt_name=$(printf "$WFMUX_OPS" | eval "$MENU")
   test -z "$opt_name" && return

   {
      trap '' HUP
      case $ops in
      select)
         set_whxy $WIN_ATTR_FILE_SELECTOR
         ;;
      *)
         set_whxy $WIN_ATTR_OTHERS
         ;;
      esac
      tmux display-popup -w $w -h $h -x $x -y $y -E "/home/kueppo/projects/wfmux/src/wfmux $ops"
   } &

   tmux display-popup -C
}

main "$@"
