#!/bin/sh

#set -x
set -ue

readonly ALT_SCREEN='\033[?1049h'
readonly NORMAL_SCREEN='\033[?1049l'
readonly HIDE_CUR='\033[?25l'
readonly SHOW_CUR='\033[?25h'
readonly CLEAR_SCREEN='\033[2J'
readonly BOLD='\033[1m'
readonly UNSET_ANSI='\033[0m'
readonly PROGRAM=${0##*/}
readonly CONFIG_DIR=${XDG_CONFIG_HOME:-"$HOME/.config"}
readonly WFMUX_CONFIG_DIR="${CONFIG_DIR%%/}/wfmux"
readonly COMMANDS="$WFMUX_CONFIG_DIR/commands"
readonly CACHE_DIR=${XDG_CACHE_HOME:-"$HOME/.cache"}
readonly CACHE="${CACHE_DIR%%/}/wfmux"
readonly CACHE_PL="${CACHE_DIR}/wfmux.pl"
readonly SESSION_DIR="${CACHE_DIR%%/}/wfmux/sessions"
readonly TMUX_CONF="$HOME/.tmux.conf"

mkdir -p "$CONFIG_DIR" "$CACHE_DIR" "$CACHE" "$SESSION_DIR" "$WFMUX_CONFIG_DIR"

readonly LOGO_LS=$(cat <<EOF
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx┌────────────
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx┌───────
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxxxxxxxxxxxxxxx┌───┐xxxxxxxxxx│
xxxxxxxxxxxx┌──┐xxxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxxxxxxxxxxxxxxx│xxx│xxxxxxxxxx│
xxxxxxxxxxxx│xx│xxxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxxxxxxxxxxxxxxx│xxx│xxxxxxxxxx│
xxxxxxxxxxxx│xx│xxxxxxxxxxx┌────┼─────┬─────┬──────┬──┐xxxxxxx│xxx│xxxx┌─────┘
xxxxxxxxxxxx│xx│xxxxx┌─xxxx│xxxx│xxxxx│xxxxx│xxxxxx│xx│xxxxxxx│xxx│xxxx│
────────────┘xx│xxxxx│xxxxx│xxxx│xxxxx│xxxxx│xxxxxx│xx│xxxxxxx│xxx└────┼─────┐
xxxxxxxxxxxxxxx│xxxxx│xxxxx│xxxx│xxxxx│xxxxx│xxxxxx│xx│xxxxxxx│xxxxxxxx│xxxxx│
xxxxxxxxxxxxxxx│xxxxx│xxxxx│xxxx│xxxxx│xxxxx└────xx│xx└───────┘xxxxxxxx│xxxxx│
xxxxxxxxxxxxxxx├─────┴─────┘xxxx│xxxxx│xxxxxxxxxxxx└──xxxxxxxxxxxxxxxxx│xxxxx│
xxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxx│xxxx─┘xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│xxxxx│
xxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxx│xxxxxxxxxxxx──────────────────────────┘xxxxx│
xxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxx└─xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│
xxxxxxxxx──────┘xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│
EOF
)
readonly LOGO_MS=$(cat <<EOF
xxxxxxxxxxxxxxxxxxxxx┌─────xxxxxxxxxxxxxxxxxxxxxxxxxxx┌───
xxxxxxxxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│
xxxxxxxx┌─┐xxxxxxxxxx│xxxxxxxxxxxxxxxxxxxxxx┌──┐xxxxxx│
xxxxxxxx│x│xxxxxxx┌──┼───┬───┬───┬────┐xxxxx│xx│xx┌───┘
xxxxxxxx│x│xxx┌─xx│xx│xxx│xxx│xxx│xxxx│xxxxx│xx│xx│
────────┘x│xxx│xxx│xx│xxx│xxx│xxx│xxxx│xxxxx│xx└──┼───┐
xxxxxxxxxx│xxx│xxx│xx│xxx│xxx│xxx│xxxx│xxxxx│xxxxx│xxx│
xxxxxxxxxx├───┴───┘xx│xx─┘xxx└─xx│xxxx└─────┘xxxxx│xxx│
xxxxxxxxxx│xxxxxxxxxx└─xxxxxxxxxx└──xxxxxxxxxxxxxx│xxx│
xxxxxxxxxx│xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx─────────┘xxx│
xxxxxxx───┘xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│
EOF
)
readonly LOGO_SS='WFMUX'

readonly WFMUX=$(cat<<EOF

     ┌──────────────┤ WFMUX
    ┌┴─────────────────────────────────────────────────┐
    │                                                  │
    ├───── Input a name for a new tmux session         │
    │                                                  │
    ├───── Input f⟨return⟩ to select a project         │
    │                                                  │
    ├───── Input ⟨return⟩ to drop to the terminal      │
    │                                                  │
    └──────────────────────────────────────────────────┘
EOF
)

TOK=tok
GITLAB_TOK_NAME=gitlab_token_name
WFMUX_CONFIG="$WFMUX_CONFIG_DIR/wfmux.conf"
USE_XDG=yes
RUNNER=entr
RUNNER_TEMPLATES="$HOME/.config/wfmux/rtemplate"
DASH_COLOR=4
EXPLORER=nnn
IGNORE=.git
SEARCHER='fzf --multi --border=bottom --margin=25%'
WINDOW_ATTRIBUTES_REST=20x20+10+20
WINDOW_ATTRIBUTES_FILE_SELECTOR=20x20+10+20
WINDOW_ATTRIBUTES_INPUT_BOX=20x20+10+20
TBIND_OPS==
TBIND_EXPLORE=BSpace
TBIND_SELECT=Enter

PROJECT_DIRECTORY=$(cat <<-EOF
	$HOME/projects
	$HOME/aprojects
	$HOME/oprojects
	EOF
)

PROGRAMS=$(cat <<-EOF
	pdf:      zathura
	text:     nvim
	video:    ffmpeg
	audio:    aplay
	image:    feh
	database: program_name
	EOF
)

usage() {
	cat <<EOF
Build an awesome dev workflow with tmux, fzf, nnn, and entr.
usage: wfmux [ [-c|-config|--config] *config_file* ] *operation_name*
       wfmux [ -h | -help | --help ]

Options:
     -h, -help, --help             print this help message.
     -c, -config, --config *FILE*  load *FILE* configuration file.

Operation names:
    open         fuzzyly select a project and open a new tmux session.
    nsession     create a new project tmux session while in a tmux session.
    switch      switch between project sessions
    explore      open your favorite file manager on a popup tmux pane.
    select       fuzzyly select a file to open provided that they exist
                 a recently used tmux session which carries the name of your
                 project.   
    commit       add to the index and commit changes to local repository.
    acommit      replace the tip of the current branch by creating a new commit
    push         push to the remote repositories.
    fpush        force-push to the remote repositories.
    branch       fuzzyly switch between branches of your local repository.
    dump         dump wfmux's tmux configuration to stdout.
    tmux         update wfmux's tmux configuration at ~/.tmux.conf.
    ops          a wrapper to the above operations.
    dwatcher     disable a watcher from the watcher list
    ewatcher     enable a watcher from the watcher list
    awatcher     add a new watcher to the watcher list
    rwatcher     remove a new watcher to the watcher list
    view         fancy view of any existing running project watcher.

EOF
	exit "$1"
}

die() {
	printf "$*\n" >&2
	exit 1
}

func_main() {
	local operation=
	local gave_config=false

	[ $# -eq 0 ] && usage 1
	until [ $# -eq 0 ]
	do
		case "$1" in
		-h | -help | --help)
			usage 0 ;;
		-c | -config | --config)
			[ $# -eq 1 ] && WFMUX_CONFIG=$2 || usage 1
			gave_config=true
			shift ;;
		push     | \
		fpush    | \
		commit   | \
		acommit  | \
		select   | \
		explore  | \
		open     | \
		tmux     | \
		dump     | \
		ops      | \
		view     | \
		awatcher | \
		dwatcher | \
		ewatcher | \
		rwatcher | \
		branch   | \
		nsession | \
		switch)
			operation=$1
			if [ -f "$WFMUX_CONFIG" ]
			then
				[ -r "$WFMUX_CONFIG" ] || die "no permission to read '$WFMUX_CONFIG'"
				. $WFMUX_CONFIG        || die "could not source configuration file"
			fi ;;
		*)
			die "'$1' is an unrecognized option, please try \`$PROGRAM --help'" ;;
		esac
		shift
	done

	if [ x$gave_config = x"true" ]
	then
		check_config_variables
	else
		# use default config "~/.config/wfmux.conf" is possible
		if [ -f "$WFMUX_CONFIG" -a -r "$WFMUX_CONFIG" ]
		then
			check_config_variables
		fi
	fi

	eval "func_$operation"
}

## Check if variables are unset or null	and if set then
## check if the data is somehow our expectation.
## we won't have to rely on `set -u`, we would want to output a custom 
## error message if one of these variables aren't set/sane.
check_config_variables() {
	local is_set para
	local error="$PROGRAM: ('$WFMUX_CONFIG'):"

	for para in \
		         USE_XDG \
		         RUNNER \
		         SEARCHER \
		         EXPLORER \
		         WINDOW_ATTRIBUTES_REST \
		         WINDOW_ATTRIBUTES_INPUT_BOX \
		         WINDOW_ATTRIBUTES_FILE_SELECTOR \
		         PROJECT_DIRECTORY \
		         TBIND_OPS \
		         TBIND_SELECT \
		         TBIND_EXPLORE
	do
		eval "is_set=\${$para:-UNSET}"
		[ "$is_set" = UNSET ] && die "$error '$para' isn't set"
	done

	_config_die() {
		die "$error invalid value assigned to '$1'"
	}

	## Check if we got sane values
	{
		local window_regex='[[:digit:]]\+x[[:digit:]]\++[[:digit:]]\++[[:digit:]]\+$'
		expr "$WINDOW_ATTRIBUTES_REST"          : "$window_regex" || _config_die WINDOW_ATTRIBUTES_REST
		expr "$WINDOW_ATTRIBUTES_FILE_SELECTOR" : "$window_regex" || _config_die WINDOW_ATTRIBUTES_FILE_SELECTOR
		expr "$WINDOW_ATTRIBUTES_INPUT_BOX"     : "$window_regex" || _config_die WINDOW_ATTRIBUTES_INPUT_BOX
		expr "$USE_XDG"                         : 'true\|false$'  || _config_die USE_XDG
		expr "$DASH_COLOR"                      : '[0-9]$'        || _config_die DASH_COLOR
	} >/dev/null

	for i in EXPLORER RUNNER SEARCHER
	do
		eval "command -v" "\${$i} >/dev/null"
		test $? -ne 0 && die "$error '$i' not found"
	done

	# IFS=$'\n' won't expand '\n' on dash shell
	printf "$PROJECT_DIRECTORY" |
	while read i
	do
		test -d "$i" || die "$error '$i' is not a directory"
		test -r "$i" || die "$error cannot list content of '$i'"
	done
}

display_dashboard() {
	local put_color="\033[3${DASH_COLOR:-9}m"
	local max="awk 'BEGIN{len = 0}; {nlen = length(\$0); if (nlen > len) len = nlen;}; END{print len}'"

	# generate help message for the dashboard
	_gen_key_helper() {
		cat <<-EOF
			The following are tmux bindings related to WFMUX.

			M-$TBIND_SELECT: fuzzyly open project files
			M-$TBIND_EXPLORE: open file manager
			M-$TBIND_OPS: fuzzyly select other wfmux operations

			input any key to exit dashboard
		EOF
	}

	_print() {
		printf "\033[$1;$2f$3" >/dev/tty
	}

	# save initial terminal setting and will set it back after exiting dashboard
	local init_stty=$(stty -g)
	stty -cooked -echo time 0 min 1
	printf "${ALT_SCREEN}${HIDE_CUR}${CLEAR_SCREEN}"

	(
		term_h= term_w=
		while true; do
			if [ "$(stty -F /dev/tty size)" = "$term_h $term_w" ]
			then
				sleep 2
				continue
			fi
			term_h=$(stty -F /dev/tty size | cut -d' ' -f1)
			term_w=$(stty -F /dev/tty size | cut -d' ' -f2)
			if   [ $term_h -lt 32 -o $term_w -lt 97  ]
			then
				_size=ss
			elif [ $term_h -lt 43 -o $term_w -lt 155 ]
			then
				_size=ms
			else
				_size=ls
			fi
			eval 'logo_h=$(printf "$logo_'$_size'" | wc -l);
				  logo_w=$(printf "$logo_'$_size'" | eval "$max")'

			logo_h=$(expr $logo_h + `_gen_key_helper | wc -l`)
			gen_w=$(_gen_key_helper | eval "$max")
			x=$(expr $term_w / 2 - $logo_w / 2)
			y=$(expr $term_h / 2 - $logo_h / 2)
			if [ $gen_w -gt $logo_w ]
			then
				gen_x=$(expr $x - \( $gen_w  - $logo_w \) / 2)
			else
				gen_x=$(expr $x + \( $logo_w - $gen_w  \) / 2)
			fi

			printf "${CLEAR_SCREEN}${PUT_COLOR}${BOLD}"
			eval 'printf "$logo_'$_size'"' | {
				while read i
				do
					_print $y $x "$(printf "$i" | tr 'x' ' ')"
					y=$(($y+1))
				done

				printf "$UNSET_ANSI"
				_gen_key_helper | while read i
				do
					y=$(($y+1))
					_print "$y" "$gen_x" "$i"
				done
			}
		done
	) &

	# get key from standard input
	dd if=/dev/tty count=1 bs=1 >/dev/null 2>&1
	kill -KILL $! || : ## CAUTION: script would exit if set -e
	stty "$init_stty"
	printf "$UNSET_ANSI$SHOW_CUR"
	tput clear
}

__get_cur_session() {
	tmux list-sessions -F '#S:#{session_activity}' | sort -b -t: -k2,2n | tail -n1 | cut -d: -f1
}

__get_pty() {
	tmux list-clients -F '#S:#{client_tty}' | grep -F "$(__get_cur_session):" | cut -d: -f2
}

__new_session() {
	locate_git_repos() {
		find "$1" -mindepth 2 -type d -iname '.git' -exec expr '{}' : '\(.*\)/.git$' \;
	}

	# TODO: cache search results
	local project_list=$(printf "$PROJECT_DIRECTORY\n" | while read pdir; do locate_git_repos "$pdir"; done | tee "$CACHE_PL")
	local project_name=$(printf "$project_list" | sed -nE 's,^.*/(.*)$,\1,p' | awk '{print "["NR"]:"$0}' | eval "$SEARCHER")

	test -z "$project_name" && return

	local project_dir=$(printf "$project_list" | sed -n "$(expr "$project_name" : '\[\([0-9]\+\)\]:.*$')p")
	local session_name=`mktemp -u pr-XXXXXX`

	# Check if session already exist
	for i in "$SESSION_DIR"/*
	do
		local path="$i/path"
		if [ -f "$path" ]
		then
			if [ `cat "$path"` = "$project_dir" ]
			then
				session_name=`basename "$i"`
			fi
		fi
	done

	# Start session with all its watchers
	{
		TMUX=${TMUX:-}
		if ! tmux has-session -t "$session_name"
		then
			if [ -n "$TMUX" ]
			then
				local pty=`__get_pty`

				_setup_session "$project_dir" "$session_name"&
				tmux new-session -s "$session_name" -d
				tmux switch-client -c "$pty" -t "$session_name"
			else
				_setup_session "$project_dir" "$session_name"&
				display_dashboard
				tmux new-session -s "$session_name"
			fi
		else
			if [ -n "$TMUX" ]
			then
				local pty=`__get_pty`

				tmux switch-client -c "$pty" -t "$session_name"
			else
				tmux attach-session -t "$session_name"
			fi
		fi
	} #2>/dev/null
}

# Create a new project tmux session while in an existing session, similer to `func_open'
func_nsession() {
	__new_session
}

_setup_session() {
	local project_dir=$1
	local session_name=$2
	local project_session="$SESSION_DIR/$session_name"

	mkdir -p "$project_session"
	printf "$project_dir" >"$project_session/path"

	local watch_config="$project_session/watch"
	if [ -f "$watch_config" ]
	then
		local fifo
		for pairs in `cat "$watch_config" | sed -ne 's/^s+\[\(.*\)\]: *\(.\+\) *$/(\1)\2/p'`
		do
			local cmd=${pairs#(*)}
			local watcher_name=${pairs%%)*}

			watcher_name=${pairs#(}

			# You would be seeing the std(out|err) of watchers via named-pipes
			fifo="$project_session/$watcher_name.fifo"
			test -p "$fifo" || mkfifo "$fifo"

			{ trap '' HUP
			  cat "$watch_config" \
				| sed -ne "/^s+\[$watcher_name\]:/,/^e\[$watcher_name\]/p" \
				| tail -n +2 \
				| sed '$d' \
				| 
				  case $RUNNER in
				   entr) entr -nr "$cmd" ;;
				   *) : ;;
				  esac >"$fifo"
			} &

			printf "$!" >"$project_session/$watcher_name.pid"
		done
	fi
}

# Select a project and open a tmux session
func_open() {
	local session_name input

	if tmux list-sessions >/dev/null 2>&1
	then
		printf "Choose an existing session to attach\n\n"
		tmux list-sessions | awk '{print "["NR"] "$0}'
	fi
	printf "$WFMUX\n"
	read -p '⟩⟩ ' input
	tput clear

	if [ -n "$(expr "$input" : '\([0-9][0-9]*\)$')" ]
	then
		session_name=$(tmux list-sessions -F '#S' | sed -n "${input}p")
		if [ -n "$session_name" ]
		then
			tmux attach-session -t "$session_name"
		fi
	else
		if [ -n "$(expr "$input" : '\(F\|f\)$')" ]
		then
			__new_session
		elif [ -z "$input" ]
		then
			return 0
		else
			tmux new-session -s "$(printf "$input")"
		fi
	fi
}

__set_whxy() {
	local window_attribute=$1

	y=$(printf "$window_attribute" | sed -e 's/^.*+\([0-9]\+\)$/\1/')
	x=$(printf "$window_attribute" | sed -e 's/^.*+\([0-9]\+\)+.*/\1/')
	w=$(printf "$window_attribute" | sed -e 's/^\([0-9]\+\)x.*/\1/')
	h=$(printf "$window_attribute" | sed -e 's/^.*x\([0-9]\+\).*/\1/')
}

_dump() {

	__set_whxy $WINDOW_ATTRIBUTES_FILE_SELECTOR
	cat <<EOTX
unbind M-$TBIND_SELECT
bind M-$TBIND_SELECT if-shell "command -v wfmux" { display-popup -w $w -h $h -x $x -y $y -E "wfmux select"; }
EOTX

	__set_whxy $WINDOW_ATTRIBUTES_REST
	cat <<EOTX
unbind M-$TBIND_EXPLORE
bind M-$TBIND_EXPLORE if-shell "command -v wfmux" { display-popup -w $w -h $h -x $x -y $y -E "wfmux explore"; }
unbind M-$TBIND_OPS
bind M-$TBIND_OPS if-shell "command -v wfmux" { display-popup -w $w -h $h -x $x -y $y -E "wfmux ops"; }
EOTX

}

func_dump() {
	_dump
}

func_tmux() {
	_dump >>"$TMUX_CONF"
}

__get_project_dir() {
	local session_name=`__get_cur_session`
	local session="$SESSION_DIR/$session_name"

	if [ -d "$session" ]
	then
		local project_dir=`cat "$session/path"`
		test -d "$project_dir" && printf "$project_dir"
	fi
}

func_switch() {
	local base_dir=$(basename `__get_project_dir`)

	__get_projects_basenames() {
		local session
		local project_dir

		tmux list-sessions -F '#S' | while read sname
		do
			session="$SESSION_DIR/$sname"
			if [ -d "$session" ]
			then
				project_dir=$(cat "$session/path")
				if [ -d "$project_dir" ]
				then
					project_dir=$(printf "%s\n" "$project_dir" | sed -e 's,.*/\([^/]*/[^/]*\),\1,')
					printf "%s\n" "$sname:$project_dir" | sed -e "s,/\($base_dir\)$,/\1*,"
				fi
			fi
		done
	}

	local session_pbase=`__get_projects_basenames`
	local pbasename=$(printf "$session_pbase" | cut -d: -f2 | eval "$SEARCHER")

	pbasename=${pbasename%*}
	if [ -n "$pbasename" ]
	then
		local pty=`__get_pty`

		# CAUTION: This is not a BUG!!! (note the head -n1)
		# The differenciation level for every projects are the names of their parent directories only, not uptil the OS's root directory.
		tmux switch-client -c "$pty" -t "$(printf "$session_pbase" | sed -ne "s,\(.*\):$pbasename,\1,p" | head -n1)"
	fi
}

## open your favorite tui file manager
func_explore() {
	local project_dir=`__get_project_dir`
	eval "$EXPLORER" "$project_dir"
}

## select project files to open
func_select() {
	local file
	local new_window=true
	local sh=${SHELL##*/}
	local project_dir=`__get_project_dir`

	test -d "$project_dir" || return

	file=$(
		args=$(printf "$IGNORE" | sed -e '${ s/\(.*\)/-name "\1"/; q; }; 1,${ s/\(.*\)/-name "\1" -or /; }' | tr '\n' ' ')
		eval "find '$project_dir' \( $args \) -prune -or -type f -print | sed -e 's,^$project_dir/,,' | $SEARCHER"
	)

	test -n "$file" || return
	file="$project_dir/$file"

	__give_it_or_do_it() {

		if [ x"$USE_XDG" != xtrue ]
		then
			local mime
			local mime_type=$(xdg-mime query filetype "$file")

			if [ $? = 0 ] && [ -n "$mime_type" ]
			then
				# use `subtype' whenever `type' is `application' otherwise use `type'
				test x"${mime_type%/*}" = x"application" && mime=${mime_type#*/} || mime="${mime_type%/*}"

				local opener=$(printf "$PROGRAMS" | sed -ne "s/^$mime:[[:space:]]*\([^[:space:]]*\)/\1/p")
				opener=${opener:-$EDITOR}
				opener=${opener:-vim}
				{ 
					which "$opener" 1>&2
					if [ $? -eq 0 ]
					then
						# Put in list of all TUI applications that takes a $file as argument
						printf "$opener" | grep -qE '^vim|ranger|cmus|nvim|nnn|kak$'
						if [ $? -eq 0 ]
						then
							printf "$opener '$file'"
						else
							{ trap '' HUP; eval "$opener '$file'"; } &
							tmux display-popup -C
						fi
					fi
				} 2>/dev/null
			fi
		else
			printf "xdg-open '$file'"
		fi
	}

	local command=`__give_it_or_do_it`
	if [ -n "$command" ]
	then
		# start from the most active, ignore the previous one
		for window_index in `tmux list-windows -F '#I:#{window_active}' | awk -F[':'] '$2 == 1{pass = 1}; pass == 1{print $1}'`
		do
			local panes=$(tmux list-panes -t "$window_index" -F '#{pane_current_command}:#P:#{pane_active}')
			local bash_panes=$(printf "$panes" | grep "^${sh:-bash}:")

			# is it an active pane idle? if no then
			# take the most recently opened idle pane
			if [ -n "$bash_panes" ]
			then
				local bash_index=$(printf "$bash_panes" | sed -nE 's/.*:([0-9]+):1$/\1/p')
				test -z "$bash_index" && bash_index=$(printf "$bash_panes" | sort -t: -k2,2n | head -n1 | cut -d: -f2)

				tmux send-keys -t "$window_index.$bash_index" "$command" C-m
				test $? -eq 0 && new_window=false && break
			else
				if [ `printf '%s\n' "$panes" | wc -l` -eq 1 ]
				then
					tmux select-window -t "$window_index"
					tmux split-window  -h "$command"
					test $? -eq 0 && new_window=false && break
				fi
			fi
		done

		test x$new_window = x"true" && tmux new-window "$(__give_it_or_do_it)"
	fi
}

func_commit() {
	__commit
}

func_acommit() {
	__commit true
}

__commit() {
	local editor=$(printf "$PROGRAMS" | sed -ne 's/^[ \t]*text:[ \t]\+\(\w*\)$/\1/p')

	editor=${editor:-$EDITOR}
	editor=${editor:-vim}

	{ command -v git       || return
	  command -v "$editor" || return
	} >/dev/null

	local project_dir=`__get_project_dir`

	if [ -n "$project_dir" ]
	then
		cd "$project_dir"
		if [ $? = 0 ]
		then
			local amend=${1:-false}

			git add .
			if [ "$amend" = false ]
			then
				local tempfile=`mktemp /tmp/.git_XXXXXX`

				$editor "$tempfile"
				# Let git abord if we did not commit with a commit message
				# than trying to introduce a `du'-like command
				git commit --message "$(cat "$tempfile")"
				rm -f "$tempfile"
			else
				git commit --amend
			fi
		fi
	fi
}

func_branch() {
	command -v git >/dev/null || return

	local project_dir=`__get_project_dir`

	cd "$project_dir"
	if [ $? = 0 ]
	then
		if printf "%s\n" "$SEARCHER" | grep -q '^fzf'
		then
			SEARCHER="$SEARCHER --print-query"
		fi

		local branch=$(git branch | sed -e 's/^\(\*\?\) *\(.*\)$/\2\1/' | eval "$SEARCHER" | tail -n1)

		branch=${branch%*}
		if [ -n "$branch" ]
		then
			# Check if the current working branch is clean(nothing to commit)
			git status | tail -n1 | grep -q '^nothing to commit' 
			if [ $? -eq 0 ]
			then
				git checkout "$branch" || git checkout -b "$branch"
			fi
		fi
	fi
}

__input_to_exit() {
	printf "\nPress anything to quit!"
	stty -echo -cooked && dd if=/dev/tty count=1 bs=1 >/dev/null 2>&1
}

func_push() {
	__push
}

func_fpush() {
	__push --force
}

__push() {
	{ command -v git    || return
	  command -v "$TOK" || return
	} >/dev/null

	local project_dir=`__get_project_dir`
	test -n "$project_dir" && project_name=$(basename "$project_dir")

	if [ -n "$project_name" ]
	then
		cd "$project_dir"
		if [ $? -eq 0 ]
		then
			local username
			local remotes=$(printf "$WFMUX_REMOTE" | eval "$SEARCHER")
			local session_path="$SESSION_DIR/$(__get_cur_session)"

			if [ -s "$session_path" ]
			then
				username=$(cat "$session_path/user")
			else
				username=$(printf "$WFMUX_USERS" | eval "$SEARCHER")
				printf "$username" >"$session_path/user"
			fi

			if [ -n "$remotes" ]; then
				local force=${1:---force}
				local proto=https
				local branch=$(git branch | sed -ne 's,^* \(.*\),\1,p')
				local git_config=$(cat .git/config)

				printf "%s\n" "$remotes" | while read remote
				do
					local my_tok=$(eval "$TOK '${remote%%.*}'")

					case $remote in
						codeberg.org | github.com | github.com) proto=https ;;
						*) proto=https ;;
					esac
					test "$remote" = "gitlab.com" && my_tok="$GITLAB_TOK_NAME:$my_tok"

					printf "Pushing to $remote/$username  ";
					{ i=0
					  set -- − \\ \| /
					  while true; do 
						  sleep 0.2
						  i=$(($i+1))
						  eval "printf \"\b\$$(($(($i%4))+1))\""
					  done
					} &

					local failed=No
					git push "$force" --set-upstream "$proto://$my_tok@$remote/$username/$project_name.git" "$branch" >/dev/null 2>&1 || failed=Yes
					kill -KILL $!

					test x"$failed" = x"Yes" && c=1mFailed || c=${DASH_COLOR}mDone
					printf "\b\033[1;3%s$UNSET_ANSI\n" "$c"
				done

				# To avoid saving tokens!
				printf "$git_config" > .git/config
				__input_to_exit
			fi
		fi
	fi
}

# Add a new watcher to the watcher list
func_awatcher() {
	local watcher_name
	local watch_config="$SESSION_DIR/`__get_cur_session`/watch"
	local project_dir=`__get_project_dir`

	printf "Give a name to your watcher: "
	read watcher_name

	if [ -n "$watcher_name" ]
	then
		# Check if this name already exists in the watcher list
		if [ -f "$watch_config" ]
		then
			cat "$watch_config" | grep -q "s[-+]:\[$watcher_name\]" && return
		fi

		local files=$(
			args=$(printf "$IGNORE" | sed -e '${ s/\(.*\)/-name "\1"/; q; }; 1,${ s/\(.*\)/-name "\1" -or /; }' | tr '\n' ' ')
			eval "find '$project_dir' \( $args \) -prune -or -type f -print | sed -e 's,^$project_dir/,,' | $SEARCHER"
		)

		if [ -n "$files" ]
		then
			printf "\033[1;4m"
			if [ -r "$COMMANDS" ]
			then
				local cmd=$(cat "$COMMANDS" | grep -v '^[\t ]*\(#.*\)\?$' | eval "$SEARCHER")
				cat <<-EOF >>"$watch_config"

				s+[$watcher_name]: $cmd
				$files
				e[$watcher_name]
				EOF
				printf "\033[1;3${DASH_COLOR}m"
				printf "'$watcher_name' was successfully added to the list of watchers\n"
			else
				printf "\033[1;31m"
				printf "Could not find the list of commands.\n" >&2
				printf "these commands should be located at '$COMMANDS'\n" >&2
			fi
			printf "${UNSET_ANSI}${UNSET_ANSI}"

			__input_to_exit
		fi
	fi
}

# remove watchers from the watcher list
func_rwatcher() {
	local cur_session=`__get_cur_session`
	local project_session="$SESSION_DIR/$cur_session"
	local watch_config="$project_session/watch"

	[ -n "$cur_session" ] || return
	[ -r "$watch_config" -a -s "$watch_config" ] || return

	local watcher_name=$(cat "$watch_config" | sed -ne 's/^s[-+]\[\(\w*\)\]:.*$/\1/p')
	if [ -n "$watcher_name" ]
	then
		watcher_name=$(printf "$watcher_name" | eval "$SEARCHER")
		if [ -n "$watcher_name" ]
		then
			printf "\033[1;4m"
			if cat "$watch_config" | grep -q "^e\[$watcher_name\]"
			then
				sed -i "/^s+\[$watcher_name\]:/,/^e\[$watcher_name\]/d" "$watch_config"
				if [ $? -eq 0 ]
				then
					if [ -r "$project_session/$watcher_name.pid" ]
					then
						pid=$(cat "$project_session/$watcher_name.pid")
						kill -KILL "$pid" >/dev/null 2>&1
					fi
					printf "\033[1;3${dash_color}m"
					printf "Watcher '$watcher_name' successfully deleted\n"
				else
					printf "\033[1;31m"
					printf "Could not delete watcher\n"
				fi
			else
				printf "\033[1;31m"
				printf "Error: could not find scope of definition of '$watcher_name'\n"
			fi
			printf "${UNSET_ANSI}${UNSET_ANSI}"
		fi
	else
		printf "you do not have any watcher\n"
	fi

	__input_to_exit
}

__ed_watcher() {
	local cur_session=`__get_cur_session`
	local watch_config="$SESSION_DIR/$cur_session/watch"

	[ -z "$cur_session" ] && return
	if [ -r "$watch_config" -a -s "$watch_config" ]
	then
		local watcher_name=$(cat "$watch_config" | sed -ne 's/^s[-+]\[\(\w*\)\]:.*$/\1/p')

		if [ -n "$watcher_name" ]
		then
			watcher_name=$(printf "$watcher_name" | eval "$SEARCHER")
			if [ -n "$watcher_name" ]
			then
				local state=$1
				local to=disable

				[ x$state = x"+" ] && to=enable
				printf "\033[4m\033[3${DASH_COLOR}m"

				sed -ie "s/^s.[$watcher_name]/^s$state[$watcher_name]/" "$watch_config"

				printf "Watcher '$watcher_name' ${to}d\n"
				printf "${UNSET_ANSI}${UNSET_ANSI}"
			fi
		else
			printf "you do not have any watcher\n"
		fi

		__input_to_exit
	fi
}

# enable watchers, should run when creating tmux session
func_ewatcher() {
	__ed_watcher +
}

# disable watchers, don't run this watcher when creating tmux sessions
func_rwatchers() {
	__ed_watcher -
}

# fancy view of the watchers
func_view() {
	:;
}

# Cycle through std(out&stderr) of project watchers
func_cycle() {
	local cur_session=`__get_cur_session`
	local project_fifos="$SESSION_DIR/$cur_session/fifos"

	[ -z "$cur_session" ] && return
	local watcher_name

	cd "$project_fifo"
	if [ $? -eq 0 ]
	then
		for fifo in *
		do
			watcher_name=${fifo%.fifo}
			if [ -n "$watcher_name" ]
			then
				printf "\033[1;4${DASH_COLOR}${watcher_name}${UNSET_ANSI}${BOLD}\n"
				cat "$fifo" | less --RAW-CONTROL-CHARS
				printf "$UNSET_ANSI"
			fi
		done
	fi
}

# Wrap all operations, plugins appear here
func_ops() {

	_load_plugins() {
		:;
	}

	[ -z `__get_project_dir` ] && return

	local ops=$(
	    printf "commit
acommit
branch
runner
explore
select
dwatcher
ewatcher
awatcher
rwatcher
view
cycle
nsession
switch
fpush
push" | eval "$SEARCHER")

	test -n "$ops" && {
		trap '' HUP

		case $ops in
			select)
				__set_whxy $WINDOW_ATTRIBUTES_FILE_SELECTOR ;;
			commit   | \
			acommit  | \
			runner   | \
			branch   | \
			explore  | \
			push     | \
			fpush    | \
			dwatcher | \
			ewatcher | \
			awatcher | \
			rwatcher | \
			view     | \
			cycle    | \
			nsession | \
			switch)
				__set_whxy $WINDOW_ATTRIBUTES_REST ;;
		esac

		tmux display-popup -w $w -h $h -x $x -y $y -E "/home/kueppo/projects/wfmux/src/wfmux $ops"
		#tmux display-popup -w $w -h $h -x $x -y $y -E "wfmux $ops"
	} &

	tmux display-popup -C
}

func_main "$@"
