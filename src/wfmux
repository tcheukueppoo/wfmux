#!/bin/sh

#set -x
set -ue

readonly alt_screen='\033[?1049h'
readonly normal_screen='\033[?1049l'
readonly hide_cur='\033[?25l'
readonly show_cur='\033[?25h'
readonly clear_screen='\033[2J'
readonly bold='\033[1m'
readonly unset_ansi='\033[0m'
readonly program=${0##*/}
readonly config_dir="${XDG_CONFIG_HOME:-"$HOME/.config"}"
readonly wfmux_config_dir="${config_dir%%/}/wfmux/"
readonly cache_dir="${XDG_CACHE_HOME:-"$HOME/.cache"}"
readonly cache="${cache_dir%%/}/wfmux"
readonly cache_pl="${cache_dir}/wfmux.pl"
readonly session_dir="${cache_dir%%/}/wfmux/sessions"
readonly tmux_conf="$HOME/.tmux.conf"

mkdir -p "$config_dir" "$cache_dir" "$cache" "$session_dir" "$wfmux_config_dir"

readonly logo_ls=$(cat <<EOF
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx┌────────────
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx┌───────
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxxxxxxxxxxxxxxx┌───┐xxxxxxxxxx│
xxxxxxxxxxxx┌──┐xxxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxxxxxxxxxxxxxxx│xxx│xxxxxxxxxx│
xxxxxxxxxxxx│xx│xxxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxxxxxxxxxxxxxxx│xxx│xxxxxxxxxx│
xxxxxxxxxxxx│xx│xxxxxxxxxxx┌────┼─────┬─────┬──────┬──┐xxxxxxx│xxx│xxxx┌─────┘
xxxxxxxxxxxx│xx│xxxxx┌─xxxx│xxxx│xxxxx│xxxxx│xxxxxx│xx│xxxxxxx│xxx│xxxx│
────────────┘xx│xxxxx│xxxxx│xxxx│xxxxx│xxxxx│xxxxxx│xx│xxxxxxx│xxx└────┼─────┐
xxxxxxxxxxxxxxx│xxxxx│xxxxx│xxxx│xxxxx│xxxxx│xxxxxx│xx│xxxxxxx│xxxxxxxx│xxxxx│
xxxxxxxxxxxxxxx│xxxxx│xxxxx│xxxx│xxxxx│xxxxx└────xx│xx└───────┘xxxxxxxx│xxxxx│
xxxxxxxxxxxxxxx├─────┴─────┘xxxx│xxxxx│xxxxxxxxxxxx└──xxxxxxxxxxxxxxxxx│xxxxx│
xxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxx│xxxx─┘xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│xxxxx│
xxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxx│xxxxxxxxxxxx──────────────────────────┘xxxxx│
xxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxx└─xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│
xxxxxxxxx──────┘xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│
EOF
)
readonly logo_ms=$(cat <<EOF
xxxxxxxxxxxxxxxxxxxxx┌─────xxxxxxxxxxxxxxxxxxxxxxxxxxx┌───
xxxxxxxxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│
xxxxxxxx┌─┐xxxxxxxxxx│xxxxxxxxxxxxxxxxxxxxxx┌──┐xxxxxx│
xxxxxxxx│x│xxxxxxx┌──┼───┬───┬───┬────┐xxxxx│xx│xx┌───┘
xxxxxxxx│x│xxx┌─xx│xx│xxx│xxx│xxx│xxxx│xxxxx│xx│xx│
────────┘x│xxx│xxx│xx│xxx│xxx│xxx│xxxx│xxxxx│xx└──┼───┐
xxxxxxxxxx│xxx│xxx│xx│xxx│xxx│xxx│xxxx│xxxxx│xxxxx│xxx│
xxxxxxxxxx├───┴───┘xx│xx─┘xxx└─xx│xxxx└─────┘xxxxx│xxx│
xxxxxxxxxx│xxxxxxxxxx└─xxxxxxxxxx└──xxxxxxxxxxxxxx│xxx│
xxxxxxxxxx│xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx─────────┘xxx│
xxxxxxx───┘xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│
EOF
)
readonly logo_ss='WFMUX'

readonly wfmux=$(cat<<EOF

     ┌──────────────┤ WFMUX
    ┌┴─────────────────────────────────────────────────┐
    │                                                  │
    ├───── Input a name for a new tmux session         │
    │                                                  │
    ├───── Input f⟨return⟩ to select a project         │
    │                                                  │
    ├───── Input ⟨return⟩ to drop to the terminal      │
    │                                                  │
    └──────────────────────────────────────────────────┘
EOF
)

wfmux_config="${config_dir%%/}/wfmux/wfmux.conf"
use_xdg=yes
runner=entr
runner_templates="$HOME/.config/wfmux/rtemplate"
dash_color=4
explorer=nnn
ignore=.git
searcher='fzf --multi --border=bottom --margin=25%'
window_attributes_rest=20x20+10+20
window_attributes_file_selector=20x20+10+20
window_attributes_input_box=20x20+10+20
tbind_ops==
tbind_explore=BSpace
tbind_select=Enter

project_directory=$(cat <<-EOF
	$HOME/projects
	$HOME/aprojects
	$HOME/oprojects
	EOF
)

programs=$(cat <<-EOF
	pdf:      zathura
	text:     nvim
	video:    ffmpeg
	audio:    aplay
	image:    feh
	database: program_name
	EOF
)

usage() {
	cat <<EOF
Build an awesome dev workflow with tmux, fzf, nnn, and entr.
usage: wfmux [ [-c|-config|--config] *config_file* ] *operation_name*
       wfmux [ -h | -help | --help ]

Options:
     -h, -help, --help             print this help message.
     -c, -config, --config *FILE*  load *FILE* configuration file.

Operation names:
    open      fuzzyly select a project and open a new tmux session.
    runner    set commands to run when files change.
    explore   open your favorite file manager on a popup tmux pane.
    select    fuzzyly select a file to open provided that they exist
              a recently used tmux session which carries the name of your
              project.
    commit    add to the index and commit changes to local repository.
    push      push to the preconfigured remote repositories.
    switch    fuzzyly switch between branches of your local repository.
    dump      dump wfmux's tmux configuration to stdout.
	 tmux      update wfmux's tmux configuration at ~/.tmux.conf.
    ops       a wrapper to the above operations.
EOF
	exit $1
}

die() {
	printf "$*\n" >&2
	exit 1
}

main() {
	local operation=
	local gave_config=false

	[ $# -eq 0 ] && usage 1
	until [ $# -eq 0 ]
	do
		case "$1" in
		-h|-help|--help)
			usage 0 ;;
		-c|-config|--config)
			[ $# -eq 1 ] && wfmux_config=$2 || usage 1
			gave_config=true
			shift ;;
		push|commit|select|explore|auto|open|tmux|dump|ops)
			operation=$1
			if [ -f "$wfmux_config" ]
			then
				[ -r "$wfmux_config" ] || die "no permission to read '$wfmux_config'"
				. $wfmux_config        || die "could not source configuration file"
			fi ;;
		*)
			die "'$1' is an unrecognized option, please try \`$program --help'" ;;
		esac
		shift
	done
	if [ $gave_config = true ]
	then
		check_config_variables
	else
		# use default config "~/.config/wfmux.conf" is possible
		if [ -f "$wfmux_config" -a -r "$wfmux_config" ]
		then
			check_config_variables
		fi
	fi
	eval "func_$operation"
}

## Check if variables are unset or null	and if set then
## check if the data is somehow our expectation.
## we won't have to rely on `set -u`, we would want to output a custom 
## error message if one of these variables aren't set/sane.
check_config_variables() {
	_error="$program: ('$wfmux_config'):"
	for para in \
		         use_xdg \
		         runner \
		         searcher \
		         explorer \
		         window_attributes_rest \
		         window_attributes_input_box \
		         window_attributes_file_selector \
		         project_directory \
		         tbind_ops \
		         tbind_select \
		         tbind_explore
	do
		eval "para=\${$para:-UNSET}"
		if [ "$para" = UNSET ]
		then
			die "$_error '$para' isn't set"
		fi
	done

	_config_die() {
		die "$_error invalid value assigned to '$1'"
	}

	## Check if we got sane values
	{
		window_regex='[[:digit:]]\+x[[:digit:]]\++[[:digit:]]\++[[:digit:]]\+$'
		expr "$window_attributes_rest"          : "$window_regex" || _config_die window_attributes_rest
		expr "$window_attributes_file_selector" : "$window_regex" || _config_die window_attributes_file_selector
		expr "$window_attributes_input_box"     : "$window_regex" || _config_die window_attributes_input_box
		expr "$use_xdg"                         : 'true\|false$'  || _config_die use_xdg
		expr "$dash_color"                      : '[0-9]$'        || _config_die dash_color
	} >/dev/null

	for i in explorer runner searcher
	do
		eval "command -v" "\${$i} >/dev/null" || die "$_error '$i' not found"
	done

	# IFS=$'\n' won't expand '\n' on dash, thus `for i in $pro...' or a simple use of `$pro..` might not work as intended
	printf "$project_directory" |
	while read i
	do
		test -d "$i" || die "$_error '$i' is not a directory"
		test -r "$i" || die "$_error cannot list content of '$i'"
	done
}

decode_dots() { tr "\034" .; }
encode_dots() { tr . "\034"; }

encode_dash() { tr - '⁓' | tr / -; }
decode_dash() { tr - /   | tr '⁓' -; }

display_dashboard() {
	term_h=
	term_w=
	put_color="\033[3${dash_color:-9}m"
	max="awk 'BEGIN{len = 0}; {nlen = length(\$0); if (nlen > len) len = nlen;}; END{print len}'"

	# generate help message for the dashboard
	_gen_key_helper() {
		cat <<-EOF
			The following are tmux bindings related to WFMUX.

			M-$tbind_select: fuzzyly open project files
			M-$tbind_explore: open file manager
			M-$tbind_ops: fuzzyly select other wfmux operations

			input any key to exit dashboard
		EOF
	}

	_print() {
		printf "\033[$1;$2f$3" >/dev/tty
	}

	# save initial terminal setting and will set it back after exiting dashboard
	init_stty="$(stty -g)"
	stty -cooked -echo time 0 min 1
	printf "${alt_screen}${hide_cur}${clear_screen}"

	(
		while true; do
			if [ "$(stty -F /dev/tty size)" = "$term_h $term_w" ]
			then
				sleep 2
				continue
			fi
			term_h="$(stty -F /dev/tty size | cut -d' ' -f1)"
			term_w="$(stty -F /dev/tty size | cut -d' ' -f2)"
			if   [ $term_h -lt 32 -o $term_w -lt 97  ]
			then
				_size=ss
			elif [ $term_h -lt 43 -o $term_w -lt 155 ]
			then
				_size=ms
			else
				_size=ls
			fi
			eval 'logo_h=$(printf "$logo_'$_size'" | wc -l);
				  logo_w=$(printf "$logo_'$_size'" | eval "$max")'

			logo_h="$(expr $logo_h + `_gen_key_helper | wc -l`)"
			gen_w="$(_gen_key_helper | eval "$max")"
			x="$(expr $term_w / 2 - $logo_w / 2)"
			y="$(expr $term_h / 2 - $logo_h / 2)"
			if [ $gen_w -gt $logo_w ]
			then
				gen_x="$(expr $x - \( $gen_w  - $logo_w \) / 2)"
			else
				gen_x="$(expr $x + \( $logo_w - $gen_w  \) / 2)"
			fi

			printf "${clear_screen}${put_color}${bold}"
			eval 'printf "$logo_'$_size'"' | {
				while read i
				do
					_print $y $x "$(printf "$i" | tr 'x' ' ')"
					y="$(($y+1))"
				done

				printf "$unset_ansi"
				_gen_key_helper | while read i
				do
					y="$(($y+1))"
					_print $y $gen_x "$i"
				done
			}
		done
	) &

	# get key from standard input
	dd if=/dev/tty count=1 bs=1 >/dev/null 2>&1
	kill -SIGKILL $! || : [[[[CAUTION: script would exit if set -e]]]]
	stty "$init_stty"
	printf "${unset_ansi}${show_cur}"
	tput clear
}

## select a project and open a tmux session
## refer to usage() function for more information
func_open() {
	local session_name input

	if tmux list-sessions >/dev/null 2>&1
	then
		printf "Choose an existing session to attach\n\n"
		tmux list-sessions | awk '{print "["NR"] "$0}'
	fi
	printf "$wfmux\n"
	read -p '⟩⟩ ' input
	tput clear

	if [ -n "$(expr "$input" : '\([0-9][0-9]*\)$')" ]
	then
		session_name="$(tmux list-sessions -F '#S' | sed -n "${input}p")"
		if [ -n "$session_name" ]
		then
			tmux attach-session -t "$session_name"
		fi
	else
		if [ -n "$(expr "$input" : '\(F\|f\)$')" ]
		then
			local ran_find project_list
			local must_find=false

			find_git_repos() {
				find "$1" -mindepth 2 -type d -iname '.git' -exec expr '{}' : '\(.*\)/.git$' \;
			}
			[ -e "$cache_pl" ] || touch "$cache_pl"
			project_list=$(
				printf "$project_directory" | {
					while read p
					do
						if [ "$p" -nt "$cache_pl" ]
						then
							must_find=true
						fi
						$must_find || { set -- "$@" "$p"; continue; }
						find_git_repos "$p" | tee ${ran_find--a} "$cache_pl"
						unset ran_find
					done
					if $must_find
					then # go through the rest
						for p in "$@"; do find_git_repos "$p" | tee -a "$cache_pl"; done
					fi
				}
			)
			if [ -z "$project_list" ]
			then
				project_list="$(cat "$cache_pl")"
			fi

			project_name=$(
				  printf "$project_list" \
				| sed -nE 's,^.*/(.*)$,\1,p' \
				| awk '{print "["NR"]:"$0}' \
				| eval "$searcher"
			)
			[ -z "$project_name" ] && return

			project_dir="$(printf "$project_list" | sed -n "$(expr "$project_name" : '\[\([0-9]\+\)\]:.*$')p" | encode_dots)"
			session_name="$(printf "$project_dir" | encode_dash)"
			{
				if ! tmux has-session -t "$session_name"
				then
					display_dashboard
					_setup_session "$project_dir" "$session_name"&
					tmux new-session -s "$session_name"
				else
					# Assume the watchers have already been started and attach the session to the controlling terminal
					tmux attach-session -t "$session_name"
				fi
			} 2>/dev/null
		elif [ -z "$input" ]
		then
			return 0
		else
			tmux new-session -s "$(printf "$input" | encode_dots | encode_dash)"
		fi
	fi
}

_setup_session() {
	local project_dir="$1"
	local project_session="$session_dir/$2"
	local watch_config="$session_dir/$2/watch"

	if [ -f "$watch_config" ]
	then
		local fifo
		for i in `cat "$watch_config" | sed -ne 's/^s:\[\(.*\)\].*/\1/p'`
		do
			fifo="$project_session/${i}_fifo"
			test -p "$fifo" || mkfifo "$fifo"
			#wxwatch "$runner" "$i" "$watch_config" >"$fifo" &
		done
	fi

	mkdir -p "$project_session"
}

__set_whxy() {
	local window_attributes="$1"

	y="$(printf "$window_attributes" | sed -e 's/^.*+\([0-9]\+\)$/\1/')"
	x="$(printf "$window_attributes" | sed -e 's/^.*+\([0-9]\+\)+.*/\1/')"
	w="$(printf "$window_attributes" | sed -e 's/^\([0-9]\+\)x.*/\1/')"
	h="$(printf "$window_attributes" | sed -e 's/^.*x\([0-9]\+\).*/\1/')"
}

_dump() {
	__set_whxy $window_attributes_file_selector
	cat <<-EOTX
		unbind M-$tbind_select
		bind M-$tbind_select if-shell "command -v wfmux" { display-popup -w $w -h $h -x $x -y $y -E "wfmux select"; }
	EOTX

	__set_whxy $window_attributes_rest
	cat <<-EOTX
		unbind M-$tbind_explore
		bind M-$tbind_explore if-shell "command -v wfmux" { display-popup -w $w -h $h -x $x -y $y -E "wfmux explore"; }
		unbind M-$tbind_ops
		bind M-$tbind_ops if-shell "command -v wfmux" { display-popup -w $w -h $h -x $x -y $y -E "wfmux ops"; }
	EOTX
}

func_dump() {
	_dump
}

func_tmux() {
	_dump >> "$tmux_conf"
}

_get_session_name() {
	tmux list-sessions -F '#S:#{session_activity}' | sort -b -t: -k 2,2n | tail -n1 | cut -d: -f1 | decode_dots
}

## open your favorite tui file manager
func_explore() {
	local session_name=`_get_session_name`
	local project_dir=`printf -- "$session_name" | decode_dash`

	echo "$session_name, $project_dir"
	if [ -d "$project_dir" -a -d "$session_dir/$session_name" ]
	then
		eval "$explorer" "$project_dir"
	fi
}

## select project files to open
func_select() {
	set -x
	local file
	local new_window=true
	local sh=${SHELL##*/}
	local project_dir=`_get_session_name | decode_dash`

	[ -d "$project_dir" ] || return

	file=$(
		args=`
			printf "$ignore" |
			sed \
			   -e '
			   ${ 
				 s/\(.*\)/-name "\1"/
				 q
			   }
			   1,${ 
				 s/\(.*\)/-name "\1" -or /
			   }' |
			tr '\n' ' '
		`
		eval "find '$project_dir' \( $args \) -prune -or -type f -print | $searcher"
	)
	test -n "$file" || return

	_open_file() {
		if [ x"$use_xdg" != xtrue ]
		then
			local mime_type="$(xdg-mime query filetype "$file")"
			if [ $? = 0 -a -n "$mime_type" ]
			then
				local opener="$(printf "$programs" | sed -ne "s/^${mime_type%/*}:[[:space:]]*\([^[:space:]]*\)/\1/p")"
				which "$opener" >/dev/null 2>&1 && printf "$opener '$file'"
			fi
		else
			printf "xdg-open '$file'"
		fi
	}

	for wid in $(
	      tmux list-window -F '#{window_activity}:#I' \
	    | sort -r -t: -k 1,1n \
		| cut -d: -f2
	)
	do
		local panes=`tmux list-panes -t $wid -F '#{pane_current_command}:#P:#{pane_active}'`
		local bash_panes=`printf "$panes" | grep "^${sh:-bash}:"`

		if [ -n "$bash_panes" ]
		then
			# is it an idle active pane?
			local bash_id=`printf "$bash_panes" | sed -nE 's/.*:([0-9]+):1$/\1/p'`
			if [ -z "$bash_id" ]
			then
				# take the most recently opened idle pane
				bash_id=`printf "$bash_panes" | sort -t: -k 2,2n | head -n1 | cut -d: -f2`
			fi
			tmux send-keys -t "$wid.$bash_id" "$(_open_file)" C-m
			test $? -eq 0 && new_window=false && break
		else
			if [ `printf '%s\n' "$panes" | wc -l` -eq 1 ]
			then
				tmux select-window -t "$wid"
				tmux split-window -h "$(_open_file)"
				test $? -eq 0 && new_window=false && break
			fi 
		fi
	done

	test $new_window = true && tmux new-window "$(_open_file)"
}

switch()   { :; }
commit()   { :; }
runner()   { :; }


main "$@"
