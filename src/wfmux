#!/bin/sh

#set -x
set -ue

readonly alt_screen='\033[?1049h'
readonly normal_screen='\033[?1049l'
readonly hide_cur='\033[?25l'
readonly show_cur='\033[?25h'
readonly clear_screen='\033[2J'
readonly bold='\033[1m'
readonly unset_ansi='\033[0m'
readonly program=${0##*/}
readonly config_dir=${XDG_CONFIG_HOME:-"$HOME/.config"}
readonly wfmux_config_dir="${config_dir%%/}/wfmux/"
readonly cache_dir=${XDG_CACHE_HOME:-"$HOME/.cache"}
readonly cache="${cache_dir%%/}/wfmux"
readonly cache_pl="${cache_dir}/wfmux.pl"
readonly session_dir="${cache_dir%%/}/wfmux/sessions"
readonly tmux_conf="$HOME/.tmux.conf"

mkdir -p "$config_dir" "$cache_dir" "$cache" "$session_dir" "$wfmux_config_dir"

readonly logo_ls=$(cat <<EOF
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx┌────────────
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx┌───────
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxxxxxxxxxxxxxxx┌───┐xxxxxxxxxx│
xxxxxxxxxxxx┌──┐xxxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxxxxxxxxxxxxxxx│xxx│xxxxxxxxxx│
xxxxxxxxxxxx│xx│xxxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxxxxxxxxxxxxxxx│xxx│xxxxxxxxxx│
xxxxxxxxxxxx│xx│xxxxxxxxxxx┌────┼─────┬─────┬──────┬──┐xxxxxxx│xxx│xxxx┌─────┘
xxxxxxxxxxxx│xx│xxxxx┌─xxxx│xxxx│xxxxx│xxxxx│xxxxxx│xx│xxxxxxx│xxx│xxxx│
────────────┘xx│xxxxx│xxxxx│xxxx│xxxxx│xxxxx│xxxxxx│xx│xxxxxxx│xxx└────┼─────┐
xxxxxxxxxxxxxxx│xxxxx│xxxxx│xxxx│xxxxx│xxxxx│xxxxxx│xx│xxxxxxx│xxxxxxxx│xxxxx│
xxxxxxxxxxxxxxx│xxxxx│xxxxx│xxxx│xxxxx│xxxxx└────xx│xx└───────┘xxxxxxxx│xxxxx│
xxxxxxxxxxxxxxx├─────┴─────┘xxxx│xxxxx│xxxxxxxxxxxx└──xxxxxxxxxxxxxxxxx│xxxxx│
xxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxx│xxxx─┘xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│xxxxx│
xxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxx│xxxxxxxxxxxx──────────────────────────┘xxxxx│
xxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxx└─xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│
xxxxxxxxx──────┘xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│
EOF
)
readonly logo_ms=$(cat <<EOF
xxxxxxxxxxxxxxxxxxxxx┌─────xxxxxxxxxxxxxxxxxxxxxxxxxxx┌───
xxxxxxxxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│
xxxxxxxx┌─┐xxxxxxxxxx│xxxxxxxxxxxxxxxxxxxxxx┌──┐xxxxxx│
xxxxxxxx│x│xxxxxxx┌──┼───┬───┬───┬────┐xxxxx│xx│xx┌───┘
xxxxxxxx│x│xxx┌─xx│xx│xxx│xxx│xxx│xxxx│xxxxx│xx│xx│
────────┘x│xxx│xxx│xx│xxx│xxx│xxx│xxxx│xxxxx│xx└──┼───┐
xxxxxxxxxx│xxx│xxx│xx│xxx│xxx│xxx│xxxx│xxxxx│xxxxx│xxx│
xxxxxxxxxx├───┴───┘xx│xx─┘xxx└─xx│xxxx└─────┘xxxxx│xxx│
xxxxxxxxxx│xxxxxxxxxx└─xxxxxxxxxx└──xxxxxxxxxxxxxx│xxx│
xxxxxxxxxx│xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx─────────┘xxx│
xxxxxxx───┘xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│
EOF
)
readonly logo_ss='WFMUX'

readonly wfmux=$(cat<<EOF

     ┌──────────────┤ WFMUX
    ┌┴─────────────────────────────────────────────────┐
    │                                                  │
    ├───── Input a name for a new tmux session         │
    │                                                  │
    ├───── Input f⟨return⟩ to select a project         │
    │                                                  │
    ├───── Input ⟨return⟩ to drop to the terminal      │
    │                                                  │
    └──────────────────────────────────────────────────┘
EOF
)

username=username
tok=tok
gitlab_tok_name=gitlab_token_name
wfmux_config="${config_dir%%/}/wfmux/wfmux.conf"
use_xdg=yes
runner=entr
runner_templates="$HOME/.config/wfmux/rtemplate"
dash_color=4
explorer=nnn
ignore=.git
searcher='fzf --multi --border=bottom --margin=25%'
window_attributes_rest=20x20+10+20
window_attributes_file_selector=20x20+10+20
window_attributes_input_box=20x20+10+20
tbind_ops==
tbind_explore=BSpace
tbind_select=Enter

project_directory=$(cat <<-EOF
	$HOME/projects
	$HOME/aprojects
	$HOME/oprojects
	EOF
)

programs=$(cat <<-EOF
	pdf:      zathura
	text:     nvim
	video:    ffmpeg
	audio:    aplay
	image:    feh
	database: program_name
	EOF
)

usage() {
	cat <<EOF
Build an awesome dev workflow with tmux, fzf, nnn, and entr.
usage: wfmux [ [-c|-config|--config] *config_file* ] *operation_name*
       wfmux [ -h | -help | --help ]

Options:
     -h, -help, --help             print this help message.
     -c, -config, --config *FILE*  load *FILE* configuration file.

Operation names:
    open         fuzzyly select a project and open a new tmux session.
    nsession     create a new project tmux session while in a tmux session.
    switch      switch between project sessions
    explore      open your favorite file manager on a popup tmux pane.
    select       fuzzyly select a file to open provided that they exist
                 a recently used tmux session which carries the name of your
                 project.   
    commit       add to the index and commit changes to local repository.
    acommit      replace the tip of the current branch by creating a new commit
    push         push to the remote repositories.
    fpush        force-push to the remote repositories.
    branch       fuzzyly switch between branches of your local repository.
    dump         dump wfmux's tmux configuration to stdout.
    tmux         update wfmux's tmux configuration at ~/.tmux.conf.
    ops          a wrapper to the above operations.
    dwatcher     disable a watcher from the watcher list
    ewatcher     enable a watcher from the watcher list
    awatcher     add a new watcher to the watcher list
    rwatcher     remove a new watcher to the watcher list
    view         fancy view of any existing running project watcher.

EOF
	exit "$1"
}

die() {
	printf "$*\n" >&2
	exit 1
}

func_main() {
	local operation=
	local gave_config=false

	[ $# -eq 0 ] && usage 1
	until [ $# -eq 0 ]
	do
		case "$1" in
		-h | -help | --help)
			usage 0 ;;
		-c | -config | --config)
			[ $# -eq 1 ] && wfmux_config=$2 || usage 1
			gave_config=true
			shift ;;
		push     | \
		fpush    | \
		commit   | \
		acommit  | \
		select   | \
		explore  | \
		open     | \
		tmux     | \
		dump     | \
		ops      | \
		view     | \
		awatcher | \
		dwatcher | \
		ewatcher | \
		rwatcher | \
		branch   | \
		nsession | \
		switch)
			operation=$1
			if [ -f "$wfmux_config" ]
			then
				[ -r "$wfmux_config" ] || die "no permission to read '$wfmux_config'"
				. $wfmux_config        || die "could not source configuration file"
			fi ;;
		*)
			die "'$1' is an unrecognized option, please try \`$program --help'" ;;
		esac
		shift
	done

	if [ $gave_config = true ]
	then
		check_config_variables
	else
		# use default config "~/.config/wfmux.conf" is possible
		if [ -f "$wfmux_config" -a -r "$wfmux_config" ]
		then
			check_config_variables
		fi
	fi

	eval "func_$operation"
}

## Check if variables are unset or null	and if set then
## check if the data is somehow our expectation.
## we won't have to rely on `set -u`, we would want to output a custom 
## error message if one of these variables aren't set/sane.
check_config_variables() {
	_error="$program: ('$wfmux_config'):"
	for para in \
		         use_xdg \
		         runner \
		         searcher \
		         explorer \
		         window_attributes_rest \
		         window_attributes_input_box \
		         window_attributes_file_selector \
		         project_directory \
		         tbind_ops \
		         tbind_select \
		         tbind_explore
	do
		eval "para=\${$para:-UNSET}"
		if [ "$para" = UNSET ]
		then
			die "$_error '$para' isn't set"
		fi
	done

	_config_die() {
		die "$_error invalid value assigned to '$1'"
	}

	## Check if we got sane values
	{
		window_regex='[[:digit:]]\+x[[:digit:]]\++[[:digit:]]\++[[:digit:]]\+$'
		expr "$window_attributes_rest"          : "$window_regex" || _config_die window_attributes_rest
		expr "$window_attributes_file_selector" : "$window_regex" || _config_die window_attributes_file_selector
		expr "$window_attributes_input_box"     : "$window_regex" || _config_die window_attributes_input_box
		expr "$use_xdg"                         : 'true\|false$'  || _config_die use_xdg
		expr "$dash_color"                      : '[0-9]$'        || _config_die dash_color
	} >/dev/null

	for i in explorer runner searcher
	do
		eval "command -v" "\${$i} >/dev/null"
		test $? -ne 0 && die "$_error '$i' not found"
	done

	# IFS=$'\n' won't expand '\n' on dash shell
	printf "$project_directory" |
	while read i
	do
		test -d "$i" || die "$_error '$i' is not a directory"
		test -r "$i" || die "$_error cannot list content of '$i'"
	done
}

display_dashboard() {
	local put_color="\033[3${dash_color:-9}m"
	local max="awk 'BEGIN{len = 0}; {nlen = length(\$0); if (nlen > len) len = nlen;}; END{print len}'"

	# generate help message for the dashboard
	_gen_key_helper() {
		cat <<-EOF
			The following are tmux bindings related to WFMUX.

			M-$tbind_select: fuzzyly open project files
			M-$tbind_explore: open file manager
			M-$tbind_ops: fuzzyly select other wfmux operations

			input any key to exit dashboard
		EOF
	}

	_print() {
		printf "\033[$1;$2f$3" >/dev/tty
	}

	# save initial terminal setting and will set it back after exiting dashboard
	local init_stty=$(stty -g)
	stty -cooked -echo time 0 min 1
	printf "${alt_screen}${hide_cur}${clear_screen}"

	(
		term_h= term_w=
		while true; do
			if [ "$(stty -F /dev/tty size)" = "$term_h $term_w" ]
			then
				sleep 2
				continue
			fi
			term_h=$(stty -F /dev/tty size | cut -d' ' -f1)
			term_w=$(stty -F /dev/tty size | cut -d' ' -f2)
			if   [ $term_h -lt 32 -o $term_w -lt 97  ]
			then
				_size=ss
			elif [ $term_h -lt 43 -o $term_w -lt 155 ]
			then
				_size=ms
			else
				_size=ls
			fi
			eval 'logo_h=$(printf "$logo_'$_size'" | wc -l);
				  logo_w=$(printf "$logo_'$_size'" | eval "$max")'

			logo_h=$(expr $logo_h + `_gen_key_helper | wc -l`)
			gen_w=$(_gen_key_helper | eval "$max")
			x=$(expr $term_w / 2 - $logo_w / 2)
			y=$(expr $term_h / 2 - $logo_h / 2)
			if [ $gen_w -gt $logo_w ]
			then
				gen_x=$(expr $x - \( $gen_w  - $logo_w \) / 2)
			else
				gen_x=$(expr $x + \( $logo_w - $gen_w  \) / 2)
			fi

			printf "${clear_screen}${put_color}${bold}"
			eval 'printf "$logo_'$_size'"' | {
				while read i
				do
					_print $y $x "$(printf "$i" | tr 'x' ' ')"
					y=$(($y+1))
				done

				printf "$unset_ansi"
				_gen_key_helper | while read i
				do
					y=$(($y+1))
					_print "$y" "$gen_x" "$i"
				done
			}
		done
	) &

	# get key from standard input
	dd if=/dev/tty count=1 bs=1 >/dev/null 2>&1
	kill -KILL $! || : ## CAUTION: script would exit if set -e
	stty "$init_stty"
	printf "$unset_ansi$show_cur"
	tput clear
}

__get_cur_session() {
	tmux list-sessions -F '#S:#{session_activity}' | sort -b -t: -k 2,2n | tail -n1 | cut -d: -f1
}

__get_pty() {
	tmux list-clients -F '#S:#{client_tty}' | grep -F "$(__get_cur_session):" | cut -d: -f2
}

__new_session() {
	locate_git_repos() {
		find "$1" -mindepth 2 -type d -iname '.git' -exec expr '{}' : '\(.*\)/.git$' \;
	}

	# TODO: cache search results
	local project_list=$(printf "$project_directory\n" | while read pdir; do locate_git_repos "$pdir"; done | tee "$cache_pl")
	local project_name=$(printf "$project_list" | sed -nE 's,^.*/(.*)$,\1,p' | awk '{print "["NR"]:"$0}' | eval "$searcher")

	test -z "$project_name" && return

	local project_dir=$(printf "$project_list" | sed -n "$(expr "$project_name" : '\[\([0-9]\+\)\]:.*$')p")
	local session_name=`mktemp -u pr-XXXXXX`

	# Check if session already exist
	for i in "$session_dir"/*
	do
		local path="$i/path"
		if [ -f "$path" ]
		then
			if [ `cat "$path"` = "$project_dir" ]
			then
				session_name=`basename "$i"`
			fi
		fi
	done

	# Start session with all its watchers
	{
		TMUX=${TMUX:-}
		if ! tmux has-session -t "$session_name"
		then
			if [ -n "$TMUX" ]
			then
				local pty=`__get_pty`

				_setup_session "$project_dir" "$session_name"&
				tmux new-session -s "$session_name" -d
				tmux switch-client -c "$pty" -t "$session_name"
			else
				_setup_session "$project_dir" "$session_name"&
				display_dashboard
				tmux new-session -s "$session_name"
			fi
		else
			if [ -n "$TMUX" ]
			then
				local pty=`__get_pty`

				tmux switch-client -c "$pty" -t "$session_name"
			else
				tmux attach-session -t "$session_name"
			fi
		fi
	} #2>/dev/null
}

# Create a new project tmux session while in an existing session, similer to `func_open'
func_nsession() {
	__new_session
}

# Select a project and open a tmux session
func_open() {
	local session_name input

	if tmux list-sessions >/dev/null 2>&1
	then
		printf "Choose an existing session to attach\n\n"
		tmux list-sessions | awk '{print "["NR"] "$0}'
	fi
	printf "$wfmux\n"
	read -p '⟩⟩ ' input
	tput clear

	if [ -n "$(expr "$input" : '\([0-9][0-9]*\)$')" ]
	then
		session_name=$(tmux list-sessions -F '#S' | sed -n "${input}p")
		if [ -n "$session_name" ]
		then
			tmux attach-session -t "$session_name"
		fi
	else
		if [ -n "$(expr "$input" : '\(F\|f\)$')" ]
		then
			__new_session
		elif [ -z "$input" ]
		then
			return 0
		else
			tmux new-session -s "$(printf "$input")"
		fi
	fi
}

_setup_session() {
	local project_dir=$1
	local project_session="$session_dir/$2"

	mkdir -p "$project_session"
	printf "$project_dir" >"$project_session/path"

	local watch_config="$project_session/watch"
	if [ -f "$watch_config" ]
	then
		local fifo
		for i in `cat "$watch_config" | sed -ne 's/^s:\[\(.*\)\].*/\1/p'`
		do
			# You would be seeing results of watchers via named-pipes
			fifo="$project_session/${i}_fifo"
			test -p "$fifo" || mkfifo "$fifo"
			#wxwatch "$runner" "$i" "$watch_config" >"$fifo" &
		done
	fi
}

__set_whxy() {
	local window_attributes=$1

	y=$(printf "$window_attributes" | sed -e 's/^.*+\([0-9]\+\)$/\1/')
	x=$(printf "$window_attributes" | sed -e 's/^.*+\([0-9]\+\)+.*/\1/')
	w=$(printf "$window_attributes" | sed -e 's/^\([0-9]\+\)x.*/\1/')
	h=$(printf "$window_attributes" | sed -e 's/^.*x\([0-9]\+\).*/\1/')
}

_dump() {

	__set_whxy $window_attributes_file_selector
	cat <<EOTX
unbind M-$tbind_select
bind M-$tbind_select if-shell "command -v wfmux" { display-popup -w $w -h $h -x $x -y $y -E "wfmux select"; }
EOTX

	__set_whxy $window_attributes_rest
	cat <<EOTX
unbind M-$tbind_explore
bind M-$tbind_explore if-shell "command -v wfmux" { display-popup -w $w -h $h -x $x -y $y -E "wfmux explore"; }
unbind M-$tbind_ops
bind M-$tbind_ops if-shell "command -v wfmux" { display-popup -w $w -h $h -x $x -y $y -E "wfmux ops"; }
EOTX

}

func_dump() {
	_dump
}

func_tmux() {
	_dump >>"$tmux_conf"
}

__get_project_dir() {
	local session_name=$(tmux list-sessions -F '#S:#{session_activity}' | sort -b -t: -k 2,2n | tail -n1 | cut -d: -f1)
	local session="$session_dir/$session_name"

	if [ -d "$session" ]
	then
		local project_dir=`cat "$session/path"`
		test -d "$project_dir" && printf "$project_dir"
	fi
}

func_switch() {
	local cur_session=`__get_cur_session`

	__get_session_dir_basename() {
		local session
		local project_dir

		tmux list-sessions -F '#S' | while read sname; do

			session="$session_dir/$sname"
			if [ -d "$session" ]
			then
				project_dir=$(cat "$session/path")
				if [ -d "$project_dir" ]
				then
					project_dir=$(printf "%s\n" "$project_dir" | sed -e 's,.*/\([^/]*/[^/]*\),\1,')
					printf "%s\n" "$sname:$project_dir"
				fi
			fi
		done | sed -e "s/$cur_//"
	}

	local session_pbase=`__get_session_dir_basename`
	local pbasename=$(printf "$session_pbase" | cut -d: -f2 | eval "$searcher")

	if [ -n "$pbasename" ]
	then
		local pty=`__get_pty`

		# CAUTION: This is not a BUG!!! (note the head -n1)
		# The differenciation level for every projects are the names of their parent directories only, not uptil the OS's root directory.
		tmux switch-client -c "$pty" -t "$(printf "$session_pbase" | sed -ne "s,\(.*\):$pbasename,\1,p" | head -n1)"
	fi
}

## open your favorite tui file manager
func_explore() {
	local project_dir=`__get_project_dir`
	eval "$explorer" "$project_dir"
}

## select project files to open
func_select() {
	local file torun
	local new_window=true
	local sh=${SHELL##*/}
	local project_dir=`__get_project_dir`

	test -d "$project_dir" || return

	file=$(
		args=$(printf "$ignore" | sed -e '${ s/\(.*\)/-name "\1"/; q; }; 1,${ s/\(.*\)/-name "\1" -or /; }' | tr '\n' ' ')
		eval "find '$project_dir' \( $args \) -prune -or -type f -print | sed -e 's,^$project_dir/,,' | $searcher"
	)

	test -n "$file" || return
	file="$project_dir/$file"

	_open_file_command() {

		if [ x"$use_xdg" != xtrue ]
		then
			local mime
			local mime_type=$(xdg-mime query filetype "$file")

			if [ $? = 0 ] && [ -n "$mime_type" ]
			then

				# The right program to open files of type 'application' can partly be determined
				# with the aid of its subtype, like for example application/json, application/pdf, etc.
				# therefore $mime should be the file's subtype in case the we have 'application' as mime
				# type otherwise its type is the best option.
				test "${mime_type%/*}" = application && mime=${mime_type#*/} || mime="${mime_type%/*}"

				local opener=$(printf "$programs" | sed -ne "s/^$mime:[[:space:]]*\([^[:space:]]*\)/\1/p")
				opener=${opener:-$EDITOR}
				opener=${opener:-vim}

				{ 
					which "$opener" 1>&2
					if [ $? -eq 0 ]  
					then
						# Put in list of all TUI applications that takes a $file as argument
						if printf "$opener" | grep -qE '^vim|ranger|cmus|nvim|nnn|kak$'
						then
							printf "$opener '$file'"
						else
							{ trap '' HUP; eval "$opener '$file'"; } &
							tmux display-popup -C
						fi
					fi
				} 2>/dev/null
			fi
		else
			printf "xdg-open '$file'"
		fi
	}

	local torun=`_open_file_command`
	if [ -n "$torun" ]
	then
		for wid in $(tmux list-window -F '#{window_activity}:#I' | sort -r -t: -k 1,1n | cut -d: -f2 | tac)
		do
			local panes=$(tmux list-panes -t $wid -F '#{pane_current_command}:#P:#{pane_active}')
			local bash_panes=$(printf "$panes" | grep "^${sh:-bash}:")

			if [ -n "$bash_panes" ]
			then
				# is it an idle active pane?
				local bash_id=$(printf "$bash_panes" | sed -nE 's/.*:([0-9]+):1$/\1/p')
				if [ -z "$bash_id" ]
				then
					# take the most recently opened idle pane
					bash_id=$(printf "$bash_panes" | sort -t: -k 2,2n | head -n1 | cut -d: -f2)
				fi

				tmux send-keys -t "$wid.$bash_id" "$torun" C-m
				if [ $? -eq 0 ]; then new_window=false; break; fi
			else
				if [ `printf '%s\n' "$panes" | wc -l` -eq 1 ]
				then
					tmux select-window -t "$wid"
					tmux split-window -h "$torun"
					if [ $? -eq 0 ]; then new_window=false; break; fi
				fi
			fi
		done

		test $new_window = true && tmux new-window "$(_open_file)"
	fi
}

func_commit() {
	__commit
}

func_acommit() {
	__commit true
}

__commit() {
	local editor=$(printf "$programs" | sed -ne 's/^[ \t]*text:[ \t]\+\(\w*\)$/\1/p')

	editor=${editor:-$EDITOR}
	editor=${editor:-vim}

	{ command -v git       || return
	  command -v "$editor" || return
	} >/dev/null

	local project_dir=`__get_project_dir`

	if [ -n "$project_dir" ]
	then
		cd "$project_dir"
		if [ $? = 0 ]
		then
			local amend=${1:-false}

			git add .
			if [ "$amend" = false ]
			then
				local tempfile=`mktemp /tmp/.git_XXXXXX`

				$editor "$tempfile"
				# Let git abord if we did not commit with a commit message
				# than trying to introduce a `du'-like command
				git commit --message "$(cat "$tempfile")"
				rm -f "$tempfile"
			else
				git commit --amend
			fi
		fi
	fi
}

func_branch() {
	command -v git >/dev/null || return

	local project_dir=`__get_project_dir`

	cd "$project_dir"
	if [ $? = 0 ]
	then
		if printf "%s\n" "$searcher" | grep -q '^fzf'
		then
			local old_searcher=$searcher
			searcher="$searcher --print-query"
		fi

		local branch=$(git branch | sed -e 's/^\(\*\?\) *\(.*\)$/\2\1/' | eval "$searcher" | tail -n1)
		branch=${branch%*}
		if [ -n "$branch" ]
		then
			# Check if he/she commited before checking out
			git status | tail -n1 | grep -q '^nothing to commit' 
			if [ $? -eq 0 ]
			then
				git checkout "$branch" || git checkout -b "$branch"
			fi
		fi

		searcher=$old_searcher
	fi
}

func_push() {
	__push
}

func_fpush() {
	__push --force
}

__push() {
	{ command -v git    || return
	  command -v "$tok" || return
	} >/dev/null

	local project_dir=`__get_project_dir`
	test -n "$project_dir" && project_name=$(basename "$project_dir")

	if [ -n "$project_name" ]
	then
		cd "$project_dir"
		if [ $? -eq 0 ]
		then
			local remote=$(printf "$remote" | eval "$searcher")

			if [ -n "$remote" ]; then
				local force=${1:---force}
				local proto=https
				local branches=$(git branch | sed -ne 's,^* \(.*\),\1,p')
				local tok=$(eval "$tok '${remote%%.*}'")
				local git_config=$(cat .git/config)

				case $remote in
					codeberg.org | github.com | github.com) proto=https ;;
					*) proto=https ;;
				esac
				if [ "$remote" = "gitlab.com" ]
				then
					tok="$gitlab_tok_name:$tok"
				fi

				printf "%s\n" "$branches" | while read branch
				do
					printf "Pushing to $remote/$username  ";
					{ i=0
					  set -- − \\ \| /
					  while true; do 
						  sleep 0.2
						  i=$(($i+1))
						  eval "printf \"\b\$$(($(($i%4))+1))\""
					  done
					} &

					local failed=No
					git push "$force" --set-upstream "$proto://$tok@$remote/$username/$project_name.git" "$branch" >/dev/null 2>&1 || failed=Yes
					kill -KILL $!

					test x"$failed" = x"Yes" && c=2mFailed || c=4mPushed
					printf "\b\033[1;3${c}\033[0m\n\n"
				done

				# To avoid saving tokens!
				printf "$git_config" > .git/config
				printf "\nPress anything to quit!"
				stty -echo -cooked && dd if=/dev/tty count=1 bs=1 >/dev/null 2>&1
			fi
		fi
	fi
}

# add a new watcher to the watcher list
func_awatcher() {
	local watcher_name files

	printf "give a name to your watcher"
	read watcher_name

	if [ -n "$watcher_name" ]
	then
		# Check if this name already exists in the database
		local session_name=$()

		if [ -z `` ]
		then
			files=$(
				args=$(printf "$ignore" | sed -e '${ s/\(.*\)/-name "\1"/; q; }; 1,${ s/\(.*\)/-name "\1" -or /; }' | tr '\n' ' ')
				eval "find '$project_dir' \( $args \) -prune -or -type f -print | sed -e 's,^$project_dir/,,' | $searcher"
			)

			if [ -n "$files" ]
			then
				:
			fi
		fi
	fi
}

# disable watchers, don't run this watcher when creating tmux sessions
func_dwatcher() {
	:;
}

# enable watchers, should run when creating tmux session
func_ewatchers() {
	:;
}

# remove watchers from the watcher list
func_rwatchers() {
	:;
}

# fancy view of the watchers
func_view() {
	:;
}

# Cycle through stdout&stderr of watchers
func_cycle() {
	:;
}

# Wrap all operations, plugins appear here
func_ops() {

	_load_plugins() {
		:;
	}

	[ -z `__get_project_dir` ] && return

	local ops=$(
	    printf "commit
acommit
branch
runner
explore
select
dwatcher
ewatcher
awatcher
rwatcher
view
cycle
nsession
switch
fpush
push" | eval "$searcher")

	test -n "$ops" && {
		trap '' HUP

		case $ops in
			select)
				__set_whxy $window_attributes_file_selector ;;
			commit   | \
			acommit  | \
			runner   | \
			branch   | \
			explore  | \
			push     | \
			fpush    | \
			dwatcher | \
			ewatcher | \
			awatcher | \
			rwatcher | \
			view     | \
			cycle    | \
			nsession | \
			switch)
				__set_whxy $window_attributes_rest ;;
		esac

		tmux display-popup -w $w -h $h -x $x -y $y -E "/home/kueppo/projects/wfmux/src/wfmux $ops"
		#tmux display-popup -w $w -h $h -x $x -y $y -E "wfmux $ops"
	} &

	tmux display-popup -C
}

func_main "$@"
