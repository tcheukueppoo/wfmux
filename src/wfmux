#!/bin/dash

#set -x
set -u

readonly ESC_ALT_SCREEN='\033[?1049h'
readonly ESC_NORMAL_SCREEN='\033[?1049l'
readonly ESC_HIDE_CUR='\033[?25l'
readonly ESC_SHOW_CUR='\033[?25h'
readonly ESC_CLEAR_SCREEN='\033[2J'
readonly ESC_BOLD='\033[1m'
readonly ESC_UNDERLINE='\033[4m'
readonly ESC_RED='\033[31m'
readonly ESC_UNSET_ANSI='\033[0m'

readonly CONFIG_DIR=${XDG_CONFIG_HOME:-"$HOME/.config"}
readonly WFMUX_CONF_DIR="${CONFIG_DIR%%/}/wfmux"
readonly WFMUX_PLUG_DIR="$WFMUX_CONF_DIR/plugins"
readonly TMUX_CONF="$HOME/.tmux.conf"

# Shell running command from `tmux display-pop' does not seem 
# to have sourced profiles.
readonly LOCAL_BIN="$HOME/.local/bin"

# Some watcher commands frequently used in some projects.
readonly WATCHER_TEMPLATES="$WFMUX_CONF_DIR/watchers"

readonly NL=$(printf '\n_')

mkdir -p "$CONFIG_DIR" "$WFMUX_CONF_DIR"

# Large size
readonly WFMUX_LS=$(cat <<END
                                ┌────────────
                                │
                                │                                            ┌───────
                                │                             ┌───┐          │
            ┌──┐                │                             │   │          │
            │  │                │                             │   │          │
            │  │           ┌────┼─────┬─────┬──────┬──┐       │   │    ┌─────┘
            │  │     ┌─    │    │     │     │      │  │       │   │    │
────────────┘  │     │     │    │     │     │      │  │       │   └────┼─────┐
               │     │     │    │     │     │      │  │       │        │     │
               │     │     │    │     │     └────  │  └───────┘        │     │
               ├─────┴─────┘    │     │            └──                 │     │
               │                │    ─┘                                │     │
               │                │            ──────────────────────────┘     │
               │                └─                                           │
         ──────┘                                                             │
                                                                             │
END
)

# Medium size
readonly WFMUX_MS=$(cat <<END
                     ┌─────────                      ┌───
                     │                               │
        ┌─┐          │                     ┌──┐      │
        │ │       ┌──┼───┬───┬───┬───┐     │  │  ┌───┘
        │ │   ┌─  │  │   │   │   │   │     │  │  │
────────┘ │   │   │  │   │   │   │   │     │  └──┼───┐
          │   │   │  │   │   └─  │   │     │     │   │
          ├───┴───┘  │  ─┘       │   └─────┘     │   │
          │          └─          └──             │   │
          │                  ────────────────────┘   │
     ─────┘                                          │
                                                     │
END
)

# Small size
readonly WFMUX_SS='WFMUX'

readonly WFMUX=$(cat<<END

     ┌──────────────┤ WFMUX
    ┌┴────────────────────────────────────────┐
    │                                         │
    ├─ Input a name for a new tmux session    │
    ├─ Input f⟨return⟩ to select a project    │
    ├─ Input ⟨return⟩ to drop to the terminal │
    │                                         │
    └─────────────────────────────────────────┘
END
)

WFMUX_CONF="$WFMUX_CONF_DIR/wfmux.conf"
WFMUX_OPS=$(cat<<END
new
tmux
dump
open
explore
shell
nsession
switch
log
commit
acommit
push
fpush
checkout
fcheckout
cbranch
view
awatcher
dwatcher
ewatcher
rwatcher
ops
END
)

# Default configuration if external config file does not exist
COLOR=4
SUCCESS="\033[1;3${COLOR}m"

WATCHER='entr'
FILE_MANAGER='lf'

WIN_ATT_OPT='20x20+10+20'
WIN_ATT_INPUT_BOX='20x20+10+20'

TBIND_OPEN='Enter'
TBIND_EXPLORE='BSpace'
TBIND_OPS='i'
TBIND_SWITCH='w'

MENU='fzf --multi --margin=25%'

PROJECT_DIRS=$(cat <<END
$HOME/projects
$HOME/oprojects
END
)

USE_XDG_OPEN=false

PROGRAMS=$(cat <<END
tty=true,text=vim '%s'
tty=true,directory=lf '%s'
tty=false,video=ffplay -hide_banner -loop 0 '%s'
tty=true,audio=ffplay  -hide_banner -loop 0 -nodisp '%s'
tty=false,pdf=zathura '%s'
tty=false,image=feh '%s'
END
)

usage () {
   cat <<END
Build an awesome dev workflow using tmux, fzf, lf, entr and more.

Usage: wfmux [ -h | --help ]
       wfmux [ ( -c | --config ) CONF ] OPT_NAME
       
Options:
     -h, --help         print this help message.
     -c, --config CONF  load CONF configuration file.

OPT_NAME:
    new          Select a project and open its new wfmux tmux session.
    nsession     Create a new wfmux tmux session of a project while in a
                 tmux session.
    switch       Switch between wfmux tmux sessions
    explore      Open file manager to a project directory on a popup pane.
    open         Select a file to open provided that they exist ...
    commit       add to the index and commit changes to local repository.
    acommit      replace the tip of the current branch by creating a new commit
    checkout     fuzzyly switch between branches of your local repository.
    fcheckout
    push         push to the remote repositories.
    fpush        force-push to the remote repositories.
    dump         dump wfmux's tmux configuration to stdout.
    tmux         update wfmux's tmux configuration at ~/.tmux.conf.
    ops          a wrapper to the above operations.
    dwatcher     disable a watcher from the watcher list
    ewatcher     enable a watcher from the watcher list
    awatcher     Add a new watcher to a project's watcher list.
    rwatcher     Remove a new watcher to a project's watcher list.
    view         Fancy view of the concerned running project watcher.

END
   exit $1
}

die () {
   printf '%s: %s.\n' "$0" "$*" >&2
   exit 1
}

main () {
   test $# -eq 0 && usage 1

   opt_name=
   while [ $# -ne 0 ] ; do
      case $1 in
         -h|--help)
            usage 0
            ;;
         -c|--config)
            test $# -eq 1 && WFMUX_CONF=$2 || usage 1
            if ! test -e "$WFMUX_CONF" ; then
               die "Config '$WFMUX_CONF' does not exist"
            fi
            shift
            ;;
         -*)
            die "Unknown option '$1', please try \`$0 --help'"
            ;;
         *)
            test -n "$opt_name" && usage 1
            opt_name=$1
            printf '%s' "$WFMUX_OPS" | grep -q "^$opt_name$"
            if test $? -ne 0 ; then
               die "Unknown wfmux operation: $opt_name"
            fi
            ;;
      esac
      shift
   done

   test -f "$WFMUX_CONF" && {
      test -r "$WFMUX_CONF" || die "No permission to read '$WFMUX_CONF'"
      . "$WFMUX_CONF"       || die "Non-zero exit status when sourcing config"
   }

   check_config_variables
   eval "opt_wfmux_$opt_name"
}

check_config_variables () {
   var=
   is_set=

   die_conf () {
      die "('$WFMUX_CONF'): $*"
   }

   v_error () {
      die_conf "Invalid value assigned to '$1'"
   }

   for var in USE_XDG_OPEN WATCHER MENU FILE_MANAGER     \
              WIN_ATT_OPT WIN_ATT_INPUT_BOX PROJECT_DIRS  \
              TBIND_OPS TBIND_SELECT TBIND_EXPLORE ; do

      eval 'is_set=${'$var':+true}'
      test -z "$is_set" && die_conf "'$var' isn't defined"
   done

   ## Check if we've got sane values
   {
      expr "$COLOR"        : '[0-9]$'           || v_error COLOR
      expr "$USE_XDG_OPEN" : '\(true\|false\)$' || v_error USE_XDG_OPEN

      for cmd in FILE_MANAGER WATCHER MENU ; do
         eval 'command' '-v' '${'$cmd'}' || {
            die_conf "Command '$cmd' not found"
         }
      done

   } >/dev/null

   OIFS=$IFS IFS='
'
   project_dirs=

   for path in $PROJECT_DIRS ; do
      rpath=$(realpath -e "$path" 2>/dev/null)

      test $? -eq 0    || die_conf "'$path' does not exist"
      test -d "$rpath" || die_conf "'$rpath' is not a directory"
      test -r "$rpath" || die_conf "cannot list contents of '$rpath'"

      project_dirs="$project_dirs${project_dirs:+${NL%?}}$rpath"
   done

   IFS=$OIFS
   PROJECT_DIRS=$(printf '%s' "$project_dirs")
}

display_dashboard () {
   awk_max='
      BEGIN { len = 0 }
      {
         nlen = length($0)
         if (nlen > len)
            len = nlen
      }
      END { print len }
   '

   # Dashboard message, explains how to use wfmux on tmux.
   dashboard_msg () {
      cat <<END
The following are tmux bindings related to wfmux.

M-$TBIND_SELECT: fuzzyly open project files
M-$TBIND_EXPLORE: open file manager
M-$TBIND_OPS: fuzzyly select other wfmux operations

input any key to exit dashboard
END
   }

   tty_print () {
      printf '\033[%d;%df%s' "$1" "$2" "$3" >/dev/tty
   }

   # Save initial terminal setting, will set back after exiting dashboard
   init_stty=`stty -g`
   stty -cooked -echo time 0 min 1
   printf "${ESC_ALT_SCREEN}${ESC_HIDE_CUR}${ESC_CLEAR_SCREEN}"

   {
      term_h= term_w=
      while [ 1 ] ; do

         new_size=`stty -F /dev/tty size`
         test "$new_size" = "$term_h $term_w" && {
            sleep 1
            continue
         }

         term_h=$(printf "$new_size\n" | cut -d' ' -f1)
         term_w=$(printf "$new_size\n" | cut -d' ' -f2)
         if test $term_h -lt 32 || test $term_w -lt 97 ; then
            _size=SS
         elif test $term_h -lt 43 || test $term_w -lt 155 ; then
            _size=MS
         else
            _size=LS
         fi
         eval 'wfmux_h=$(printf "$WFMUX_'$_size'" | wc -l)
               wfmux_w=$(printf "$WFMUX_'$_size'" | awk "$awk_max")'

         wfmux_h=$(expr $wfmux_h + `dashboard_msg | wc -l`)

         x=$((($term_w - $wfmux_w) / 2))
         y=$((($term_h - $wfmux_h) / 2))

         msg_w=$(dashboard_msg | awk "$awk_max")
         if test $msg_w -gt $wfmux_w ; then
            msg_x=$(($x - ($msg_w - $wfmux_w) / 2))
         else
            msg_x=$(($x + ($wfmux_w - $msg_w) / 2))
         fi

         printf "${ESC_CLEAR_SCREEN}${SUCCESS}${ESC_BOLD}"

         IFS='
'
         for line in $(eval 'printf "$WFMUX_'$_size'"') ; do
            tty_print $y $x "$line"
            y=$(($y + 1))
         done

         printf "$ESC_UNSET_ANSI"
         for line in `dashboard_msg` ; do
            y=$(($y + 1))
            tty_print "$y" "$msg_x" "$line"
         done
      done
   } &

   # Get key from the standard input
   dd if=/dev/tty count=1 bs=1 >/dev/null 2>&1

   kill -KILL $! || :

   stty "$init_stty"
   printf "$ESC_UNSET_ANSI$ESC_SHOW_CUR"
   tput clear
}

tmux_cur_session () {
   tmux list-sessions -F '#S:#{session_activity}' | sort -b -t: -k2,2n | tail -n1 | cut -d: -f1
}

tmux_cur_pty () {
   tmux list-clients -F '#S:#{client_tty}' | grep -F "$(tmux_cur_session):" | cut -d: -f2
}

tmux_message () {
   tmux display-message -d 2500 -- "$*."
}

shrink_project_dirs () {
   sdirs=$PROJECT_DIRS

   for n in $(seq `printf '%s\n' "$sdirs" | wc -l`) ; do
      path=$(printf '%s' "$sdirs" | sed -ne "${n}p")

      # Check if it's already shrinked
      expr "$path" : / >/dev/null || continue

      name=${path#/}
      name=${name%%/*}

      # Check if $path is the only one.
      test $(printf '%s' "$sdirs" | grep "^/$name/" | wc -l) -eq 1 && continue

      path=${path#/*/}
      sdirs=$(printf '%s' "$sdirs" | sed -e "s#^/$name/#*/#")

      # Shrink more
      OIFS=$IFS IFS=/
      for name in $path ; do
         test $(printf '%s' "$sdirs" | grep "^\*/$name/" | wc -l) -eq 1 && continue

         _sdirs=$(printf '%s' "$sdirs" | sed -e "s#^\*/$name/#*/#")

         a=$(printf '%s' "$_sdirs" | sed -e 's/\*/.../')
         b=$(printf '%s' "$a"      | sort -u)
         test ${#a} -ne ${#b} && break

         sdirs=$_sdirs
      done
      IFS=$OIFS

      sdirs=$(printf '%s' "$sdirs" | sed -e 's/\*/.../')
   done

   printf '%s\n' "$sdirs"
}

get_project_list () {
   line=1
   sdirs=`shrink_project_dirs`

   IFS='
'
   for dir in $PROJECT_DIRS ; do
      cd "$dir"

      for file in * ; do
         test -d "$file" || continue
         test -x "$file" || continue

         sdir=$(printf "$sdirs" | sed -ne "${line}p")
         printf "[%d]:%s/%s\n" $line "$sdir" "$file"
      done

      line=$(($line + 1))
   done
}

new_session () {
   project=$(get_project_list | eval "$MENU")

   test -z "$project" && return

   line=${project%%]*}
   line=${line#[}
   project_ddir=$(printf "$PROJECT_DIRS" | sed -ne "${line}p")
   project_name=$(basename "$project")
   project_dir="$project_ddir/$project_name"

   cd -L "$project_dir"

   test -d .git && {
      touch .gitignore
      grep -q -- .wfmux .gitignore || {
         printf '.wfmux\n' >>.gitignore
         git add .gitignore && git commit -m 'Update .gitignore'
      } 
   }

   if test -d .wfmux      \
   && test -x .wfmux       \
   && test -s .wfmux/name   \
   && expr "$(cat .wfmux/name)" : "$project_name-.\\{6\\}$" >/dev/null ; then
      session_name=`cat .wfmux/name`
   else
      rm -rf .wfmux
      mkdir .wfmux
      touch .wfmux/name
      session_name=`mktemp -u $project_name-XXXXXX`
      printf "$session_name" >>.wfmux/name
      printf '.git\n'        >>.wfmux/ignore
   fi

   if [ -z "${TMUX:-}" ] ; then
      tmux has-session -t "$session_name" 2>/dev/null || {
         start_watchers "$project_dir"
         display_dashboard
         tmux new-session -s "$session_name" -d
      }
      exec tmux attach-session -t "$session_name"
   else
      pty=`tmux_cur_pty`
      tmux has-session -t "$session_name" 2>/dev/null || tmux new-session -s "$session_name" -d
      exec tmux switch-client -c "$pty" -t "$session_name"
   fi
}

# Create a new tmux wfmux session while in an existing session.
opt_wfmux_nsession () { new_session; }

# Select a project and open a tmux session
opt_wfmux_new () {
   input=
   session_name=

   if tmux list-sessions >/dev/null 2>&1 ; then
      printf "Choose an existing session to attach\n\n"
      tmux list-sessions | awk '{print "["NR"] "$0}'
   fi

   printf "$WFMUX\n"
   printf '⟩⟩ '
   read input
   tput clear

   test -z "$input" && return

   if test "$input" = 'f' ; then
      new_session
   elif expr "$input" : '\([0-9]\|[1-9][0-9]\+\)$' >/dev/null ; then
      session_name=$(tmux list-sessions -F '#S' | sed -n "${input}p")
      test -n "$session_name" && exec tmux attach-session -t "$session_name"
   else
      exec tmux new-session -s "$(printf '%s' "$input")"
   fi
}

set_whxy () {
   name=$1 win_att=$2

   num_re='[0-9]\|[1-9][0-9]\+'
   com_re='C\|P\|M\|W'

   x_re="\($com_re\|R\|$num_re\)"
   y_re="\($com_re\|S\|$num_re\)"

   size_re="\(\($num_re\)%\?\)"

   c=$(printf '%s' "$win_att" | sed -ne "s/^${size_re}x${size_re}+${x_re}+${y_re}$/w=\1 h=\3 x=\5 y=\6/p")

   test -z "$c" && die "Invalid value assigned to '$name'"
   eval "$c"
}

dump_config () {
   set_whxy WIN_ATT_OPT $WIN_ATT_OPT

   cat <<END
unbind M-$TBIND_OPEN
bind   M-$TBIND_OPEN display-popup -w $w -h $h -x $x -y $y -E "$LOCAL_BIN/wfmux open"

unbind M-$TBIND_EXPLORE
bind   M-$TBIND_EXPLORE display-popup -w $w -h $h -x $x -y $y -E "$LOCAL_BIN/wfmux explore"

unbind M-$TBIND_OPS
bind   M-$TBIND_OPS display-popup -w $w -h $h -x $x -y $y -E "$LOCAL_BIN/wfmux ops"

unbind M-$TBIND_SWITCH
bind   M-$TBIND_SWITCH display-popup -w $w -h $h -x $x -y $y -E "$LOCAL_BIN/wfmux switch"
END
}

opt_wfmux_dump () { dump_config; }
opt_wfmux_tmux () { dump_config >>"$TMUX_CONF"; }

get_project_dir () {
   test -z "$1" && return

   session_name=$1
   project_name=$(printf "$session_name" | sed -ne 's/^\([^-]\+\)-.\{6\}$/\1/p')
   test -z "$project_name" && return

   OIFS=$IFS IFS='
'
   for dir in $PROJECT_DIRS ; do
      project_dir="$dir/$project_name"

      test -d "$project_dir"       \
         && test -x "$project_dir"  \
         && cd -L "$project_dir"     \
         || continue

      if test -f ".wfmux/name" \
      && test $session_name = "$(cat .wfmux/name)" ; then
         printf "$project_dir\n"
      fi
   done

   IFS=$OIFS
}

tmux_or_die () {
   test -n "${TMUX:-}" || die "Wfmux must run in a tmux session"
}

opt_wfmux_switch () {
   tmux_or_die

   wfmux_sessions= IFS='
'
   for session in `tmux list-sessions -F '#S'` ; do
      test -z "$(get_project_dir "$session")" && continue
      wfmux_sessions="${wfmux_sessions}${session}\n"
   done

   test -z "$wfmux_sessions" && return
   session=$(printf "$wfmux_sessions" | eval "$MENU")

   if test -n "$session" ; then
      tmux switch-client -c "$(tmux_cur_pty)" -t "$session"
   fi
}

## Open tui file manager
opt_wfmux_explore () {
   tmux_or_die

   project_dir=`get_project_dir "$(tmux_cur_session)"`

   test -z "$project_dir"   \
      && not_wfmux_session   \
      || eval "$FILE_MANAGER" "$project_dir"
}

get_project_files () {
   ignore=
   project_dir=$1

   if test -s .wfmux/ignore ; then
      IFS='
'
      for pattern in `cat .wfmux/ignore` ; do
         ignore="${ignore}${ignore:+ -or}"
         ignore="${ignore} -name '${pattern}'"
      done
   fi

   if test -n "$ignore" ; then
      eval find . '\(' "$ignore" '\)' -prune -or -type f -print
   else
      find . -type f -print
   fi
}

get_filetype () {
   file=$1

   if command -v xdg-mime >/dev/null ; then
      filetype=$(xdg-mime query filetype "$file")
   elif command -v file >/dev/null ; then
      filetype=$(file --mime-type "$file")
      filetype=${filetype##*: }
   else
      tmux-message "'$file': Couldn't determine the file type"
      return
   fi

   expr "$filetype" : application >/dev/null  \
      && filetype=${filetype##*/}              \
      || filetype=${filetype%%/*}

   printf "$filetype"
}

nohup () {
   { trap '' HUP; eval "$@"; } &
}

## Open a project file
opt_wfmux_open () {
   tmux_or_die

   project_dir=`get_project_dir "$(tmux_cur_session)"`

   test -z "$project_dir" && {
      not_wfmux_session
      return 1
   }

   cd -L "$project_dir"

   files=$(get_project_files "$project_dir" | eval "$MENU")
   IFS='
'
   for file in $files ; do

      if test "$USE_XDG_OPEN" = true ; then

         command -v xdg-open >/dev/null || {
            tmux_message "xdg-utils package not installed"
            tmux display-popup -C
            exit 1
         }

         cmd="xdg-open '$file'"
      else
         filetype=`get_filetype "$file"`
         test -z "$filetype" && continue

         data=$(printf '%s' "$PROGRAMS" | grep "^tty=\(true\|false\),$filetype=" | head -n1)

         test -z "$data" && {
            tmux_message "Unable to open '$file'"
            continue
         }

         use_tty=${data%,$filetype=*}
         use_tty=${use_tty#tty=}

         cmd=${data#*,$filetype=}
         cmd=$(printf "$cmd" "$file")

         bin=${cmd%% *}
         command -v "$bin" >/dev/null || {
            tmux_message "Unable to open '$file', $bin: not found"
            continue
         }
      fi

      wfmux_run_cmd "$cmd" $use_tty
   done
}

wfmux_run_cmd () {
   cmd=$1
   use_tty=$2

   test $use_tty = true || {
      nohup "$cmd" >/dev/null 2>&1
      return 0
   }

   test -n "${SHELL:-}" || {
      tmux_message '$SHELL not defined'
      tmux display-popup -C
      return 0
   }

   panes=$(tmux list-panes -F '#{pane_current_command}:#P:#{pane_active}')

   # If possible, run the command in an idle pane.
   idle_panes=$(printf '%s' "$panes" | grep "^${SHELL##*/}:")

   if test -n "$idle_panes" ; then

      target=$(printf '%s' "$idle_panes" | grep ':1$')
      target=${target%:1}

      test -z "$target" && {
         target=$(printf '%s' "$idle_panes" | sort -t: -k1,1n | head -n1)
         target=${target%:0}
      }

      target=${target##*:}
      tmux send-keys -t "$target" "$cmd" C-m

   # Spawn off a new pane in the current window if there's only one pane
   # and that pane it's busy.
   elif test $(printf '%s' "$panes" | wc -l) -eq 0 ; then

      tmux split-window -h "$cmd"

   # In the worst case, run it in a new window.
   else
      tmux new-window "$cmd"
   fi

   return 0
}

opt_wfmux_shell () {
   tmux_or_die

   project_dir=`get_project_dir "$(tmux_cur_session)"`
   test -z "$project_dir"   \
      && not_wfmux_session   \
      && return 1

   cd -L "$project_dir"
   exec ${SHELL:-/bin/sh}
}

is_git_repository () {
   git rev-parse --show-toplevel >/dev/null 2>&1 || {
      tmux_message "This project isn't a git repository"
      tmux display-popup -C
      return 1
   }
}

not_wfmux_session () {
   tmux_message "This is not a wfmux tmux session"
   tmux display-popup -C
}

requires () {
   for cmd in "$@" ; do
      command -v "$cmd" >/dev/null || {
         tmux_message "$cmd: Command not found"
         return 1
      }
   done
}

has () {
   command -v "$1" >/dev/null
}

opt_wfmux_log () {
   tmux_or_die

   requires git || return

   project_dir=`get_project_dir "$(tmux_cur_session)"`

   test -z "$project_dir"   \
      && not_wfmux_session   \
      && return 1

   cd -L "$project_dir"

   is_git_repository || return

   git log | less
}

git_status () {
   git status --porcelain --ignore-submodules
}

wfmux_commit () {
   tmux_or_die

   requires git || return

   project_dir=`get_project_dir "$(tmux_cur_session)"`

   test -z "$project_dir"   \
      && not_wfmux_session   \
      && return 1

   cd -L "$project_dir"

   is_git_repository || return

   if test -z "${EDITOR:-}" ; then
      tmux_message 'Undefined $EDITOR'
      tmux display-popup -C
      return
   fi

   command -v "$EDITOR" >/dev/null || {
      tmux_message "$EDITOR: Command not found"
      tmux display-popup -C
      return
   }

   gstatus=$(git_status | sed -e 's/^ /-/;s/^??/-U/;s/^\(.\)  /\1 /')

   test -z "$gstatus"  \
      && test $# -eq 0  \
      && {
      tmux_message "Nothing to commit, working tree clean"
      tmux display-popup -C
      return
   }

   gstatus=$(printf '%s' "$gstatus" | eval "$MENU")

   test -z "$gstatus"  \
      && test $# -eq 0  \
      && {
      tmux display-popup -C
      return
   }

   IFS='
'
   for change in $gstatus ; do
      file=${change#* }
      ctype=${change%% *}

      test x"${ctype%?}" != x'-' && continue

      ctype=${ctype#?}
      test $ctype != M       \
         && test $ctype != U  \
         && continue

      git add "$file" 2>/dev/null || {
         tmux_message "$file: Couldn't be added to the index"
         tmux display-popup -C
         return 1
      }
   done

   git commit "$@"
}

opt_wfmux_commit () {
   wfmux_commit || tmux-message "Unable to commit"
}

opt_wfmux_acommit () {
   wfmux_commit --amend || tmux-message "Unable to amend"
}

git_branches () {
   IFS='
'
   for lbranch in `git branch --list --no-color` ; do
      test x"${lbranch% *}" = x'*' && continue

      lbranch=${lbranch#  }
      rbranch=$(git rev-parse --abbrev-ref "$lbranch@{u}" 2>/dev/null)

      test $? -eq 0                                     \
         && printf 'L %s -> %s\n' "$lbranch" "$rbranch"  \
         || printf 'L %s\n'       "$lbranch"
   done

   git branch --remote --no-color | sed -ne '2,$s/^ */R /p'
}

wfmux_new_branch () {
   rbranch=$1
   lbranch=${rbranch##*/}

   git show-ref --verify --quiet refs/heads/$lbranch && {

      printf '%s: Local branch name already exists\n' "$branch"
      printf 'New name (y/n)? '
      read input
      test "$input" != y && return

      printf ': '
      read lbranch
      test -z "$lbranch" && return

      git check-ref-format --branch "$lbranch" >/dev/null
      test $? -ne 0 && return 1
   }

   git checkout -b "$lbranch" --track "$rbranch"
}

wfmux_checkout () {
   tmux_or_die

   requires git || return

   project_dir=`get_project_dir "$(tmux_cur_session)"`

   test -z "$project_dir"   \
      && not_wfmux_session   \
      && return 1

   cd -L "$project_dir"

   is_git_repository || return

   test "${1:-}" = '--clean-worktree' && {
      test -z "$(git_status)" || {
         tmux_message "Still have local changes to be commited"
         return 1
      }
   }

   branch=`git_branches | eval "$MENU"`
   test -z "$branch" && return

   btype=${branch%% *}
   branch=${branch#? }
   branch=${branch%% *}

   if test $btype = L ; then
      git checkout "$branch"
   else
      wfmux_new_branch "$branch"
   fi

   if git_status | grep -q '^?? \.wfmux$' ; then
      printf '.wfmux/' >>.gitignore
      git add .wfmux
   fi

   test $? -eq 0 && tmux_message "Switched to '$branch'"

   input_2_quit
   tmux display-popup -C
}

opt_wfmux_checkout  () { wfmux_checkout --clean-worktree; }
opt_wfmux_fcheckout () { wfmux_checkout;                  }

opt_wfmux_cbranch () {
   tmux_or_die

   requires git || return

   project_dir=`get_project_dir "$(tmux_cur_session)"`

   test -z "$project_dir"   \
      && not_wfmux_session   \
      && return 1

   cd -L "$project_dir"

   is_git_repository || return

   tmux_message "$(git branch --show-current)"
   tmux display-popup -C
}

input_2_quit () {
   init_stty=`stty -g`
   stty -echo -cooked && dd if=/dev/tty count=1 bs=1 >/dev/null 2>&1
   stty "$init_stty"
}

opt_wfmux_nremote () {
   tmux_or_die

   requires git || return

   project_dir=`get_project_dir "$(tmux_cur_session)"`

   test -z "$project_dir"   \
      && not_wfmux_session   \
      && return 1

   cd -L "$project_dir"

   is_git_repository || return

   printf 'remote name: '
   read name
   test -z "$name" && return

   printf 'url: '
   read url
   test -z "$url" && return

   git remote add "$name" "$url"
   input_2_quit
}

wfmux_push () {
   tmux_or_die

   requires git || return

   project_dir=`get_project_dir "$(tmux_cur_session)"`

   test -z "$project_dir"   \
      && not_wfmux_session   \
      && return 1

   cd -L "$project_dir"

   is_git_repository || return

   # TODO: wfmux_push
   # $GITLAB_TOK_NAME:$my_tok, --set-upstream $my_tok@...
}

spin () {
   pos=0

   set -- − \\ \| /
   while true ; do 
      sleep 0.2
      pos=$(($pos + 1))
      eval 'printf "\b$'$((($pos % 4) + 1))'"'
   done
} 

opt_wfmux_push  () { wfmux_push;         }
opt_wfmux_fpush () { wfmux_push --force; }


# Add a new watcher to the watcher list
opt_awatcher () {
   watcher_name=
   watch_config="$SESSION_DIR/`tmux_cur_session`/watch"
   project_dir=`__get_project_dir`

   printf "Give a name to your watcher: "
   read watcher_name

   printf "One shot(Y/n)? "
   read one_shot

   if [ -n "$watcher_name" ] ; then
      # Check if this name already exists in the watcher list
      test -f "$watch_config" && cat "$watch_config" | grep -q "^s[-+][01]:\[$watcher_name\]" && return

      __get_files() {
         local args=$(printf "$IGNORE" | sed -e '${ s/\(.*\)/-name "\1"/; q; };1,${ s/\(.*\)/-name "\1" -or /; }' | tr '\n' ' ')
          eval "find '$project_dir' \( $args \) -prune -or -type f -print | sed -e 's,^$project_dir/,,' | $MENU"
      }

      files=`__get_files`
      if [ -n "$files" ]; then
         printf "$ESC_UNDERLINE"

         if [ -r "$COMMANDS" ]; then
            case $one_shot in
            y | Y)
               local cmd=$(cat "$COMMANDS" | grep -v '^[\t ]*\(#.*\)\?$' | eval "$MENU")
               cat <<EOF
s+0[$watcher_name]: $cmd
$files
e[$watcher_name]
EOF
               ;;
            *)
               cat <<-EOF
s+1[$watcher_name]: $cmd
e[$watcher_name]
EOF
               ;;
            esac >>"$watch_config"
            printf "$SUCCESS"
            printf "'$watcher_name' was successfully added to the list of watchers\n"
         else
            printf "$ESC_RED"
            printf "Could not find the list of commands.\n" >&2
            printf "these commands should be located at '$COMMANDS'\n" >&2
         fi
         printf "${ESC_UNSET_ANSI}${ESC_UNSET_ANSI}"

         __input_to_exit
      fi
   fi
}
start_watchers () {
   project_dir=$1
   watch_config="$project_dir/.wfmux/watch"

   ! test -s "$watch_config" && return

   cat "$watch_config" | while read watcher ; do
      expr "$watcher" : 's+' >/dev/null || continue

      watcher_name=$(printf "$watcher" | sed -ne 's/^s+.\[\([^:]]\+\)\]:.*/\1/p')
      is_oneshot=$(printf "$watcher"   | sed -ne 's/^s+\(0\|1\).*/\1/p')
      watcher_cmd=$(printf "$watcher"  | sed -ne 's/^[^:]*:\(.\+\)/\1/;s/^[ \t]*//;s/[ \t]*$//p')

      if test -z "$watcher_name"  \
      || test -z "$is_oneshot"     \
      || test -z "$watcher_cmd" ; then
         die "failed to parse watcher: '$watch_config'"
      fi

      start_watcher "$project_dir" $watcher_name $is_oneshot "$watcher_cmd"
   done
}

start_watcher () {
   project_session=$2
   one_shot=${1%%(*}
   cmd=${1#?(*)}
   watcher_name=${1%%)*}

   watcher_name=${1#?(}

   # You will be seeing the std(out|err) of watchers via named-pipes
   local fifo="$project_session/fifos/$watcher_name.fifo"

   test -p "$fifo" || mkfifo "$fifo"
   { 
      trap '' HUP
      if [ $one_shot = 1 ] ; then
         # for self restarting programs(e.g framework developement server)
         eval "$cmd"
      else
         cat "$project_session/watch" \
         | sed -ne "/^s+0\[$watcher_name\]:/,/^e\[$watcher_name\]/p" \
         | tail -n +2 \
         | sed '$d' \
         | case $WATCHER in
            entr) entr -nr "$cmd" ;;
            *) : ;;
           esac >"$fifo"
      fi
   } >"$fifo" 2>&1 &

   printf "$!" >"$project_session/$watcher_name.pid"
}



# remove watchers from the watcher list
opt_rwatcher () {
   cur_session=`tmux_cur_session`
   [ -z "$cur_session" ] && return

   project_session="$SESSION_DIR/$cur_session"
   watch_config="$project_session/watch"

   test -r "$watch_config" -a -s "$watch_config" || return

   watcher_names=$(cat "$watch_config" | sed -ne 's/^s[-+]\[\(\w*\)\]:.*$/\1/p')
   if [ -n "$watcher_names" ]; then
      watcher_name=$(printf "$watcher_names" | eval "$MENU")

      if [ -n "$watcher_name" ]; then
         printf "$ESC_UNDERLINE"
         cat "$watch_config" | grep -q "^e\[$watcher_name\]"

         if [ $? -eq 0 ]; then
            sed -i "/^s..\[$watcher_name\]:/,/^e\[$watcher_name\]/d" "$watch_config"
            if [ $? -eq 0 ]; then
               if [ -r "$project_session/fifos/$watcher_name.pid" ] ; then
                  pid=$(cat "$project_session/fifos/$watcher_name.pid")
                  kill -KILL "$pid" >/dev/null 2>&1
               fi
               printf "$SUCCESS"
               printf "Watcher '$watcher_name' successfully deleted\n"
            else
               printf "$ESC_RED"
               printf "Could not delete watcher\n"
            fi
         else
            printf "$ESC_RED"
            printf "could not find scope of definition of '$watcher_name'\n"
         fi
         printf "${ESC_UNSET_ANSI}${ESC_UNSET_ANSI}"
      fi
   else
      printf "you do not have any watcher\n"
   fi

   __input_to_exit
}

__ed_watcher () {
   watch_config="$1/watch"

   if [ -r "$watch_config" -a -s "$watch_config" ] ; then
      watcher_names=$(cat "$watch_config" | sed -ne 's/^s[-+][01]\[\(\w*\)\]:.*$/\1/p')

      if [ -n "$watcher_names" ] ; then
         watcher_name=$(printf "$watcher_names" | eval "$MENU")
         if [ -n "$watcher_name" ] ; then
            sed -ie "s/^s.\(.\[$watcher_name\]\)/^s$2\1/" "$watch_config"
         fi
      else
         printf "No watcher were found\n"
      fi
   fi
}

# Enable watchers, should be runned within an existing wfmux tmux session.
# This operation sets on watchers to be runned upon session startup.
opt_ewatcher () {
   cur_session=`tmux_cur_session`
   project_session="$SESSION_DIR/$cur_session"
   watch_file="$project_session/watch"

   [ -z "$cur_session" ] && return

   printf "$ESC_UNDERLINE"

   watcher_name=$(__ed_watcher "$watch_file" +)
   if [ $? -eq 0 ] ; then
      pid_file="$project_session/fifos/$watcher_name.pid"

      if ! test -s "$pid_file" ||
         ! ps a | grep -q "^[\t ]\+$(cat "$pid_file")" ; then
         pairs=$(cat "$watch_file" | sed -ne 's/^s+\(.\)\[\(.*\)\]: *\(.\+\) *$/\1(\2)\3/p')
         __start_watcher "$pairs" "$project_session"
      fi

      printf "$SUCCESS"
      printf "Watcher '$watcher_name' enabled.\n"
      printf "${ESC_UNSET_ANSI}${ESC_UNSET_ANSI}"
   else
      printf "$ESC_RED"
      printf "Could not enable watcher '$watcher_name'\n"
   fi
   printf "${ESC_UNSET_ANSI}${ESC_UNSET_ANSI}"

   __input_to_exit
}

# Disable watchers, should be runned within an existing wfmux tmux session.
# This operation sets off watchers so that they cannot run when a new wfmux
# tmux session is initiated either via `opt_open' or `opt_nsession'
opt_rwatchers () {
   cur_session=`tmux_cur_session`
   project_session="$SESSION_DIR/$cur_session"
   watch_file="$project_session/watch"

   [ -z "$cur_session" ] && return

   printf "$ESC_UNDERLINE"

   watcher_name=$(__ed_watcher "$watch_file" -)
   if [ $? -eq 0 ] ; then
      printf "$SUCCESS"
      printf "Watcher '$watcher_name' disabled.\n"
      printf "${ESC_UNSET_ANSI}${ESC_UNSET_ANSI}"
   else
      printf "$ESC_RED"
      printf "Could not disable watcher '$watcher_name'\n"
   fi
   printf "${ESC_UNSET_ANSI}${ESC_UNSET_ANSI}"

   __input_to_exit
}

# Fancy view of all watchers belonging to the project
# Definition of the view
#             --[ project_name ]--
#    PID:          not running(red), running($COLOR)
#    WATCHER_NAME: disable(red), enabled($COLOR)
#    o/m         : o, not monitored by $runner otherwise m
#
#    WATCHER_NAME   PID    o/m  COMMAND
#    watcher_name_1 pid_1  o    command_1
#    watcher_name_2 pid_2  m    command_2
#    watcher_name_3 pid_3  m    command_3
opt_view () {
   i= j= project_name=`__get_project_dir` project_session=`tmux_cur_session`

   test -z "$project_name" && return
   project_name=`basename "$project_name"`

   printf "${ESC_UNDERLINE}${SUCCESS}${project_name}${ESC_UNSET_ANSI}${ESC_UNSET_ANSI}\n"
   printf "${ESC_BOLD}PID${ESC_UNSET_ANSI}:          shotdown(${ESC_RED}red${ESC_UNSET_ANSI}), running(${SUCCESS}this color${ESC_UNSET_ANSI})\n"
   printf "${ESC_BOLD}WATCHER_NAME${ESC_UNSET_ANSI}: disable(${ESC_RED}red${ESC_UNSET_ANSI}), enabled(${SUCCESS}this color${ESC_UNSET_ANSI})\n"
   printf "${ESC_BOLD}O/M${ESC_UNSET_ANSI}         : ${ESC_BOLD}O${ESC_UNSET_ANSI} = oneshot, ${ESC_BOLD}M${ESC_UNSET_ANSI} = not oneshot\n\n"

   watcher_file="$SESSION_DIR/$project_session/watch"
   while read watcher ; do
      watcher=$(printf "$watcher" | sed -ne "s///p")
      _name=$(printf "$watcher" | awk 'BEGIN{RS="";FS="\n"};{print $1}')
      pid_file="$SESSION_DIR/$project_session/$_name/pid"
      test -s "$pid_file" && _pid=$(cat "$pid_file") || _pid=X
   
      test ${#pid}  -gt $j && j=${#pid}
      test ${#name} -gt $i && i=${#name}

      pid=${pid}${pid:+"\n"}$_pid
      name=${name}${name:+"\n"}$_name
      stat=${stat}${stat:+"\n"}$(printf "$watcher" | awk 'BEGIN{RS="";FS="\n"};{print $2}')
      shot=${shot}${shot:+"\n"}$(printf "$watcher" | awk 'BEGIN{RS="";FS="\n"};{print $3}')
      comm=${comm}${comm:+"\n"}$(printf "$watcher" | awk 'BEGIN{RS="";FS="\n"};{print $4}')
   done <"$watcher_file"

   printf "%${i}s |%${j}s |%-4s |%s\n" "WATCHER_NAME" "PID" "O/M" "COMMAND"
   printf "%${i}s |%${j}s |%-4s |%s\n" "" "" "" ""

   while [ 1 ] ; do
      test ${#name} -eq 0 && break
      printf "%${i}s |%${j}s |%-4s |%s\n" "$_name" "$_pid" "$_stat" "$_comm"
   done
}


opt_ksession () { :; }

# Cycle through std(out&stderr) of watchers
opt_cycle () { :; }

add_plug () {
   name=${1:-}

   test -z "$name" && return

   printf "$WFMUX_OPS" | grep -xqF "$name" || {
      wfmux_message "Another plugin has this name."
      return
   }

   WFMUX_OPS="${WFMUX_OPS}${NL%?}$name"
}

opt_wfmux_ops () {
   tmux_or_die

   # Loading plugins
   if test -d "$WFMUX_PLUG_DIR" ; then
      test -r "$WFMUX_PLUG_DIR" || {
         tmux_message "No read permission for '$WFMUX_PLUG_DIR'"
         return
      }

      for plug in "$WFMUX_PLUG_DIR"/*.wfmux.sh ; do
         . "$plug"
         test $? -eq 0 && continue
         tmux_message "Load('$plug') has a non-zero exit status"
         return 1
      done
   fi

   opt=$(printf '%s' "$WFMUX_OPS" | grep -xEv '(new|ops)' | eval "$MENU")
   test -z "$opt" && return

   func="opt_wfmux_$opt"
   cmd_val=`command -v "$func"`

   if test -z "$cmd_val" ; then
      tmux_message "The wfmux operation '$func' is not defined"
   elif test "$cmd_val" != "$func" ; then
      tmux_message "'$func' should be a function that defines a wfmux operation"
   else
      eval "$func"
   fi
}

main "$@"
