#!/bin/bash

#set -x
set -u

readonly ESC_ALT_SCREEN='\033[?1049h'
readonly ESC_NORMAL_SCREEN='\033[?1049l'
readonly ESC_HIDE_CUR='\033[?25l'
readonly ESC_SHOW_CUR='\033[?25h'
readonly ESC_CLEAR_SCREEN='\033[2J'
readonly ESC_BOLD='\033[1m'
readonly ESC_UNDERLINE='\033[4m'
readonly ESC_RED='\033[31m'
readonly ESC_UNSET_ANSI='\033[0m'

readonly CONF_DIR="${XDG_CONFIG_HOME:-"$HOME/.config"}"
readonly WFMUX_CONF_DIR="${CONF_DIR%%/}/wfmux"
readonly WFMUX_PLUG_DIR="$WFMUX_CONF_DIR/plugins"
readonly TMUX_CONF="$HOME/.tmux.conf"

# Shell running command from `tmux display-pop' does not seem 
# to have sourced profiles.
readonly LOCAL_BIN="$HOME/.local/bin"

# Some watcher commands frequently used in some projects.
readonly WATCHER_TEMPLATES="$WFMUX_CONF_DIR/watchers"

readonly NL="$(printf '\n_')"
readonly NUM_RE='[0-9]\|[1-9][0-9]\+'

mkdir -p "$WFMUX_CONF_DIR"

# Large size
readonly WFMUX_LS=$(cat <<END
                                ┌────────────
                                │
                                │                                            ┌───────
                                │                             ┌───┐          │
            ┌──┐                │                             │   │          │
            │  │                │                             │   │          │
            │  │           ┌────┼─────┬─────┬──────┬──┐       │   │    ┌─────┘
            │  │     ┌─    │    │     │     │      │  │       │   │    │
────────────┘  │     │     │    │     │     │      │  │       │   └────┼─────┐
               │     │     │    │     │     │      │  │       │        │     │
               │     │     │    │     │     └────  │  └───────┘        │     │
               ├─────┴─────┘    │     │            └──                 │     │
               │                │    ─┘                                │     │
               │                │            ──────────────────────────┘     │
               │                └─                                           │
         ──────┘                                                             │
                                                                             │
END
)

# Medium size
readonly WFMUX_MS=$(cat <<END
                     ┌─────────                      ┌───
                     │                               │
        ┌─┐          │                     ┌──┐      │
        │ │       ┌──┼───┬───┬───┬───┐     │  │  ┌───┘
        │ │   ┌─  │  │   │   │   │   │     │  │  │
────────┘ │   │   │  │   │   │   │   │     │  └──┼───┐
          │   │   │  │   │   └─  │   │     │     │   │
          ├───┴───┘  │  ─┘       │   └─────┘     │   │
          │          └─          └──             │   │
          │                  ────────────────────┘   │
     ─────┘                                          │
                                                     │
END
)

# Small size
readonly WFMUX_SS='WFMUX'

readonly WFMUX=$(cat<<END

     ┌──────────────┤ WFMUX
    ┌┴────────────────────────────────────────┐
    │                                         │
    ├─ Input a name for a new tmux session    │
    ├─ Input f⟨return⟩ to select a project    │
    ├─ Input ⟨return⟩ to drop to the terminal │
    │                                         │
    └─────────────────────────────────────────┘
END
)

WFMUX_CONF="$WFMUX_CONF_DIR/wfmux.conf"
WFMUX_OPS=$(cat <<END
new
tmux
dump
open
explore
shell
nsession
ksession
switch
log
commit
acommit
checkout
fcheckout
cbranch
view
awatch
rwatch
mwatch
ewatch
dwatch
vwatch
cwatch
sawatch
sowatch
wtop
ops
last
END
)

# Default configuration if external config file does not exist
COLOR=4
SUCCESS="\033[1;3${COLOR}m"

WATCHER='entr'
FILE_MANAGER='nnn'

WIN_ATT_OPT='20x20+10+20'

BIND_OPS='i'
BIND_OPEN='Enter'
BIND_EXPLORE='BSpace'
BIND_SWITCH='w'
BIND_SHELL='r'
BIND_CYCLE='a'
BIND_LAST='p'

MENU='fzf --multi --margin=25%'

PROJ_DIRS=$(cat <<END
$HOME/projects
$HOME/oprojects
END
)

USE_XDG_OPEN=false

PROGRAMS=$(cat <<END
tty=true,text=vim '%s'
tty=true,directory=nnn '%s'
tty=false,video=ffplay -hide_banner -loop 0 '%s'
tty=true,audio=ffplay  -hide_banner -loop 0 -nodisp '%s'
tty=false,pdf=zathura '%s'
tty=false,image=feh '%s'
END
)

usage () {
   cat <<END
Build an awesome dev workflow using tmux, fzf, nnn, entr and more.

Usage: wfmux [ -h | --help ]
       wfmux [ ( -c | --conf ) CONF ] OPT
       
Options:
     -h, --help         print this help message.
     -c, --conf CONF    load CONF configuration file.

OPT:
    new          Select a project, create and attach a new tmux session
                 for it. A project with an already existing tmux session
                 has that session reused.
    dump         Dump to the stdout the tmux configuration of wfmux.
    tmux         Update the tmux configuration of wfmux at ~/.tmux.conf.
    open         Select a project file to open.
    explore      In a popup tmux pane, open at the project directory the
                 configured TUI file manager.
    shell        Launch the shell on a popup tmux pane.
    nsession     Just like \`new' but does not show the already existing
                 tmux session.
    ksession     Kill a wfmux tmux session.
    switch       Switch between different wfmux tmux sessions.

    log          View the git logs of the current project.
    commit       Select changes of the current project and commit them.
    acommit      If the working tree is clean, simply run a git amend
                 command; otherwise select changes and add them to the
                 index before running a git amend command.
    push         Push changes to the configured remote repositories if
                 any.
    fpush        Force push to the remote repository, the default push
                 wfmux operation refuses to update a remote ref that is
                 not an ancestor of the local ref used to overwrite it.

    checkout     Switch to a branch in your project.
    fcheckout    Force the checkout since the above fails if the working
                 tree is not clean.

    cbranch      Show in tmux the name of the current branch of your
                 project.

    awatch       Create a watcher and add it to the watcher registry of
                 the current project.
    rwatch       Selected a watcher from the watcher registry to delete
                 from that registry.
    mwatch       Modify the attributes of a watcher from the watcher
                 registry.
    ewatch       Enable a watcher from the watcher registry, enabled
                 watchers of a project will be started at the creation
                 of that project's tmux session.
    dwatch       Disable a watcher from the watcher registry.
    vwatch       View the stdout of a running watcher.
    cwatch       Cycle through the standard output of all the running
                 watchers of the current project.
    sawatch      Launch a watcher from the watcher registry of the
                 current project.
    sowatch      Stop a running watcher launched from the watcher
                 registry of the current project.

    wtop         View the characteristics of all registered watchers.
    ops          A wfmux operation to call other wfmux operations whether
                 built-in or gotten via wfmux plugins.
    last         Call the last called wfmux operation.

END

   exit $1
}

die () {
   say "$0: $*." >&2
   exit 1
}

main () {
   opt_name=

   test $# -eq 0 && usage 1
   while test $# -ne 0 ; do
      case "$1" in
      -h|--help)
         usage 0
         ;;
      -c|--conf)
         test $# -gt 2 || usage 1
         test -e "$2"  || die "Conf file '$2' does not exist"
         WFMUX_CONF=$2
         shift
         ;;
      -*)
         die "Unknown option '$1', please try \`$0 --help'"
         ;;
      *)
         test -n "$opt_name" && usage 1
         say "$WFMUX_OPS" | grep -xqF "$1"

         test $? -ne 0 && {
            emsg="'$1' is an unknown wfmux operation"

            test -n "${TMUX:-}" && tmux_message "$emsg"
            die "$emsg"
         }
         opt_name=$1
         ;;
      esac
      shift
   done

   test -f "$WFMUX_CONF" && {
      test -r "$WFMUX_CONF" || die "No permission to read '$WFMUX_CONF'"
      . "$WFMUX_CONF"       || die "Non-zero exit status when sourcing config"
   }

   check_conf_vars
   eval "opt_wfmux_$opt_name"
}

die_conf () {
   test -z "${TMUX:-}"                   \
      && die "('$WFMUX_CONF'): $*"        \
      || wfmux_die "('$WFMUX_CONF'): $*."
}

check_conf_vars () {
   var=''
   is_set=''

   v_err () {
      die_conf "Invalid value assigned to '$1'"
   }

   # Check it all here though they aren't all used in a single wfmux opt
   for var in USE_XDG_OPEN MENU WIN_ATT_OPT   \
              PROJ_DIRS FILE_MANAGER WATCHER   \
              BIND_OPS BIND_OPEN BIND_EXPLORE   \
              BIND_SWITCH BIND_SHELL BIND_LAST   \
              BIND_CYCLE ; do

      eval 'is_set=${'$var':+true}'
      test -z "$is_set" && die_conf "'$var' isn't defined"
   done

   # Check if we've got sane values
   expr "$COLOR" : '[0-9]$' >/dev/null || v_err COLOR

   test "$USE_XDG_OPEN" = true        \
      || test "$USE_XDG_OPEN" = false  \
      || v_err USE_XDG_OPEN

   # MENU is used by most wfmux opts, so check it here!
   menu="${MENU%% *}"
   command -v "$menu" >/dev/null || die_conf "var(MENU): '$menu': Command not found"

   proj_dirs=
   O_IFS=$IFS IFS=${NL%?}

   # This variable is used by all wfmux opts
   for path in $PROJ_DIRS ; do
      rpath=$(realpath -e "$path" 2>/dev/null)

      test $? -eq 0    || die_conf "'$path' does not exist"
      test -d "$rpath" || die_conf "'$rpath' is not a directory"
      test -r "$rpath" || die_conf "cannot list contents of '$rpath'"

      proj_dirs="$proj_dirs${proj_dirs:+${NL%?}}$rpath"
   done

   IFS=$O_IFS
   PROJ_DIRS="$proj_dirs"
}

tty_print () {
   printf '\033[%d;%df%s' "$1" "$2" "$3" >/dev/tty
}

awk_max () {
   fn_max='
      BEGIN { len = 0 }
      {
         nlen = length($0)
         if (nlen > len)
            len = nlen
      }
      END { print len }
   '
   awk "$fn_max"
}

dashboard_msg () {

   cat <<END
The following are tmux bindings related to wfmux.

M-$BIND_OPEN: Select project files to open.
M-$BIND_EXPLORE: Open TUI file manager.
M-$BIND_SHELL: Launch a shell on a popup tmux pane.
M-$BIND_SWITCH: Switch to other wfmux tmux sessions.
M-$BIND_LAST: Call the last called wfmux operation.
M-$BIND_CYCLE: Cycle through the output of running watchers.
M-$BIND_OPS: Select other wfmux operations to execute.

Input anything to exit this dashboard.
END

}

display_dashboard () {
   # Save initial term setting, set back after exiting dashboard!
   init_stty=$(stty -g)

   stty -cooked -echo min 0
   printf "${ESC_ALT_SCREEN}${ESC_HIDE_CUR}${ESC_CLEAR_SCREEN}"

   key=''
   term_h=''
   term_w=''
   while true ; do

      new_size=$(stty -F /dev/tty size)
      test "$new_size" = "$term_h $term_w" && {
         stty time 10 min 0 >/dev/null 2>&1

         # Get key from the standard input
         key=$(dd if=/dev/tty count=1 bs=1 2>/dev/null)
         test -n "$key" && break
         continue
      }

      term_h="${new_size%% *}"
      term_w="${new_size##* }"
      if   test "$term_h" -lt 32 || test "$term_w" -lt 97 ; then
         _size=SS
      elif test "$term_h" -lt 43 || test "$term_w" -lt 155 ; then
         _size=MS
      else
         _size=LS
      fi
      eval 'wfmux_h=$(printf "$WFMUX_'$_size'" | wc -l)
            wfmux_w=$(printf "$WFMUX_'$_size'" | awk_max)'

      wfmux_h=$(expr "$wfmux_h" + $(dashboard_msg | wc -l))

      x=$(( ($term_w - $wfmux_w) / 2 ))
      y=$(( ($term_h - $wfmux_h) / 2 ))

      msg_w=$(dashboard_msg | awk_max)
      if test $msg_w -gt $wfmux_w ; then
         msg_x=$(( $x - ($msg_w - $wfmux_w) / 2 ))
      else
         msg_x=$(( $x + ($wfmux_w - $msg_w) / 2 ))
      fi

      printf "${ESC_CLEAR_SCREEN}${SUCCESS}${ESC_BOLD}"

      IFS=${NL%?}
      for line in $(eval 'printf "$WFMUX_'$_size'"') ; do
         tty_print $y $x "$line"
         y=$(( $y + 1 ))
      done

      printf "$ESC_UNSET_ANSI"
      for line in $(dashboard_msg) ; do
         y=$(( $y + 1 ))
         tty_print "$y" "$msg_x" "$line"
      done
   done

   stty "$init_stty"
   printf "${ESC_NORMAL_SCREEN}${ESC_UNSET_ANSI}${ESC_SHOW_CUR}"
}

tmux_cur_session () {
   tmux list-sessions -F '#S:#{session_activity}' | sort -b -t: -k2,2n | tail -n1 | cut -d: -f1
}

tmux_cur_pty () {
   tmux list-clients -F '#S:#{client_tty}' | grep -F "$(tmux_cur_session):" | head -n1 | cut -d: -f2
}

tmux_message () {
   tmux display-message -d 2500 -- "$*."
}

wfmux_die () {
   tmux_message "$*"
   tmux display-popup -C
   exit 1
}

shrink_proj_dirs () {
   sdirs=$PROJ_DIRS

   for n in $(seq $(say "$sdirs" | wc -l)) ; do
      path=$(say "$sdirs" | sed -ne "${n}p")

      # Check if it's already shrinked
      expr "$path" : / >/dev/null || continue

      name=${path#/}
      name=${name%%/*}

      # Check if $path is the only one.
      test $(say "$sdirs" | grep "^/$name/" | wc -l) -eq 1 && continue

      path=${path#/*/}
      sdirs=$(say "$sdirs" | sed -e "s#^/$name/#*/#")

      # Shrink more
      O_IFS=$IFS IFS=/
      for name in $path ; do
         test $(say "$sdirs" | grep "^\*/$name/" | wc -l) -eq 1 && continue

         _sdirs=$(say "$sdirs" | sed -e "s#^\*/$name/#*/#")

         a=$(say "$_sdirs" | sed -e 's/\*/.../')
         b=$(say "$a"      | sort -u)
         test ${#a} -ne ${#b} && break

         sdirs=$_sdirs
      done
      IFS=$O_IFS

      sdirs=$(say "$sdirs" | sed -e 's/\*/.../')
   done

   say "$sdirs"
}

get_proj_list () {
   line=1
   sdirs=$(shrink_proj_dirs)

   IFS=${NL%?}
   for dir in $PROJ_DIRS ; do
      cd "$dir"

      for file in * ; do
         test -d "$file" || continue
         test -x "$file" || continue

         sdir=$(say "$sdirs" | sed -ne "${line}p")
         printf "[%d]:%s/%s\n" $line "$sdir" "$file"
      done

      line=$(( $line + 1 ))
   done
}

new_session () {
   project=$(get_proj_list | eval "$MENU")

   test -z "$project" && return

   line="${project%%]*}"
   line="${line#[}"
   proj_ddir=$(say "$PROJ_DIRS" | sed -ne "${line}p")
   proj_name=$(basename "$project")
   session=$(say "$proj_name" | sed -e 'y/-./__/')
   proj_dir="$proj_ddir/$proj_name"

   cd -L "$proj_dir"

   test -d .git && {
      touch .gitignore
      grep -q -- .wfmux .gitignore || {
         say '.wfmux' >>.gitignore
         git add .gitignore && git commit -m 'Update .gitignore'
      } 
   }

   if test -d .wfmux      \
   && test -x .wfmux       \
   && test -s .wfmux/name   \
   && expr "$(cat .wfmux/name)" : "$session-.\\{6\\}$" >/dev/null ; then
      session=$(cat .wfmux/name)
   else
      rm -rf .wfmux
      mkdir .wfmux
      touch .wfmux/name

      proj_name=$(say "$proj_name" | sed -e 'y/-./__/')
      session=$(mktemp -u $proj_name-XXXXXX)
      printf "$session" >>.wfmux/name
      say './.git' >>.wfmux/ignore
   fi

   if [ -z "${TMUX:-}" ] ; then
      tmux has-session -t "$session" 2>/dev/null || {
         id=${session##*-}

         display_dashboard
         tmux new-session -s "$session" -d
         start_watcher "$proj_dir" "$id"
     }
      exec tmux attach-session -t "$session"
   else
      pty=$(tmux_cur_pty)

      tmux has-session -t "$session" 2>/dev/null || tmux new-session -s "$session" -d
      start_watcher "$proj_dir" "$id"
      exec tmux switch-client -c "$pty" -t "$session"
   fi
}

# Create a new wfmux tmux session while in an existing tmux session
opt_wfmux_nsession () { new_session; }

# Kill a wfmux tmux session
opt_wfmux_ksession () {
   tmux_or_die

   proj_dirs=''
   wfmux_sessions=''

   IFS=${NL%?}
   for session in $(tmux list-sessions -F '#S:#{session_activity}' | sort -b -t: -k2,2n) ; do
      session=${session%:*}
      proj_dir=$(get_proj_dir "$session")

      test -z "$proj_dir" && continue

      proj_dirs="${proj_dirs}${proj_dirs:+$IFS}${proj_dir}"
      wfmux_sessions="${wfmux_sessions}${wfmux_sessions:+$IFS}${session}"
   done

   if test -z "$wfmux_sessions" ; then
      wfmux_die 'No wfmux tmux session was detected'
   fi

   session=$(say "$wfmux_sessions" | eval "$MENU")
   test -z "$session" && return

   n=$(say "$wfmux_sessions"   | sed -ne "/^$session$/=")
   proj_dir=$(say "$proj_dirs" | sed -ne "${n}p")

   watch_conf="$proj_dir/.wfmux/watch"

   # First stop all its watchers.
   IFS=${NL%?}
   for name in $(watchers "$watch_conf") ; do
      pid_file="$proj_dir/.wfmux/pids/$name.pid"
      stop_watcher "$name" "$pid_file"
   done

   # Switch to the most recently accessed wfmux tmux session first.
   if test "$(cur_session)" = "$session" \
   && test $(say "$wfmux_sessions" | wc -l) -gt 1 ; then
      test $n -eq 1         \
         && n=$(( $n + 1 ))  \
         || n=$(( $n - 1 ))

      target_session=$(say "$wfmux_sessions" | sed -ne "${n}p")
      tmux switch-client -c "$(cur_pty)" -t "$target_session"
   fi

   tmux kill-session -t "$session"
}

# Select a project and open a tmux session
opt_wfmux_new () {
   input=''
   session=''

   if tmux list-sessions >/dev/null 2>&1 ; then
      printf "Choose an existing session to attach\n\n"
      tmux list-sessions | awk '{print "["NR"] "$0}'
   fi

   say "$WFMUX"
   printf '⟩⟩ '
   read input
   tput clear

   test -z "$input" && return

   if test "$input" = f ; then
      new_session
   elif expr "$input" : '\([0-9]\|[1-9][0-9]\+\)$' >/dev/null ; then
      session=$(tmux list-sessions -F '#S' | sed -n "${input}p")
      test -n "$session" && exec tmux attach-session -t "$session"
   else
      exec tmux new-session -s "$input"
   fi
}

set_whxy () {
   name=$1
   win_att=$2

   num_re="$NUM_RE"
   com_re='C\|P\|M\|W'

   x_re="\($com_re\|R\|$num_re\)"
   y_re="\($com_re\|S\|$num_re\)"

   size_re="\(\($num_re\)%\?\)"

   c=$(say "$win_att" | sed -ne "s/^${size_re}x${size_re}+${x_re}+${y_re}$/w=\1 h=\3 x=\5 y=\6/p")

   test -z "$c" && die_conf "Invalid value assigned to '$name'"
   eval "$c"
}

dump_conf () {
   set_whxy WIN_ATT_OPT "$WIN_ATT_OPT"

   cat <<END

unbind M-$BIND_OPS
bind   M-$BIND_OPS      display-popup -w $w -h $h -x $x -y $y -E "$LOCAL_BIN/wfmux ops"

unbind M-$BIND_OPEN
bind   M-$BIND_OPEN     display-popup -w $w -h $h -x $x -y $y -E "$LOCAL_BIN/wfmux open"

unbind M-$BIND_EXPLORE
bind   M-$BIND_EXPLORE  display-popup -w $w -h $h -x $x -y $y -E "$LOCAL_BIN/wfmux explore"

unbind M-$BIND_SWITCH
bind   M-$BIND_SWITCH   display-popup -w $w -h $h -x $x -y $y -E "$LOCAL_BIN/wfmux switch"

unbind M-$BIND_LAST
bind   M-$BIND_LAST     display-popup -w $w -h $h -x $x -y $y -E "$LOCAL_BIN/wfmux last"

unbind-key $BIND_SHELL
bind-key   $BIND_SHELL    display-popup -w $w -h $h -x $x -y $y -E "$LOCAL_BIN/wfmux shell"

unbind-key $BIND_CYCLE
bind-key   $BIND_CYCLE    run-shell "$LOCAL_BIN/wfmux cwatch"

END
}

opt_wfmux_dump () { dump_conf; }
opt_wfmux_tmux () { dump_conf >>"$TMUX_CONF"; }

each () {
   for i in "$@" ; do
      say "$i"
   done
}

get_proj_dir () {
   session=$1
   proj_name=''

   proj_name=$(say "$session" | sed -ne 's/^\([^-]\+\)-.\{6\}$/\1/p')
   test -z "$proj_name" && return

   IFS=${NL%?}
   for dir in $PROJ_DIRS ; do
      proj_dir=$(say "$dir/$proj_name" | tr '_' '?' | sed -e 's/\([^\\]\) /\1\\ /g')

      for proj_dir in $(eval each "$proj_dir") ; do
         test -d "$proj_dir"       \
            && test -x "$proj_dir"  \
            && cd -L "$proj_dir"     \
            || continue

         test -f .wfmux/name                          \
            && test "$session" = "$(cat .wfmux/name)"  \
            && say "$proj_dir"
      done
   done
}

tmux_or_die () {
   test -n "${TMUX:-}" || die 'Wfmux must run in a tmux session'
}

opt_wfmux_switch () {
   tmux_or_die

   wfmux_sessions=''

   IFS=${NL%?}
   for session in $(tmux list-sessions -F '#S') ; do
      test -z "$(get_proj_dir "$session")" && continue
      wfmux_sessions="${wfmux_sessions}${session}\n"
   done

   test -z "$wfmux_sessions" && return
   session=$(printf "$wfmux_sessions" | eval "$MENU")

   if test -n "$session" ; then
      tmux switch-client -c "$(tmux_cur_pty)" -t "$session"
   fi
}

last_wfmux_opt () {
   opt=$2
   say "$opt" >"$proj_dir/.wfmux/last"
}

## Open TUI file manager
opt_wfmux_explore () {
   tmux_or_die

   requires "$FILE_MANAGER"

   proj_dir=$(get_proj_dir "$(tmux_cur_session)")

   test -z "$proj_dir" && die_not_wfmux

   last_wfmux_opt explore

   eval "$FILE_MANAGER" "$proj_dir"
}

# Add some checks since this function is exposed as a wfmux API function.
get_proj_files () {
   ignore=''
   dir_opt=''

   test $# -eq 1       \
      || test $# -eq 2  \
      || die "get_proj_files: Invalid number of arguments"

   test "${1#-}" = "$1"         \
      && dir=     proj_dir="$1"  \
      || dir="$1" proj_dir="$2"

   test "$dir" = '-d' && dir_opt='-or -type d'

   cd -L -- "$proj_dir"
   if test -s .wfmux/ignore ; then
      IFS=${NL%?}
      for pattern in $(cat .wfmux/ignore) ; do
         ignore="${ignore}${ignore:+ -or}"
         ignore="${ignore} -path '${pattern}'"
      done
   fi

   if [ -n "$ignore" ] ; then
      eval find . '\(' "$ignore" '\)' -prune -or -type f "$dir_opt"
   else
      eval find . -type f "$dir_opt"
   fi
}

get_filetype () {
   file=$1

   if command -v xdg-mime >/dev/null ; then
      filetype=$(xdg-mime query filetype "$file")
   elif command -v file >/dev/null ; then
      filetype=$(file --mime-type "$file")
      filetype=${filetype##*: }
   else
      tmux-message "'$file': Couldn't determine the file type"
      return
   fi

   expr "$filetype" : application >/dev/null  \
      && filetype=${filetype##*/}              \
      || filetype=${filetype%%/*}

   printf "$filetype"
}

say () {
   printf '%s\n' "$*"
}

## Open a project file
opt_wfmux_open () {
   tmux_or_die

   test "$USE_XDG_OPEN" = true && requires xdg-open

   proj_dir=$(get_proj_dir "$(tmux_cur_session)")
   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   files=$(get_proj_files "$proj_dir" | eval "$MENU")

   IFS="${NL%?}"
   for file in $files ; do

      if test "$USE_XDG_OPEN" = true ; then
         cmd="xdg-open '$file'"
      else
         filetype=$(get_filetype "$file")
         test -z "$filetype" && continue

         data=$(say "$PROGRAMS" | grep "^tty=\(true\|false\),$filetype=" | head -n1)

         test -z "$data" && {
            tmux_message "Unable to open '$file'"
            continue
         }

         use_tty=${data%,$filetype=*}
         use_tty=${use_tty#tty=}

         cmd="${data#*,$filetype=}"
         cmd=$(printf "$cmd" "$file")

         bin="${cmd%% *}"
         command -v "$bin" >/dev/null || {
            tmux_message "Unable to open '$file', $bin: not found"
            continue
         }
      fi

      run_cmd "$cmd" $use_tty
   done

   last_wfmux_opt open
}

get_shell () {
   sh="${SHELL:-}"

   if test -z "$sh" ; then
      id=$(id -u)
      sh=$(cat '/etc/passwd' | grep "x:$id:")
      sh="${sh##*:}"
   fi
   sh="${sh##*/}"
   say "${sh:-sh}"
}

run_cmd () {
   cmd=$1
   use_tty=$2

   test "$use_tty" = true || {
      { trap '' HUP; eval "$cmd"; } &
      return 0
   }

   panes=$(tmux list-panes -F '#{pane_current_command}:#P:#{pane_active}')

   # If possible, run the command in an idle pane.
   sh=$(get_shell)
   idle_panes=$(say "$panes" | grep "^$sh:")

   if test -n "$idle_panes" ; then

      target=$(say "$idle_panes" | grep ':1$')
      target=${target%:1}

      test -z "$target" && {
         target=$(say "$idle_panes" | sort -t: -k1,1n | head -n1)
         target=${target%:0}
      }

      target=${target##*:}
      tmux send-keys -t "$target" "$cmd" C-m

   # Spawn off a new pane in the current window if there's only one pane
   # and that pane is busy.
   elif test $(say "$panes" | wc -l) -eq 1 ; then

      tmux split-window -h "$cmd"

   # In the worst case, run it in a new window.
   else
      tmux new-window "$cmd"
   fi

   return 0
}

opt_wfmux_shell () {
   tmux_or_die

   proj_dir=$(get_proj_dir "$(tmux_cur_session)")
   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   last_wfmux_opt shell
   exec ${SHELL:-/bin/sh}
}

is_git_repository () {
   git rev-parse --show-toplevel >/dev/null 2>&1 || {
      wfmux_die "This project isn't a git repository"
   }
}

die_not_wfmux () {
   wfmux_die 'This is not a wfmux tmux session'
}

requires () {
   for cmd in "$@" ; do
      command -v "$cmd" >/dev/null \
         || wfmux_die "$cmd: Command not found"
   done
}

has () {
   command -v "$1" >/dev/null
}

opt_wfmux_log () {
   tmux_or_die

   requires git

   proj_dir=$(get_proj_dir "$(tmux_cur_session)")
   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   is_git_repository || return

   last_wfmux_opt log
   git log --graph
}

git_status () {
   git status --porcelain --ignore-submodules
}

commit () {
   tmux_or_die

   requires git

   opt=$1; shift

   proj_dir=$(get_proj_dir "$(tmux_cur_session)")
   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   is_git_repository || return

   export EDITOR="${EDITOR:-vim}"
   command -v "$EDITOR" >/dev/null || wfmux_die "$EDITOR: Command not found"

   gstatus=$(git_status | sed -e 's/^ /-/;s/^??/-U/;s/^\(.\)  /\1 /')

   test -z "$gstatus"  \
      && test $# -eq 0  \
      && wfmux_die 'Nothing to commit, working tree clean'

   test -n "$gstatus" && gstatus=$(say "$gstatus" | eval "$MENU")

   test -z "$gstatus"  \
      && test $# -eq 0  \
      && {
      tmux display-popup -C
      return
   }

   IFS="${NL%?}"
   for change in $gstatus ; do
      file=${change#* }
      ctype=${change%% *}

      test "${ctype%?}" != '-' && continue

      ctype=${ctype#?}
      test "$ctype" != M       \
         && test "$ctype" != U  \
         && continue

      git add "$file" 2>/dev/null || wfmux_die "'$file' Couldn't be added to the index"
   done

   last_wfmux_opt "$opt"
   git commit "$@"
}

opt_wfmux_commit () {
   commit commit || tmux_message "Unable to commit"
}

opt_wfmux_acommit () {
   commit acommit --amend || tmux_message "Unable to amend"
}

git_branches () {
   IFS="${NL%?}"

   for lbranch in $(git branch --list --no-color) ; do
      test "${lbranch% *}" = '*' && continue

      lbranch="${lbranch#  }"
      rbranch=$(git rev-parse --abbrev-ref "$lbranch@{u}" 2>/dev/null)

      if test $? -eq 0 ; then
         printf 'L %s -> %s\n' "$lbranch" "$rbranch"
      else
         printf 'L %s\n' "$lbranch"
      fi
   done

   git branch --remote --no-color | sed -ne '2,$s/^ */R /p'
}

new_branch () {
   rbranch=$1
   lbranch=${rbranch##*/}

   git show-ref --verify --quiet "refs/heads/$lbranch" && {

      say "$branch: Local branch name already exists"
      printf 'New name (y/n)? '
      read input
      test "$input" != y && return

      printf ': '
      read lbranch
      test -z "$lbranch" && return

      git check-ref-format --branch "$lbranch" >/dev/null
      test $? -ne 0 && return 1
   }

   git checkout -b "$lbranch" --track "$rbranch"
}

git_checkout () {
   tmux_or_die

   requires git

   opt=$1; shift

   proj_dir=$(get_proj_dir "$(tmux_cur_session)")
   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   is_git_repository || return

   test "${1:-}" = '--clean-worktree' && {
      test -z "$(git_status)" || {
         wfmux_die 'Still have local changes to be commited'
      }
   }

   branch=$(git_branches | eval "$MENU")
   test -z "$branch" && return

   btype="${branch%% *}"
   branch="${branch#? }"
   branch="${branch%% *}"

   last_wfmux_opt "$opt"

   if test "$btype" = L ; then
      git checkout "$branch"
   else
      new_branch "$branch"
   fi

   test $? -eq 0 && {
      tmux_message "Switched to '$branch'"

      git_status | grep -xq '?? \.wfmux' && {
         say '.wfmux/' >>.gitignore
         git add .wfmux
      }
   }

   input_2_quit
   tmux display-popup -C
}

opt_wfmux_checkout  () { git_checkout checkout --clean-worktree; }
opt_wfmux_fcheckout () { git_checkout fcheckout;                 }

opt_wfmux_cbranch () {
   tmux_or_die

   requires git

   proj_dir=$(get_proj_dir "$(tmux_cur_session)")

   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   is_git_repository || return

   last_wfmux_opt cbranch

   tmux_message "$(git branch --show-current)"
   tmux display-popup -C
}

input_2_quit () {
   init_stty=$(stty -g)
   stty -echo -cooked && dd if=/dev/tty count=1 bs=1 >/dev/null 2>&1
   stty "$init_stty"
}

opt_wfmux_nremote () {
   tmux_or_die

   requires git

   proj_dir=$(get_proj_dir "$(tmux_cur_session)")
   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   is_git_repository || return

   printf 'remote name: '
   read name
   test -z "$name" && return

   printf 'url: '
   read url
   test -z "$url" && return

   last_wfmux_opt nremote

   git remote add "$name" "$url"
   input_2_quit
}

opt_wfmux_awatch () {
   tmux_or_die

   proj_dir=$(get_proj_dir "$(tmux_cur_session)")
   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   printf 'watcher name: '
   read name
   test -z "$name" && return

   expr "$name" : '[a-zA-Z][-a-zA-Z0-9]\+$' >/dev/null || {
      wfmux_die "'$name' isn't a valid watcher name"
   }

   watch_conf="$proj_dir/.wfmux/watch"

   if test -s "$watch_conf"  \
   && grep -q "^w[-+],[01],\[$name\]:" "$watch_conf" ; then
      wfmux_die "A watcher named '$name' already exists"
   fi

   printf 'one shot? (y/n) '
   read wtype
   test "$wtype" = y && wtype=1 || wtype=0

   printf 'cmd: '
   read cmd
   test -z "$cmd" && return

   files=$(get_proj_files -d "$proj_dir" | eval "$MENU")

   say "w+,$wtype,[$name]:$cmd${NL%?}$files${NL%?}end" >>"$watch_conf"

   last_wfmux_opt awatch
   tmux_message "Added watcher named '$name'"
}

watchers () {
   sed -ne 's/^w[-+],[01],\[\([^]]\+\)\]:.\+$/\1/p' "$1"
}

select_watcher () {
   watch_conf=$1
   names=''

   test -f "$watch_conf" || rm -f "$watch_conf"

   touch "$watch_conf"
   names=$(watchers "$watch_conf")

   if test -z "$names" ; then
      wfmux_die 'There are no configured watchers'
   fi

   say "$(say "$names" | eval "$MENU")"
}

check_conf () {
   name=$1
   conf=$2

   e="
      1 { s/^w[-+],[01],\[$name\]:.*[:a-zA-Z].*$/1/p; b }
      $ { s/^end$/1/p; b }
      /^\.\//p
   "
   a=$(say "$conf" | wc -l)
   b=$(say "$conf" | sed -ne "$e" | wc -l)

   test "$a" -eq "$b" || wfmux_die "watcher($name): Invalid watcher config"
}

opt_wfmux_mwatch () {
   tmux_or_die

   edit=${EDITOR:-vim}
   requires "$edit"

   proj_dir=$(get_proj_dir "$(tmux_cur_session)")
   test -z "$proj_dir" && die_not_wfmux

   watch_conf="$proj_dir/.wfmux/watch"

   name=$(select_watcher "$watch_conf")
   test -z "$name" && return

   e="
      /^w[-+],[01],\[$name\]:/ {
         p
         n
         b loop
      }
      b
      :loop
         /^\.\// { p; n; b loop }
         /^end$/ { p; q }
         n
         b loop
   "

   conf=$(sed -ne "$e" "$watch_conf")
   if test -z "$conf" ; then
      wfmux_die "There is no watcher named '$name'"
   fi

   check_conf $name "$conf"

   tmpfile=$(mktemp /tmp/wfmux.XXXXXX)
   say "$conf" >>$tmpfile
   say '# Please edit the watcher configuration. Empty lines and' >>$tmpfile
   say '# lines starting with "#" will be ignored.' >>$tmpfile

   eval "$edit" $tmpfile
   conf=$(grep -xv '[[:space:]]*\(#.*\)\?' $tmpfile)

   check_conf $name "$conf"
   del_watcher $name "$watch_conf"
   say "$conf" >>"$watch_conf"

   last_wfmux_opt mwatch
}

del_watcher () {
   name=$1
   watch_conf=$2

   sed -i "/^w[-+],[01],\[$name\]:/,/^end$/d" "$watch_conf"
}

opt_wfmux_rwatch () {
   tmux_or_die

   proj_dir=$(get_proj_dir "$(tmux_cur_session)")
   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   watch_conf="$proj_dir/.wfmux/watch"

   name=$(select_watcher "$watch_conf")
   test -z "$name" && return

   del_watcher "$name" "$watch_conf"
   last_wfmux_opt rwatch
}

watcher_state_edit () {
   opt=$1

   state=${2:--e}
   test "$state" = '-e' && state=+ || state=-

   proj_dir=$(get_proj_dir "$(tmux_cur_session)")
   test -z "$proj_dir" && die_not_wfmux

   watch_conf="$proj_dir/.wfmux/watch"

   name=$(select_watcher "$watch_conf")
   test -z "$name" && return

   sed -i "s/^w[-+]\(,[01],\[$name\]:\)/w$state\1/" "$watch_conf"
   grep -q "^w$state,[01],\[$name\]:" "$watch_conf"

   last_wfmux_opt "$opt"
}

opt_wfmux_dwatch () {
   tmux_or_die

   if watcher_state_edit dwatch -d ; then
      tmux_message "Watcher successfully disabled"
   else
      wfmux_die "The watcher couldn't be disabled"
   fi
}

opt_wfmux_ewatch () {
   tmux_or_die

   if watcher_state_edit ewatch -e ; then
      tmux_message "Watcher successfully enabled"
   else
      wfmux_die "The watcher couldn't be enabled"
   fi
}

opt_wfmux_sawatch () {
   tmux_or_die

   command -v "$WATCHER" >/dev/null || die_conf "$WATCHER: command not found"

   session=$(tmux_cur_session)
   id=${session##*-}

   proj_dir=$(get_proj_dir "$session")
   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   watch_conf="$proj_dir/.wfmux/watch"

   name=$(select_watcher "$watch_conf")
   test -z "$name" && return

   pid_file="$proj_dir/.wfmux/pids/$name.pid"

   if test -s "$pid_file"                    \
   && read pid <"$pid_file"                   \
   && expr "$pid" : "\($NUM_RE\)$" >/dev/null  \
   && test -d "/proc/$pid" ; then
      wfmux_die "watch($name): The watcher is already running"
   fi

   start_watcher "$proj_dir" "$id" "$name"
   last_wfmux_opt sawatch

   tmux display-popup -C
}

opt_wfmux_sowatch () {
   tmux_or_die

   proj_dir=$(get_proj_dir "$(tmux_cur_session)")
   test -z "$proj_dir" && die_not_wfmux

   watch_conf="$proj_dir/.wfmux/watch"
   count_file="$proj_dir/.wfmux/count"

   name=$(select_watcher "$watch_conf")
   test -z "$name" && return

   pid_file="$proj_dir/.wfmux/pids/$name.pid"
   if ! test -s "$pid_file" ; then
      wfmux_die "watcher($name): Unable to find the pid of the watcher"
   fi

   sed -i "/^$name:/d" "$count_file"

   stop_watcher "$name" "$pid_file"
   last_wfmux_opt sowatch
}

stop_watcher () {
   name=$1
   pid_file=$2

   while read pid ; do
      expr "$pid" : "\($NUM_RE\)$" >/dev/null || {
         wfmux_die "watcher($name): Invalid pid found at '$pid_file'"
      }
      test -d "/proc/$pid" && kill -KILL $pid
   done <"$pid_file"
}

start_watcher () {
   proj_dir=$1
   id=$2
   name=${3:-}
   
   watch_conf="$proj_dir/.wfmux/watch"
   test -s "$watch_conf" || return

   efiles_dir="$proj_dir/.wfmux/efiles"
   mkdir -p "$efiles_dir"

   cmd=''
   wtype=''
   wname=''

   n=0
   dir=false
   efiles=''
   state=watcher

   while read line ; do
      n=$(( $n + 1 ))

      if expr "$line" : '[[:space:]]*$' ; then
         continue
      elif expr "$line" : 'w+,[01],\[[^]:[:space:]]\+\]:.*[:a-zA-Z].*$' ; then

         state=files
         wname="${line##w+,?,[}"
         wname="${wname%%]*}"
         wtype="${line#*,}"
         wtype="${wtype%%,*}"
         cmd="${line#w+,?,\[*\]:}"
         efiles="$efiles_dir/$wname.efiles"

      elif test -n "$name"   \
      &&   test -n "$wname"   \
      &&   test "$name" != "$wname" ; then

         state=watcher
         continue

      elif test $state = files \
      &&   expr "$line" : '\.\($\|/.*\)' ; then

         file=$(say "$line" | sed -e 's/[[:space:]]*$//;s/ /\\ /g')

         IFS=${NL%?}
         for efile in $(eval each "$file") ; do
            test -e "$efile" || wfmux_die "watcher($wname): '$efile' does not exist"
            test -d "$efile" && dir=true
            say "$efile"
         done  >"$efiles"

      elif expr "$line" : 'end$' \
      &&   test $state = files ; then

         state=watcher
         run_watcher "$proj_dir"  \
                     "$id"         \
                     "$wname"       \
                     "$wtype"        \
                     "$cmd"           \
                     "$dir"
      else
         die_conf "('$watch_conf'): Failed to parse config at line $n"
      fi
   done <"$watch_conf"

   if test $state = files ; then
      die_conf "('$watch_conf'): Expected the 'end' token"
   fi
}

run_watcher () {
   sh=$(get_shell)
   requires "$sh"

   proj_dir=$1
   id=$2
   wname=$3
   wtype=$4
   cmd=$5
   dir=$6

   pid_dir="$proj_dir/.wfmux/pids"
   pid_file="$pid_dir/$wname.pid"
   mkdir -p "$pid_dir"

   count_file="$proj_dir/.wfmux/count"
   touch "$count_file"

   cmd='
      c=$(sed -ne "s/^$wname:\([0-9]\|[1-9][0-9]\+\)$/\1/p" "$count_file")
      if test -n "$c" ; then
         c=$(( $c + 1 ))
         sed -i "s/^$wname:[0-9]\+$/$wname:$c/" "$count_file"
      else
         sed -i "/^$wname:/d" "$count_file"
         printf "%s:1\n" "$wname" >"$count_file"
      fi

      tmux set-buffer -b "$wname-$id" "$(printf "\033[34mN_TIMES\033[0m: $c")"
      { '"$cmd"'; } | while read line ; do
         tmux set-buffer -ab "$wname-$id" "$(printf "\n$line")"
      done
   '

   entr_opts='-ns'
   test "$wtype" = 1 && entr_opts="${entr_opts}r"

   efiles="$proj_dir/.wfmux/efiles/$wname.efiles"

   export efiles
   export pid_file
   export entr_opts
   export cmd
   export count_file
   export wname
   export id

   if test "$dir" = true ; then
      entr_opts="${entr_opts}d"
      watch='
        say $$ >"$pid_file"

        while sleep 0.5 ; do
          test -e "$efiles" || test -s "$efiles" || {
            tmux set-buffer -b "$wname-$id" "Unable to locate files, restart the watcher!"
            break
          }

          entr $entr_opts "$cmd" <"$efiles" >/dev/null 2>&1 &
          say $! >>"$pid_file"
          waitpid $!
        done
      '
   else
      watch='
         printf "$$\n" >"$pid_file"
         exec entr $entr_opts "$cmd" <"$efiles"
      '
   fi

   {
      trap '' HUP
      exec $sh -c "$watch"
   } &
}

list_buffers () {
   id=$1
   tmux list-buffers -F '#{buffer_name}' | grep -x "[A-Za-z][-A-Za-z0-9]\+-$id"
}

opt_wfmux_vwatch () {
   tmux_or_die

   session=$(tmux_cur_session)
   proj_dir=$(get_proj_dir "$session")

   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   id=${session##*-}
   buf_list=$(list_buffers "$id")

   test -z "$buf_list" && {
      wfmux_die 'No wfmux buffer for this project was detected'
   }

   buf=$(say "$buf_list" | eval "$MENU") 
   test -z "$buf" && return

   # We could avoid tmux buffers and rely on pipe files which
   # offers a more efficient implementation.
   tmux new-window '
                     val="" pval=""
                     len=0  plen=0
                     while sleep 0.2 ; do
                        val=$(tmux show-buffer -b '"$buf"')
                        len=$(printf "%s\n" "$val" | wc -l)

                        if test "$len" -gt "$plen" ; then
                           pval="$val"
                           printf "%s\n" "$val" | tail -n"$(( $len - $plen ))"
                           plen="$len"
                        fi
                     done
                     read _
                   '
   last_wfmux_opt vwatch
   tmux display-popup -C

   return
}

# Cycle through the stderr & stdout of every running watcher
opt_wfmux_cwatch () {
   tmux_or_die

   session=$(tmux_cur_session)
   proj_dir=$(get_proj_dir "$session")

   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   id=${session##*-}
   buf_list=$(list_buffers "$id")

   test -z "$buf_list" && {
      wfmux_die 'No wfmux buffer for this project was detected'
   }

   tmux new-window '
                     buf_list="'"$buf_list"'"
                     NL=$(printf "\n_")
                     IFS=${NL%?}
                     for buf in $buf_list ; do
                        tmux show-buffer -b "$buf"
                        read _
                     done
                   '

   tmux display-popup -C
   return
}

#  Fetch and print watchers' state.
#
#  NAME: The watcher's name, color: red (disabled), blue (enabled)
#  PID: The watcher's PID.
#  STATE:  + (enabled) / - (disabled)
#  TIME: The number of times the command was ran by the watcher
#
#  NAME   |  PID  | STATE | TIMES | COMMAND
# --------+-------+-------+-------+-----------------
#  test   | 10722 | +     | 10    | make test && ...
#  deploy | 10764 | -     | 4     | make deploy && ...
wtop_fetch_print () {
   watch_conf=$1
   proj_dir=$2
   sense=${3:-}

   old_size=${old_size:-}
   size=$(stty -F /dev/tty size)

   test -z "$sense" && test "$old_size" = "$size" && return

   if test "$old_size" != "$size" ; then
      old_size=$size

      term_h="${size%% *}"
      term_w="${size##* }"

      # Set padding size to 5% of the tty's area
      x=$(( (5 * 100) / $term_w ))
      y=$(( (5 * 100) / $term_h ))

      # Update the size of the tty given the padding size
      term_h=$(( $term_h - (2 * $y) ))
      term_w=$(( $term_w - (2 * $x) ))
   fi

   count_file="$proj_dir/.wfmux/count"

   wname_o=4
   wtype_o=4
   state_o=5
   count_o=5
   pid_o=3
   cmd_o=7

   data=''
   while read line ; do
      expr "$line" : 'w[-+],[01],\[[^]:[:space:]]\+\]:.*[:a-zA-Z].*$' >/dev/null || continue

      _state="${line%%,*}"
      _state="${_state#?}"
      _wtype="${line#*,}"
      _wtype="${_wtype%%,*}"
      _wname="${line##w?,?,[}"
      _wname="${_wname%%]*}"
      _cmd="${line#w?,?,\[*\]:}"

      # Get the number of times the watcher ran the command
      _count=$(sed -ne "s/^$_wname:\([0-9]\|[1-9][0-9]\+\)$/\1/p" "$count_file")
      test -z "$_count" && _count='N/A'

      # Get the PID of the watcher if it's running
      pid_file="$proj_dir/.wfmux/pids/$_wname.pid"
      if test -s "$pid_file" ; then
         read _pid <"$pid_file"
         expr "$_pid" : "\([0-9]\|[1-9][0-9]\+\)$" >/dev/null || _pid='N/A'
      fi

      state="${state:-}${state:+${NL%?}}${_state}"
      wtype="${wtype:-}${wtype:+${NL%?}}${_wtype}"
      wname="${wname:-}${wname:+${NL%?}}${_wname}"
      pid="${pid:-}${pid:+${NL%?}}${_pid}"
      cmd="${cmd:-}${cmd:+${NL%?}}${_cmd}"
      count="${count:-}${count:+${NL%?}}${_count}"

      # Calculate the maximum offset of each field for max alignment
      test "$wname_o" -lt "${#_wname}" && wname_o="${#_wname}"
      test "$count_o" -lt "${#_count}" && count_o="${#_count}"
      test "$pid_o"   -lt "${#_pid}"   && pid_o="${#_pid}"
      test "$cmd_o"   -lt "${#_cmd}"   && cmd_o="${#_cmd}"

   done <"$watch_conf"

   test -z "$wname" && wfmux_die "No watcher was detected!"

   # Build the data, unfortunately we are not using any TUI lib
   data_w=0
   data_h=0

   space='    '
   data=$(
      fmt="${space}%-${wname_o}s | %s | %-${pid_o}s | %s | %-${count_o}s | %-${cmd_o}s"
      printf "$fmt" NAME TYPE PID STATE TIMES COMMAND
   )

   data_w=$(( ${#data} + ${#space} ))

   hori_bar=''
   l=0
   while test $l -ne $data_w ; do
      hori_bar="${hori_bar}_"
      l=$(( $l + 1 ))
   done

   data="${data}${NL%?}${hori_bar}"

   for l in $(seq "$(say "$wname" | wc -l)") ; do

      _state=$(say "$state" | sed -ne "${l}p")
      _wtype=$(say "$wtype" | sed -ne "${l}p")
      _wname=$(say "$wname" | sed -ne "${l}p")
      _count=$(say "$count" | sed -ne "${l}p")
      _pid=$(  say "$pid"   | sed -ne "${l}p")
      _cmd=$(  say "$cmd"   | sed -ne "${l}p")

      line=$(
         fmt="${space}%-${wname_o}s | %-${wtype_o}s | %-${pid_o}s | %-${state_o}s | %-${count_o}s | %-${cmd_o}s"

         printf "$fmt"     \
                "$_wname"   \
                "$_wtype"    \
                "$_pid"       \
                "$_state"      \
                "$_count"       \
                "$_cmd"
      )

      data="${data}${data:+${NL%?}}${line}${NL%?}${hori_bar}"
   done

   data_h=$(say "$data" | wc -l)

   data_x="${data_x:-1}"
   data_y="${data_y:-1}"

   # Possible senses: (T)OP, (D)OWN, (R)IGHT, and (L)EFT
   if test "$sense" = T && test "$term_h" -lt "$data_h" ; then
      data_y=$(( $data_y - 1 ))
      test "$data_y" -lt 0 && data_y=0

   elif test "$sense" = D && test "$term_h" -lt "$data_h" ; then
      test $(( $data_y - 1 )) -ne $(( $data_h - $term_h )) && data_y=$(( $data_y + 1 ))

   elif test "$sense" = L && test "$term_w" -lt "$data_w" ; then
      data_x=$(( $data_x - 1 ))
      test "$data_x" -lt 0 && data_x=0

   elif test "$sense" = R && test "$term_w" -lt "$data_w" ; then
      data_x=$(( $data_x + 1 ))
      test "$data_x" -gt "$data_w" && data_x="$data_w"
   fi

   # Now print the data!
   l=1
   say "$data" | while read line ; do
      test $l -lt "$data_y" && continue
      test $l -gt "$term_h" && break

      # Start from $data_x up til at most $term_w
      line=$(say "$line" | sed -e "s/^.\{$(( $data_x - 1 ))\}\(.+\)/\1/;s/^\(.\{,$term_w\}\).+/\1/")
      tty_print $x $y "$line"

      y=$(( $y + 1 ))
      l=$(( $l + 1 ))
   done
}

opt_wfmux_wtop () {
   tmux_or_die

   proj_dir=$(get_proj_dir "$(tmux_cur_session)")
   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   watch_conf="$proj_dir/.wfmux/watch"

   init_stty=$(stty -F /dev/tty -g)
   stty -F /dev/tty -cooked -echo min 0 >/dev/null 2>&1

   printf "${ESC_ALT_SCREEN}${ESC_HIDE_CUR}${ESC_CLEAR_SCREEN}"

   ctrl_z="$(printf '\32')"
   escape="$(printf '\33')"
   while true ; do
      stty -F /dev/tty time 10 >/dev/null 2>&1
      key=$(dd if=/dev/tty count=1 bs=1 2>/dev/null)

      if test -z "$key" ; then
         wtop_fetch_print "$watch_conf" "$proj_dir" "$key"
         break
      fi

      if test "$key" = 'q' || test "$key" = "$ctrl_z" ; then
         break
      elif test "$key" = "$escape" ; then
         stty -F /dev/tty time 0 >/dev/null 2>&1
         key=$(dd if=/dev/tty count=3 bs=1 2>/dev/null)
         case "$key" in
            '[A'*|'OA'*) key='U' ;;
            '[B'*|'OB'*) key='D' ;;
            '[D'*|'OD'*) key='L' ;;
            '[C'*|'OC'*) key='R' ;;
            *)           key=''  ;;
         esac
      fi

      stty -F /dev/tty time 0 min 0 >/dev/null 2>&1
      dd if=/dev/tty bs=512 count=1 >/dev/null 2>&1

      wtop_fetch_print "$watch_conf" "$proj_dir" "$key"
   done

   #printf "${ESC_NORMAL_SCREEN}${ESC_SHOW_CUR}${ESC_UNSET_ANSI}"
   stty "$init_stty"
   last_wfmux_opt wtop
}

opt_wfmux_last () {
   tmux_or_die

   proj_dir=$(get_proj_dir "$(tmux_cur_session)")
   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   last_file="$proj_dir/.wfmux/last"
   test -s "$last_file" || wfmux_die 'Unknown last wfmux operation'

   read opt <"$last_file"
   opt="opt_wfmux_$opt"

   cmd_val=$(command -v "$opt")
   if test -z "$cmd_val" ; then
      tmux_message "$opt: undefined wfmux operation"
   elif test "$cmd_val" != "$opt" ; then
      tmux_message "$opt: wfmux operation should be a function!"
   else
      eval "$opt"
   fi
}

add_plug () {
   name=${1:-}
   test -z "$name" && return

   say "$WFMUX_OPS" | grep -xqF "$name" || {
      tmux_message "Another plugin has this name."
      return
   }

   WFMUX_OPS="${WFMUX_OPS}${NL%?}$name"
}

wfmux_load_plugins () {
   test -d "$WFMUX_PLUG_DIR" || return
   test -r "$WFMUX_PLUG_DIR" || {
      tmux_message "No read permission for '$WFMUX_PLUG_DIR'"
      return 0
   }

   for plug in "$WFMUX_PLUG_DIR"/*.wfmux.sh ; do
      . "$plug" || {
         tmux_message "load_plug('$plug') has a non-zero exit status"
         return 1
      }
   done
}

opt_wfmux_ops () {
   tmux_or_die

   wfmux_load_plugins || return

   opt=$(say "$WFMUX_OPS" | grep -xEv 'new|ops' | eval "$MENU")
   test -z "$opt" && return

   func="opt_wfmux_$opt"

   cmd_val=$(command -v "$func")
   if test -z "$cmd_val" ; then
      tmux_message "$func: undefined wfmux operation"
   elif test "$cmd_val" != "$func" ; then
      tmux_message "$func: wfmux operation should be a function!"
   else
      eval "$func"
   fi
}

main "$@"
