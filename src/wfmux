#!/bin/sh

#set -x
set -ue

readonly alt_screen='\033[?1049h'
readonly normal_screen='\033[?1049l'
readonly hide_cur='\033[?25l'
readonly show_cur='\033[?25h'
readonly clear_screen='\033[2J'
readonly bold='\033[1m'
readonly unset_ansi='\033[0m'
readonly program=${0##*/}
readonly config_dir="${XDG_CONFIG_HOME:-"$HOME/.config"}"
readonly wfmux_config_dir="${config_dir%%/}/wfmux/"
readonly cache_dir="${XDG_CACHE_HOME:-"$HOME/.cache"}"
readonly cache="${cache_dir%%/}/wfmux"
readonly cache_pl="${cache_dir}/wfmux.pl"
readonly session_dir="${cache_dir%%/}/wfmux/sessions"
readonly tmux_conf="$HOME/.tmux.conf"

mkdir -p "$config_dir" "$cache_dir" "$cache" "$session_dir" "$wfmux_config_dir"

readonly logo_ls=$(cat <<EOF
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx┌────────────
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx┌───────
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxxxxxxxxxxxxxxx┌───┐xxxxxxxxxx│
xxxxxxxxxxxx┌──┐xxxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxxxxxxxxxxxxxxx│xxx│xxxxxxxxxx│
xxxxxxxxxxxx│xx│xxxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxxxxxxxxxxxxxxx│xxx│xxxxxxxxxx│
xxxxxxxxxxxx│xx│xxxxxxxxxxx┌────┼─────┬─────┬──────┬──┐xxxxxxx│xxx│xxxx┌─────┘
xxxxxxxxxxxx│xx│xxxxx┌─xxxx│xxxx│xxxxx│xxxxx│xxxxxx│xx│xxxxxxx│xxx│xxxx│
────────────┘xx│xxxxx│xxxxx│xxxx│xxxxx│xxxxx│xxxxxx│xx│xxxxxxx│xxx└────┼─────┐
xxxxxxxxxxxxxxx│xxxxx│xxxxx│xxxx│xxxxx│xxxxx│xxxxxx│xx│xxxxxxx│xxxxxxxx│xxxxx│
xxxxxxxxxxxxxxx│xxxxx│xxxxx│xxxx│xxxxx│xxxxx└────xx│xx└───────┘xxxxxxxx│xxxxx│
xxxxxxxxxxxxxxx├─────┴─────┘xxxx│xxxxx│xxxxxxxxxxxx└──xxxxxxxxxxxxxxxxx│xxxxx│
xxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxx│xxxx─┘xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│xxxxx│
xxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxx│xxxxxxxxxxxx──────────────────────────┘xxxxx│
xxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxx└─xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│
xxxxxxxxx──────┘xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│
EOF
)
readonly logo_ms=$(cat <<EOF
xxxxxxxxxxxxxxxxxxxxx┌─────xxxxxxxxxxxxxxxxxxxxxxxxxxx┌───
xxxxxxxxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│
xxxxxxxx┌─┐xxxxxxxxxx│xxxxxxxxxxxxxxxxxxxxxx┌──┐xxxxxx│
xxxxxxxx│x│xxxxxxx┌──┼───┬───┬───┬────┐xxxxx│xx│xx┌───┘
xxxxxxxx│x│xxx┌─xx│xx│xxx│xxx│xxx│xxxx│xxxxx│xx│xx│
────────┘x│xxx│xxx│xx│xxx│xxx│xxx│xxxx│xxxxx│xx└──┼───┐
xxxxxxxxxx│xxx│xxx│xx│xxx│xxx│xxx│xxxx│xxxxx│xxxxx│xxx│
xxxxxxxxxx├───┴───┘xx│xx─┘xxx└─xx│xxxx└─────┘xxxxx│xxx│
xxxxxxxxxx│xxxxxxxxxx└─xxxxxxxxxx└──xxxxxxxxxxxxxx│xxx│
xxxxxxxxxx│xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx─────────┘xxx│
xxxxxxx───┘xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│
EOF
)
readonly logo_ss='WFMUX'

readonly wfmux=$(cat<<EOF

     ┌──────────────┤ WFMUX
    ┌┴─────────────────────────────────────────────────┐
    │                                                  │
    ├───── Input a name for a new tmux session         │
    │                                                  │
    ├───── Input f⟨return⟩ to select a project         │
    │                                                  │
    ├───── Input ⟨return⟩ to drop to the terminal      │
    │                                                  │
    └──────────────────────────────────────────────────┘
EOF
)

username=username
tok=tok
gitlab_tok_name=gitlab_token_name
wfmux_config="${config_dir%%/}/wfmux/wfmux.conf"
use_xdg=yes
runner=entr
runner_templates="$HOME/.config/wfmux/rtemplate"
dash_color=4
explorer=nnn
ignore=.git
searcher='fzf --multi --border=bottom --margin=25%'
searcher_open='fzf --multi --border=bottom --margin=25%'
window_attributes_rest=20x20+10+20
window_attributes_file_selector=20x20+10+20
window_attributes_input_box=20x20+10+20
tbind_ops==
tbind_explore=BSpace
tbind_select=Enter

project_directory=$(cat <<-EOF
	$HOME/projects
	$HOME/aprojects
	$HOME/oprojects
	EOF
)

programs=$(cat <<-EOF
	pdf:      zathura
	text:     nvim
	video:    ffmpeg
	audio:    aplay
	image:    feh
	database: program_name
	EOF
)

usage() {
	cat <<EOF
Build an awesome dev workflow with tmux, fzf, nnn, and entr.
usage: wfmux [ [-c|-config|--config] *config_file* ] *operation_name*
       wfmux [ -h | -help | --help ]

Options:
     -h, -help, --help             print this help message.
     -c, -config, --config *FILE*  load *FILE* configuration file.

Operation names:
    open         fuzzyly select a project and open a new tmux session.
    watch        set commands to run when files change.
    view         fancy view of any existing running project watcher.
    explore      open your favorite file manager on a popup tmux pane.
    select       fuzzyly select a file to open provided that they exist
                 a recently used tmux session which carries the name of your
                 project.   
    commit       add to the index and commit changes to local repository.
    acommit      replace the tip of the current branch by creating a new commit
    push         push to the remote repositories.
    fpush        force-push to the remote repositories.
    switch       fuzzyly switch between branches of your local repository.
    dump         dump wfmux's tmux configuration to stdout.
    tmux         update wfmux's tmux configuration at ~/.tmux.conf.
    ops          a wrapper to the above operations.
    ssession     switch between project sessions
EOF
	exit $1
}

die() {
	printf "$*\n" >&2
	exit 1
}

func_main() {
	local operation=
	local gave_config=false

	[ $# -eq 0 ] && usage 1
	until [ $# -eq 0 ]
	do
		case "$1" in
		-h | -help | --help)
			usage 0 ;;
		-c | -config | --config)
			[ $# -eq 1 ] && wfmux_config=$2 || usage 1
			gave_config=true
			shift ;;
		push    | \
		fpush   | \
		commit  | \
		acommit | \
		select  | \
		explore | \
		open    | \
		tmux    | \
		dump    | \
		ops     | \
		view    | \
		watch   | \
		switch  | \
		sswitch)
			operation=$1
			if [ -f "$wfmux_config" ]
			then
				[ -r "$wfmux_config" ] || die "no permission to read '$wfmux_config'"
				. $wfmux_config        || die "could not source configuration file"
			fi ;;
		*)
			die "'$1' is an unrecognized option, please try \`$program --help'" ;;
		esac
		shift
	done

	if [ $gave_config = true ]
	then
		check_config_variables
	else
		# use default config "~/.config/wfmux.conf" is possible
		if [ -f "$wfmux_config" -a -r "$wfmux_config" ]
		then
			check_config_variables
		fi
	fi

	eval "func_$operation"
}

## Check if variables are unset or null	and if set then
## check if the data is somehow our expectation.
## we won't have to rely on `set -u`, we would want to output a custom 
## error message if one of these variables aren't set/sane.
check_config_variables() {
	_error="$program: ('$wfmux_config'):"
	for para in \
		         use_xdg \
		         runner \
		         searcher \
		         explorer \
		         window_attributes_rest \
		         window_attributes_input_box \
		         window_attributes_file_selector \
		         project_directory \
		         tbind_ops \
		         tbind_select \
		         tbind_explore
	do
		eval "para=\${$para:-UNSET}"
		if [ "$para" = UNSET ]
		then
			die "$_error '$para' isn't set"
		fi
	done

	_config_die() {
		die "$_error invalid value assigned to '$1'"
	}

	## Check if we got sane values
	{
		window_regex='[[:digit:]]\+x[[:digit:]]\++[[:digit:]]\++[[:digit:]]\+$'
		expr "$window_attributes_rest"          : "$window_regex" || _config_die window_attributes_rest
		expr "$window_attributes_file_selector" : "$window_regex" || _config_die window_attributes_file_selector
		expr "$window_attributes_input_box"     : "$window_regex" || _config_die window_attributes_input_box
		expr "$use_xdg"                         : 'true\|false$'  || _config_die use_xdg
		expr "$dash_color"                      : '[0-9]$'        || _config_die dash_color
	} >/dev/null

	for i in explorer runner searcher
	do
		eval "command -v" "\${$i} >/dev/null"
		test $? -ne 0 && die "$_error '$i' not found"
	done

	# IFS=$'\n' won't expand '\n' on dash shell
	printf "$project_directory" |
	while read i
	do
		test -d "$i" || die "$_error '$i' is not a directory"
		test -r "$i" || die "$_error cannot list content of '$i'"
	done
}

display_dashboard() {
	local term_h=
	local term_w=
	local put_color="\033[3${dash_color:-9}m"
	local max="awk 'BEGIN{len = 0}; {nlen = length(\$0); if (nlen > len) len = nlen;}; END{print len}'"

	# generate help message for the dashboard
	_gen_key_helper() {
		cat <<-EOF
			The following are tmux bindings related to WFMUX.

			M-$tbind_select: fuzzyly open project files
			M-$tbind_explore: open file manager
			M-$tbind_ops: fuzzyly select other wfmux operations

			input any key to exit dashboard
		EOF
	}

	_print() {
		printf "\033[$1;$2f$3" >/dev/tty
	}

	# save initial terminal setting and will set it back after exiting dashboard
	init_stty="$(stty -g)"
	stty -cooked -echo time 0 min 1
	printf "${alt_screen}${hide_cur}${clear_screen}"

	(
		while true; do
			if [ "$(stty -F /dev/tty size)" = "$term_h $term_w" ]
			then
				sleep 2
				continue
			fi
			term_h="$(stty -F /dev/tty size | cut -d' ' -f1)"
			term_w="$(stty -F /dev/tty size | cut -d' ' -f2)"
			if   [ $term_h -lt 32 -o $term_w -lt 97  ]
			then
				_size=ss
			elif [ $term_h -lt 43 -o $term_w -lt 155 ]
			then
				_size=ms
			else
				_size=ls
			fi
			eval 'logo_h=$(printf "$logo_'$_size'" | wc -l);
				  logo_w=$(printf "$logo_'$_size'" | eval "$max")'

			logo_h="$(expr $logo_h + `_gen_key_helper | wc -l`)"
			gen_w="$(_gen_key_helper | eval "$max")"
			x="$(expr $term_w / 2 - $logo_w / 2)"
			y="$(expr $term_h / 2 - $logo_h / 2)"
			if [ $gen_w -gt $logo_w ]
			then
				gen_x="$(expr $x - \( $gen_w  - $logo_w \) / 2)"
			else
				gen_x="$(expr $x + \( $logo_w - $gen_w  \) / 2)"
			fi

			printf "${clear_screen}${put_color}${bold}"
			eval 'printf "$logo_'$_size'"' | {
				while read i
				do
					_print $y $x "$(printf "$i" | tr 'x' ' ')"
					y="$(($y+1))"
				done

				printf "$unset_ansi"
				_gen_key_helper | while read i
				do
					y="$(($y+1))"
					_print "$y" "$gen_x" "$i"
				done
			}
		done
	) &

	# get key from standard input
	dd if=/dev/tty count=1 bs=1 >/dev/null 2>&1
	kill -9 $! || : ## CAUTION: script would exit if set -e
	stty "$init_stty"
	printf "${unset_ansi}${show_cur}"
	tput clear
}

## select a project and open a tmux session
## refer to usage() function for more information
func_open() {
	local session_name input

	if tmux list-sessions >/dev/null 2>&1
	then
		printf "Choose an existing session to attach\n\n"
		tmux list-sessions | awk '{print "["NR"] "$0}'
	fi
	printf "$wfmux\n"
	read -p '⟩⟩ ' input
	tput clear

	if [ -n "$(expr "$input" : '\([0-9][0-9]*\)$')" ]
	then
		session_name="$(tmux list-sessions -F '#S' | sed -n "${input}p")"
		if [ -n "$session_name" ]
		then
			tmux attach-session -t "$session_name"
		fi
	else
		if [ -n "$(expr "$input" : '\(F\|f\)$')" ]
		then
			local project_list mcount

			locate_git_repos() {
				find "$1" -mindepth 2 -type d -iname '.git' -exec expr '{}' : '\(.*\)/.git$' \;
			}

			# TODO: cache search results
			project_list="$(printf "$project_directory\n" | while read pdir; do locate_git_repos "$pdir"; done | tee "$cache_pl")"

			project_name="$(printf "$project_list" | sed -nE 's,^.*/(.*)$,\1,p' | awk '{print "["NR"]:"$0}' | eval "$searcher_open")"
			test -z "$project_name" && return

			project_dir="$(printf "$project_list" | sed -n "$(expr "$project_name" : '\[\([0-9]\+\)\]:.*$')p")"
			session_name=`mktemp -u pr-XXXXXX`

			# Check if session already exist
			for i in "$session_dir"/*
			do
				local path="$i/path"
				if [ -f "$path" ]
				then
					if [ `cat "$path"` = "$project_dir" ]
					then
						session_name=`basename "$i"`
					fi
				fi
			done

			# Start session with all its watchers
			{
				if ! tmux has-session -t "$session_name"
				then
					display_dashboard
					_setup_session "$project_dir" "$session_name"&
					tmux new-session -s "$session_name"
				else
					# Assume the watchers have already been started and attach the session to the controlling terminal
					tmux attach-session -t "$session_name"
				fi
			} 2>/dev/null

		elif [ -z "$input" ]
		then
			return 0
		else
			tmux new-session -s "$(printf "$input")"
		fi
	fi
}

_setup_session() {
	local project_dir="$1"
	local project_session="$session_dir/$2"

	mkdir -p "$project_session"
	printf "$project_dir" >"$project_session/path"

	local watch_config="$project_session/watch"
	if [ -f "$watch_config" ]
	then
		local fifo
		for i in `cat "$watch_config" | sed -ne 's/^s:\[\(.*\)\].*/\1/p'`
		do
			# You would be seeing results of watchers via named-pipes
			fifo="$project_session/${i}_fifo"
			test -p "$fifo" || mkfifo "$fifo"
			#wxwatch "$runner" "$i" "$watch_config" >"$fifo" &
		done
	fi
}

__set_whxy() {
	local window_attributes="$1"

	y="$(printf "$window_attributes" | sed -e 's/^.*+\([0-9]\+\)$/\1/')"
	x="$(printf "$window_attributes" | sed -e 's/^.*+\([0-9]\+\)+.*/\1/')"
	w="$(printf "$window_attributes" | sed -e 's/^\([0-9]\+\)x.*/\1/')"
	h="$(printf "$window_attributes" | sed -e 's/^.*x\([0-9]\+\).*/\1/')"
}

_dump() {

	__set_whxy $window_attributes_file_selector
	cat <<EOTX
unbind M-$tbind_select
bind M-$tbind_select if-shell "command -v wfmux" { display-popup -w $w -h $h -x $x -y $y -E "wfmux select"; }
EOTX

	__set_whxy $window_attributes_rest
	cat <<EOTX
unbind M-$tbind_explore
bind M-$tbind_explore if-shell "command -v wfmux" { display-popup -w $w -h $h -x $x -y $y -E "wfmux explore"; }
unbind M-$tbind_ops
bind M-$tbind_ops if-shell "command -v wfmux" { display-popup -w $w -h $h -x $x -y $y -E "wfmux ops"; }
EOTX

}

func_dump() { _dump; }
func_tmux() { _dump >> "$tmux_conf"; }

_get_project_dir() {
	local session_name="$(tmux list-sessions -F '#S:#{session_activity}' | sort -b -t: -k 2,2n | tail -n1 | cut -d: -f1)"
	local session="$session_dir/$session_name"

	if [ -d "$session" ]
	then
		local project_dir=`cat "$session/path"`
		test -d "$project_dir" && printf "$project_dir"
	fi
}

func_sswitch() {
	local session_pbase=$(tmux list-sessions -F '#S' | while read sname; do 
		session="$session_dir/$sname"
		if [ -d "$session" ]; then
			local project_dir=`cat "$session/path"`

			if [ -d "$project_dir" ]; then
				project_dir="$(printf "%s\n" "$project_dir" | sed -e 's,.*/\([^/]*/[^/]*\),\1,')"
				printf "%s\n" "$sname:$project_dir"
			fi
		fi
	done)
	local pbasename="$(printf "$session_pbase" | cut -d: -f2 | eval "$searcher")"

	if [ -n "$pbasename" ]
	then
		local session_name="$(tmux list-sessions -F '#S:#{session_activity}' | sort -b -t: -k 2,2n | tail -n1 | cut -d: -f1)"
		local pty="$(tmux list-clients -F '#S:#{client_tty}' | grep -F "$session_name:" | cut -d: -f2)"

		# CAUTION: This is not a BUG!!! (note the head -n1)
		# The differenciation level for every projects are the names of their parent directories only, not uptil the OS's root directory.
		tmux switch-client -c "$pty" -t "$(printf "$session_pbase" | sed -ne "s,\(.*\):$pbasename,\1,p" | head -n1)"
	fi
}

## open your favorite tui file manager
func_explore() {
	local project_dir=`_get_project_dir`
	eval "$explorer" "$project_dir"
}

## select project files to open
func_select() {
	local file torun
	local new_window=true
	local sh=${SHELL##*/}
	local project_dir=`_get_project_dir`

	test -d "$project_dir" || return

	file=$(
		args="$(printf "$ignore" | sed -e '${ s/\(.*\)/-name "\1"/; q; }; 1,${ s/\(.*\)/-name "\1" -or /; }' | tr '\n' ' ')"
		eval "find '$project_dir' \( $args \) -prune -or -type f -print | sed -e 's,^$project_dir/,,' | $searcher"
	)

	test -n "$file" || return
	file="$project_dir/$file"

	_open_file_command() {

		if [ x"$use_xdg" != xtrue ]
		then
			local mime
			local mime_type="$(xdg-mime query filetype "$file")"

			if [ $? = 0 ] && [ -n "$mime_type" ]
			then

				# The right program to open files of type 'application' can partly be determined
				# with the aid of its subtype, like for example application/json, application/pdf, etc.
				# therefore $mime should be the file's subtype in case the we have 'application' as mime
				# type otherwise its type is the best option.
				test "${mime_type%/*}" = application && mime="${mime_type#*/}" || mime="${mime_type%/*}"

				local opener="$(printf "$programs" | sed -ne "s/^$mime:[[:space:]]*\([^[:space:]]*\)/\1/p")"
				opener="${opener:-$EDITOR}"
				opener="${opener:-vim}"

				{ 
					which "$opener" 1>&2
					if [ $? -eq 0 ]  
					then
						# Put in list of all TUI applications that takes a $file as argument
						if printf "$opener" | grep -qE '^vim|ranger|cmus|nvim|nnn|kak$'
						then
							printf "$opener '$file'"
						else
							{ trap '' HUP; eval "$opener '$file'"; } &
							tmux display-popup -C
						fi
					fi
				} 2>/dev/null
			fi
		else
			printf "xdg-open '$file'"
		fi
	}

	local torun=`_open_file_command`
	if [ -n "$torun" ]
	then
		for wid in $(tmux list-window -F '#{window_activity}:#I' | sort -r -t: -k 1,1n | cut -d: -f2 | tac)
		do
			local panes="$(tmux list-panes -t $wid -F '#{pane_current_command}:#P:#{pane_active}')"
			local bash_panes="$(printf "$panes" | grep "^${sh:-bash}:")"

			if [ -n "$bash_panes" ]
			then
				# is it an idle active pane?
				local bash_id="$(printf "$bash_panes" | sed -nE 's/.*:([0-9]+):1$/\1/p')"
				if [ -z "$bash_id" ]
				then
					# take the most recently opened idle pane
					bash_id="$(printf "$bash_panes" | sort -t: -k 2,2n | head -n1 | cut -d: -f2)"
				fi

				tmux send-keys -t "$wid.$bash_id" "$torun" C-m
				if [ $? -eq 0 ]; then new_window=false; break; fi
			else
				if [ `printf '%s\n' "$panes" | wc -l` -eq 1 ]
				then
					tmux select-window -t "$wid"
					tmux split-window -h "$torun"
					if [ $? -eq 0 ]; then new_window=false; break; fi
				fi
			fi
		done

		test $new_window = true && tmux new-window "$(_open_file)"
	fi
}

func_commit() {
	__commit
}

func_acommit() {
	__commit true
}

__commit() {
	local editor="$(printf "$programs" | sed -ne 's/^[ \t]*text:[ \t]\+\(\w*\)$/\1/p')"

	editor="${editor:-$EDITOR}"
	editor="${editor:-vim}"

	{ command -v git       || return
	  command -v "$editor" || return
	} >/dev/null

	local project_dir=`_get_project_dir`

	if [ -n "$project_dir" ]
	then
		cd "$project_dir"
		if [ $? = 0 ]
		then
			local amend="${1:-false}"

			git add .
			if [ "$amend" = false ]
			then
				local tempfile=`mktemp /tmp/.git_XXXXXX`

				$editor "$tempfile"
				# Let git abord if we did not commit with a commit message
				# than trying to introduce a `du'-like command
				git commit --message "$(cat "$tempfile")"
				rm -f "$tempfile"
			else
				git commit --amend
			fi
		fi
	fi
}

func_switch() {
	command -v git >/dev/null|| return

	local project_dir=`_get_project_dir`

	cd "$project_dir"
	if [ $? = 0 ]
	then
		local branch="$(git branch | sed -e 's/^\*//' | eval "$seacher")"

		if [ -n "$branch" ]
		then
			# Check if he/she commited before checking out
			test `git status | wc -l` -eq 2 && git checkout "$branch"
		fi
	fi
}

func_push() {
	__push
}

func_fpush() {
	__push --force
}

__push() {
	{ command -v git    || return
	  command -v "$tok" || return
	} >/dev/null

	local project_dir=`_get_project_dir`
	test -n "$project_dir" && project_name="$(basename "$project_dir")"

	if [ -n "$project_name" ]
	then
		cd "$project_dir"
		if [ $? -eq 0 ]
		then
			local remote="$(printf "$remote" | eval "$searcher")"

			if [ -n "$remote" ]; then
				local proto=https
				local branch="$(git branch | sed -ne 's,^* \(.*\),\1,p')"
				local tok="$(eval "$tok '${remote%%.*}'")"
				local force=${1:---force}

				case $remote in
					codeberg.org | github.com | github.com) proto=https ;;
					*) proto=https ;;
				esac
				if [ "$remote" = "gitlab.org" ]
				then
					tok="$gitlab_tok_name:$tok"
				fi

				git push "$force" --set-upstream "$proto://$tok@$remote/$username/$project_name.git" "$branch"
			fi
		fi
	fi
}

# set up watchers
func_watch() {
	:;
}

# fancy view of the watchers
func_view() {
	:;
}

# Wrap all operations, plugins appear here
func_ops() {

	_load_plugins() {
		:;
	}

	[ -z `_get_project_dir` ] && return

	local ops=$(
	    printf "commit
acommit
switch
runner
explore
select
sswitch
fpush
push" | eval "$searcher")

	test -n "$ops" && {
		trap '' HUP

		case $ops in
			select)
				__set_whxy $window_attributes_file_selector ;;
			commit  | \
			acommit | \
			runner  | \
			switch  | \
			explore | \
			push    | \
			fpush   | \
			watch   | \
			view    | \
			ssession)
				__set_whxy $window_attributes_rest ;;
		esac

		tmux display-popup -w $w -h $h -x $x -y $y -E "/home/kueppo/projects/wfmux/src/wfmux $ops"
		#tmux display-popup -w $w -h $h -x $x -y $y -E "wfmux $ops"
	} &

	tmux display-popup -C
}

func_main "$@"
