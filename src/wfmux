#!/bin/dash

#set -x
set -u

readonly ESC_ALT_SCREEN='\033[?1049h'
readonly ESC_NORMAL_SCREEN='\033[?1049l'
readonly ESC_HIDE_CUR='\033[?25l'
readonly ESC_SHOW_CUR='\033[?25h'
readonly ESC_CLEAR_SCREEN='\033[2J'
readonly ESC_BOLD='\033[1m'
readonly ESC_UNDERLINE='\033[4m'
readonly ESC_RED='\033[31m'
readonly ESC_UNSET_ANSI='\033[0m'

readonly CONFIG_DIR="${XDG_CONFIG_HOME:-"$HOME/.config"}"
readonly WFMUX_CONF_DIR="${CONFIG_DIR%%/}/wfmux"
readonly WFMUX_PLUG_DIR="$WFMUX_CONF_DIR/plugins"
readonly TMUX_CONF="$HOME/.tmux.conf"

# Shell running command from `tmux display-pop' does not seem 
# to have sourced profiles.
readonly LOCAL_BIN="$HOME/.local/bin"

# Some watcher commands frequently used in some projects.
readonly WATCHER_TEMPLATES="$WFMUX_CONF_DIR/watchers"

readonly NL="$(printf '\n_')"
readonly NUM_RE='[0-9]\|[1-9][0-9]\+'

mkdir -p "$CONFIG_DIR" "$WFMUX_CONF_DIR"

# Large size
readonly WFMUX_LS="$(cat <<END
                                ┌────────────
                                │
                                │                                            ┌───────
                                │                             ┌───┐          │
            ┌──┐                │                             │   │          │
            │  │                │                             │   │          │
            │  │           ┌────┼─────┬─────┬──────┬──┐       │   │    ┌─────┘
            │  │     ┌─    │    │     │     │      │  │       │   │    │
────────────┘  │     │     │    │     │     │      │  │       │   └────┼─────┐
               │     │     │    │     │     │      │  │       │        │     │
               │     │     │    │     │     └────  │  └───────┘        │     │
               ├─────┴─────┘    │     │            └──                 │     │
               │                │    ─┘                                │     │
               │                │            ──────────────────────────┘     │
               │                └─                                           │
         ──────┘                                                             │
                                                                             │
END
)"

# Medium size
readonly WFMUX_MS=$(cat <<END
                     ┌─────────                      ┌───
                     │                               │
        ┌─┐          │                     ┌──┐      │
        │ │       ┌──┼───┬───┬───┬───┐     │  │  ┌───┘
        │ │   ┌─  │  │   │   │   │   │     │  │  │
────────┘ │   │   │  │   │   │   │   │     │  └──┼───┐
          │   │   │  │   │   └─  │   │     │     │   │
          ├───┴───┘  │  ─┘       │   └─────┘     │   │
          │          └─          └──             │   │
          │                  ────────────────────┘   │
     ─────┘                                          │
                                                     │
END
)

# Small size
readonly WFMUX_SS='WFMUX'

readonly WFMUX="$(cat<<END

     ┌──────────────┤ WFMUX
    ┌┴────────────────────────────────────────┐
    │                                         │
    ├─ Input a name for a new tmux session    │
    ├─ Input f⟨return⟩ to select a project    │
    ├─ Input ⟨return⟩ to drop to the terminal │
    │                                         │
    └─────────────────────────────────────────┘
END
)"

WFMUX_CONF="$WFMUX_CONF_DIR/wfmux.conf"
WFMUX_OPS="$(cat <<END
new
tmux
dump
open
explore
shell
nsession
switch
log
commit
acommit
push
fpush
checkout
fcheckout
cbranch
view
awatch
rwatch
mwatch
ewatch
dwatch
sawatch
sowatch
ops
END
)"

# Default configuration if external config file does not exist
COLOR=4
SUCCESS="\033[1;3${COLOR}m"

WATCHER='entr'
FILE_MANAGER='lf'

WIN_ATT_OPT='20x20+10+20'

TBIND_OPEN='Enter'
TBIND_EXPLORE='BSpace'
TBIND_OPS='i'
TBIND_SWITCH='w'

MENU='fzf --multi --margin=25%'

PROJ_DIRS="$(cat <<END
$HOME/projects
$HOME/oprojects
END
)"

USE_XDG_OPEN=false

PROGRAMS="$(cat <<END
tty=true,text=vim '%s'
tty=true,directory=lf '%s'
tty=false,video=ffplay -hide_banner -loop 0 '%s'
tty=true,audio=ffplay  -hide_banner -loop 0 -nodisp '%s'
tty=false,pdf=zathura '%s'
tty=false,image=feh '%s'
END
)"

usage () {
   cat <<END
Build an awesome dev workflow using tmux, fzf, lf, entr and more.

Usage: wfmux [ -h | --help ]
       wfmux [ ( -c | --conf ) CONF ] OPT_NAME
       
Options:
     -h, --help         print this help message.
     -c, --conf CONF    load CONF configuration file.

OPT_NAME:
    new          Select a project and open its new wfmux tmux session.
    nsession     Create a new wfmux tmux session of a project while in a
                 tmux session.
    switch       Switch between wfmux tmux sessions
    explore      Open file manager to a project directory on a popup pane.
    open         Select a file to open provided that they exist ...
    commit       add to the index and commit changes to local repository.
    acommit      replace the tip of the current branch by creating a new commit
    checkout     fuzzyly switch between branches of your local repository.
    fcheckout
    push         push to the remote repositories.
    fpush        force-push to the remote repositories.
    dump         dump wfmux's tmux configuration to stdout.
    tmux         update wfmux's tmux configuration at ~/.tmux.conf.
    ops          a wrapper to the above operations.
    dwatcher     disable a watcher from the watcher list
    ewatcher     enable a watcher from the watcher list
    awatcher     Add a new watcher to a project's watcher list.
    rwatcher     Remove a new watcher to a project's watcher list.
    view         Fancy view of the concerned running project watcher.

END
   exit $1
}

die () {
   say "$0: $*." >&2
   exit 1
}

main () {
   opt_name=

   test $# -eq 0 && usage 1
   while test $# -ne 0 ; do
      case $1 in
      -h|--help)
         usage 0
         ;;
      -c|--conf)
         test $# -gt 2 || usage 1
         test -e "$2"  || die "Conf file '$2' does not exist"
         WFMUX_CONF=$2
         shift
         ;;
      -*)
         die "Unknown option '$1', please try \`$0 --help'"
         ;;
      *)
         test -n "$opt_name" && usage 1
         say "$WFMUX_OPS" | grep -xqF "$1"

         test $? -ne 0 && {
            e_msg="'$1' is an unknown wfmux operation"
            test -n "${TMUX:-}" && tmux_message "$e_msg"
            die "$e_msg"
         }
         opt_name=$1
         ;;
      esac
      shift
   done

   test -f "$WFMUX_CONF" && {
      test -r "$WFMUX_CONF" || die "No permission to read '$WFMUX_CONF'"
      . "$WFMUX_CONF"       || die "Non-zero exit status when sourcing config"
   }

   check_conf_vars
   eval "opt_wfmux_$opt_name"
}

die_conf () {
   test -z "${TMUX:-}"                   \
      && die "('$WFMUX_CONF'): $*"        \
      || wfmux_die "('$WFMUX_CONF'): $*."
}

check_conf_vars () {
   var=''
   is_set=''

   v_err () {
      die_conf "Invalid value assigned to '$1'"
   }

   # Check it all here though they aren't all used in a single wfmux opt
   for var in USE_XDG_OPEN MENU WIN_ATT_OPT PROJ_DIRS   \
              FILE_MANAGER WATCHER TBIND_OPS TBIND_OPEN  \
              TBIND_EXPLORE TBIND_SWITCH ; do

      eval 'is_set=${'$var':+true}'
      test -z "$is_set" && die_conf "'$var' isn't defined"
   done

   # Check if we've got sane values
   expr "$COLOR" : '[0-9]$' >/dev/null || v_err COLOR

   test "$USE_XDG_OPEN" = true        \
      || test "$USE_XDG_OPEN" = false  \
      || v_err USE_XDG_OPEN

   # MENU is used by most wfmux opt, so check it here!
   menu="${MENU%% *}"
   command -v "$menu" >/dev/null \
      || die_conf '$'"MENU: '$menu': Command not found"

   proj_dirs=
   O_IFS=$IFS IFS=${NL%?}

   # This variable is used by all wfmux opts
   for path in $PROJ_DIRS ; do
      rpath=$(realpath -e "$path" 2>/dev/null)

      test $? -eq 0    || die_conf "'$path' does not exist"
      test -d "$rpath" || die_conf "'$rpath' is not a directory"
      test -r "$rpath" || die_conf "cannot list contents of '$rpath'"

      proj_dirs="$proj_dirs${proj_dirs:+${NL%?}}$rpath"
   done

   IFS=$O_IFS
   PROJ_DIRS=$(printf '%s' "$proj_dirs")
}

display_dashboard () {
   awk_max='
      BEGIN { len = 0 }
      {
         nlen = length($0)
         if (nlen > len)
            len = nlen
      }
      END { print len }
   '

   # Dashboard message, explains how to use wfmux on tmux.
   dashboard_msg () {
      cat <<END
The following are tmux bindings related to wfmux.

M-$TBIND_SELECT: fuzzyly open project files
M-$TBIND_EXPLORE: open file manager
M-$TBIND_OPS: fuzzyly select other wfmux operations

input any key to exit dashboard
END
   }

   tty_print () {
      printf '\033[%d;%df%s' "$1" "$2" "$3" >/dev/tty
   }

   # Save initial terminal setting, will set back after exiting dashboard
   init_stty=$(stty -g)
   stty -cooked -echo time 0 min 1
   printf "${ESC_ALT_SCREEN}${ESC_HIDE_CUR}${ESC_CLEAR_SCREEN}"

   {
      term_h= term_w=
      while true ; do

         new_size=$(stty -F /dev/tty size)
         test "$new_size" = "$term_h $term_w" && {
            sleep 1
            continue
         }

         term_h=$(say "$new_size" | cut -d' ' -f1)
         term_w=$(say "$new_size" | cut -d' ' -f2)
         if   test "$term_h" -lt 32 || test "$term_w" -lt 97 ; then
            _size=SS
         elif test "$term_h" -lt 43 || test "$term_w" -lt 155 ; then
            _size=MS
         else
            _size=LS
         fi
         eval 'wfmux_h=$(printf "$WFMUX_'$_size'" | wc -l)
               wfmux_w=$(printf "$WFMUX_'$_size'" | awk "$awk_max")'

         wfmux_h=$(expr "$wfmux_h" + `dashboard_msg | wc -l`)

         x=$((($term_w - $wfmux_w) / 2))
         y=$((($term_h - $wfmux_h) / 2))

         msg_w=$(dashboard_msg | awk "$awk_max")
         if test $msg_w -gt $wfmux_w ; then
            msg_x=$(($x - ($msg_w - $wfmux_w) / 2))
         else
            msg_x=$(($x + ($wfmux_w - $msg_w) / 2))
         fi

         printf "${ESC_CLEAR_SCREEN}${SUCCESS}${ESC_BOLD}"

         IFS=${NL%?}
         for line in $(eval 'printf "$WFMUX_'$_size'"') ; do
            tty_print $y $x "$line"
            y=$(($y + 1))
         done

         printf "$ESC_UNSET_ANSI"
         for line in `dashboard_msg` ; do
            y=$(($y + 1))
            tty_print "$y" "$msg_x" "$line"
         done
      done
   } &

   # Get key from the standard input
   dd if=/dev/tty count=1 bs=1 >/dev/null 2>&1

   kill -KILL $! || :

   stty "$init_stty"
   printf "$ESC_NORMAL_SCREEN$ESC_UNSET_ANSI$ESC_SHOW_CUR"
   tput clear
}

tmux_cur_session () {
   tmux list-sessions -F '#S:#{session_activity}' | sort -b -t: -k2,2n | tail -n1 | cut -d: -f1
}

tmux_cur_pty () {
   tmux list-clients -F '#S:#{client_tty}' | grep -F "$(tmux_cur_session):" | cut -d: -f2
}

tmux_message () {
   tmux display-message -d 2500 -- "$*."
}

wfmux_die () {
   tmux_message "$*"
   tmux display-popup -C
   exit 1
}

shrink_proj_dirs () {
   sdirs=$PROJ_DIRS

   for n in $(seq `say "$sdirs" | wc -l`) ; do
      path=$(say "$sdirs" | sed -ne "${n}p")

      # Check if it's already shrinked
      expr "$path" : / >/dev/null || continue

      name=${path#/}
      name=${name%%/*}

      # Check if $path is the only one.
      test $(say "$sdirs" | grep "^/$name/" | wc -l) -eq 1 && continue

      path=${path#/*/}
      sdirs=$(say "$sdirs" | sed -e "s#^/$name/#*/#")

      # Shrink more
      O_IFS=$IFS IFS=/
      for name in $path ; do
         test $(say "$sdirs" | grep "^\*/$name/" | wc -l) -eq 1 && continue

         _sdirs=$(say "$sdirs" | sed -e "s#^\*/$name/#*/#")

         a=$(say "$_sdirs" | sed -e 's/\*/.../')
         b=$(say "$a"      | sort -u)
         test ${#a} -ne ${#b} && break

         sdirs=$_sdirs
      done
      IFS=$O_IFS

      sdirs=$(say "$sdirs" | sed -e 's/\*/.../')
   done

   say "$sdirs"
}

get_proj_list () {
   line=1
   sdirs=`shrink_proj_dirs`

   IFS=${NL%?}
   for dir in $PROJ_DIRS ; do
      cd "$dir"

      for file in * ; do
         test -d "$file" || continue
         test -x "$file" || continue

         sdir=$(say "$sdirs" | sed -ne "${line}p")
         printf "[%d]:%s/%s\n" $line "$sdir" "$file"
      done

      line=$(($line + 1))
   done
}

new_session () {
   project=$(get_proj_list | eval "$MENU")

   test -z "$project" && return

   line=${project%%]*}
   line=${line#[}
   proj_ddir=$(say "$PROJ_DIRS" | sed -ne "${line}p")
   proj_name=$(basename "$project")
   session=$(say "$proj_name" | sed -e 'y/-./__/')
   proj_dir="$proj_ddir/$proj_name"

   cd -L "$proj_dir"

   test -d .git && {
      touch .gitignore
      grep -q -- .wfmux .gitignore || {
         say '.wfmux' >>.gitignore
         git add .gitignore && git commit -m 'Update .gitignore'
      } 
   }

   if test -d .wfmux      \
   && test -x .wfmux       \
   && test -s .wfmux/name   \
   && expr "$(cat .wfmux/name)" : "$session-.\\{6\\}$" >/dev/null ; then
      session=$(cat .wfmux/name)
   else
      rm -rf .wfmux
      mkdir .wfmux
      touch .wfmux/name

      proj_name=$(say "$proj_name" | sed -e 'y/-./__/')
      session=`mktemp -u $proj_name-XXXXXX`
      printf "$session" >>.wfmux/name
      say './.git' >>.wfmux/ignore
   fi

   if [ -z "${TMUX:-}" ] ; then
      tmux has-session -t "$session" 2>/dev/null || {
         start_watchers "$proj_dir"
         display_dashboard
         tmux new-session -s "$session" -d
      }
      exec tmux attach-session -t "$session"
   else
      pty=`tmux_cur_pty`
      tmux has-session -t "$session" 2>/dev/null || tmux new-session -s "$session" -d
      exec tmux switch-client -c "$pty" -t "$session"
   fi
}

# Create a new tmux wfmux session while in an existing session.
opt_wfmux_nsession () { new_session; }

# Select a project and open a tmux session
opt_wfmux_new () {
   input=
   session=

   if tmux list-sessions >/dev/null 2>&1 ; then
      printf "Choose an existing session to attach\n\n"
      tmux list-sessions | awk '{print "["NR"] "$0}'
   fi

   say "$WFMUX"
   printf '⟩⟩ '
   read input
   tput clear

   test -z "$input" && return

   if test "$input" = f ; then
      new_session
   elif expr "$input" : '\([0-9]\|[1-9][0-9]\+\)$' >/dev/null ; then
      session=$(tmux list-sessions -F '#S' | sed -n "${input}p")
      test -n "$session" && exec tmux attach-session -t "$session"
   else
      exec tmux new-session -s "$input"
   fi
}

set_whxy () {
   name=$1
   win_att=$2

   num_re="$NUM_RE"
   com_re='C\|P\|M\|W'

   x_re="\($com_re\|R\|$num_re\)"
   y_re="\($com_re\|S\|$num_re\)"

   size_re="\(\($num_re\)%\?\)"

   c=$(say "$win_att" | sed -ne "s/^${size_re}x${size_re}+${x_re}+${y_re}$/w=\1 h=\3 x=\5 y=\6/p")

   test -z "$c" && die_conf "Invalid value assigned to '$name'"
   eval "$c"
}

dump_conf () {
   set_whxy WIN_ATT_OPT "$WIN_ATT_OPT"

   cat <<END
unbind M-$TBIND_OPEN
bind   M-$TBIND_OPEN display-popup -w $w -h $h -x $x -y $y -E "$LOCAL_BIN/wfmux open"

unbind M-$TBIND_EXPLORE
bind   M-$TBIND_EXPLORE display-popup -w $w -h $h -x $x -y $y -E "$LOCAL_BIN/wfmux explore"

unbind M-$TBIND_OPS
bind   M-$TBIND_OPS display-popup -w $w -h $h -x $x -y $y -E "$LOCAL_BIN/wfmux ops"

unbind M-$TBIND_SWITCH
bind   M-$TBIND_SWITCH display-popup -w $w -h $h -x $x -y $y -E "$LOCAL_BIN/wfmux switch"
END
}

opt_wfmux_dump () { dump_conf; }
opt_wfmux_tmux () { dump_conf >>"$TMUX_CONF"; }

each () {
   for i in "$@" ; do
      say "$i"
   done
}

get_proj_dir () {
   session=$1
   proj_name=

   proj_name=$(say "$session" | sed -ne 's/^\([^-]\+\)-.\{6\}$/\1/p')
   test -z "$proj_name" && return

   IFS=${NL%?}
   for dir in $PROJ_DIRS ; do
      proj_dir=$(say "$dir/$proj_name" | tr '_' '?' | sed -e 's/\([^\\]\) /\1\\ /g')

      for proj_dir in $(eval each "$proj_dir") ; do
         test -d "$proj_dir"       \
            && test -x "$proj_dir"  \
            && cd -L "$proj_dir"     \
            || continue

         test -f '.wfmux/name'                        \
            && test "$session" = "$(cat .wfmux/name)"  \
            && say "$proj_dir"
      done
   done
}

tmux_or_die () {
   test -n "${TMUX:-}" || die "Wfmux must run in a tmux session"
}

opt_wfmux_switch () {
   tmux_or_die

   wfmux_sessions=

   IFS=${NL%?}
   for session in $(tmux list-sessions -F '#S') ; do
      test -z "$(get_proj_dir "$session")" && continue
      wfmux_sessions="${wfmux_sessions}${session}\n"
   done

   test -z "$wfmux_sessions" && return
   session=$(printf "$wfmux_sessions" | eval "$MENU")

   if test -n "$session" ; then
      tmux switch-client -c "$(tmux_cur_pty)" -t "$session"
   fi
}

## Open TUI file manager
opt_wfmux_explore () {
   tmux_or_die

   requires "$FILE_MANAGER"

   proj_dir=$(get_proj_dir "$(tmux_cur_session)")

   test -z "$proj_dir"     \
      && die_not_wfmux      \
      || eval "$FILE_MANAGER" "$proj_dir"
}

# Add some checks since this function is exposed as a wfmux API function.
get_proj_files () {
   ignore=''
   dir_opt=''

   test $# -eq 1       \
      || test $# -eq 2  \
      || die "get_proj_files: Invalid number of arguments"

   test "${1#-}" = "$1"     \
      && dir=   proj_dir=$1  \
      || dir=$1 proj_dir=$2

   test "$dir" = '-d' && dir_opt='-or -type d'

   cd -L -- "$proj_dir"
   if test -s .wfmux/ignore ; then
      IFS=${NL%?}
      for pattern in `cat .wfmux/ignore` ; do
         ignore="${ignore}${ignore:+ -or}"
         ignore="${ignore} -path '${pattern}'"
      done
   fi

   if [ -n "$ignore" ] ; then
      eval find . '\(' "$ignore" '\)' -prune -or -type f "$dir_opt"
   else
      eval find . -type f "$dir_opt"
   fi
}

get_filetype () {
   file=$1

   if command -v xdg-mime >/dev/null ; then
      filetype=$(xdg-mime query filetype "$file")
   elif command -v file >/dev/null ; then
      filetype=$(file --mime-type "$file")
      filetype=${filetype##*: }
   else
      tmux-message "'$file': Couldn't determine the file type"
      return
   fi

   expr "$filetype" : application >/dev/null  \
      && filetype=${filetype##*/}              \
      || filetype=${filetype%%/*}

   printf "$filetype"
}

nohup () {
   { trap '' HUP; eval "$@"; } &
}

say () {
   printf '%s\n' "$*"
}

## Open a project file
opt_wfmux_open () {
   tmux_or_die

   test "$USE_XDG_OPEN" = true && requires xdg-open

   proj_dir=`get_proj_dir "$(tmux_cur_session)"`
   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   files=$(get_proj_files "$proj_dir" | eval "$MENU")

   IFS=${NL%?}
   for file in $files ; do

      if test "$USE_XDG_OPEN" = true ; then
         cmd="xdg-open '$file'"
      else
         filetype=`get_filetype "$file"`
         test -z "$filetype" && continue

         data=$(say "$PROGRAMS" | grep "^tty=\(true\|false\),$filetype=" | head -n1)

         test -z "$data" && {
            tmux_message "Unable to open '$file'"
            continue
         }

         use_tty=${data%,$filetype=*}
         use_tty=${use_tty#tty=}

         cmd=${data#*,$filetype=}
         cmd=$(printf "$cmd" "$file")

         bin=${cmd%% *}
         command -v "$bin" >/dev/null || {
            tmux_message "Unable to open '$file', $bin: not found"
            continue
         }
      fi

      run_cmd "$cmd" $use_tty
   done
}

run_cmd () {
   cmd=$1
   use_tty=$2
   shell=''

   test "$use_tty" = true || {
      nohup "$cmd" >/dev/null 2>&1
      return 0
   }

   panes=$(tmux list-panes -F '#{pane_current_command}:#P:#{pane_active}')

   # If possible, run the command in an idle pane.
   shell=${SHELL:-sh}
   shell=${shell##*/}
   idle_panes=$(say "$panes" | grep "^$shell:")

   if test -n "$idle_panes" ; then

      target=$(say "$idle_panes" | grep ':1$')
      target=${target%:1}

      test -z "$target" && {
         target=$(say "$idle_panes" | sort -t: -k1,1n | head -n1)
         target=${target%:0}
      }

      target=${target##*:}
      tmux send-keys -t "$target" "$cmd" C-m

   # Spawn off a new pane in the current window if there's only one pane
   # and that pane it's busy.
   elif test $(say "$panes" | wc -l) -eq 1 ; then

      tmux split-window -h "$cmd"

   # In the worst case, run it in a new window.
   else
      tmux new-window "$cmd"
   fi

   return 0
}

opt_wfmux_shell () {
   tmux_or_die

   proj_dir=`get_proj_dir "$(tmux_cur_session)"`
   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"
   exec ${SHELL:-/bin/sh}
}

is_git_repository () {
   git rev-parse --show-toplevel >/dev/null 2>&1 || {
      wfmux_die "This project isn't a git repository"
   }
}

die_not_wfmux () {
   wfmux_die 'This is not a wfmux tmux session'
}

requires () {
   for cmd in "$@" ; do
      command -v "$cmd" >/dev/null \
         || wfmux_die "$cmd: Command not found"
   done
}

has () {
   command -v "$1" >/dev/null
}

opt_wfmux_log () {
   tmux_or_die

   requires git

   proj_dir=`get_proj_dir "$(tmux_cur_session)"`
   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   is_git_repository || return

   git log --graph | less
}

git_status () {
   git status --porcelain --ignore-submodules
}

commit () {
   tmux_or_die

   requires git

   proj_dir=`get_proj_dir "$(tmux_cur_session)"`
   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   is_git_repository || return

   export EDITOR=${EDITOR:-vim}
   command -v "$EDITOR" >/dev/null || wfmux_die "$EDITOR: Command not found"

   gstatus=$(git_status | sed -e 's/^ /-/;s/^??/-U/;s/^\(.\)  /\1 /')

   test -z "$gstatus"  \
      && test $# -eq 0  \
      && wfmux_die 'Nothing to commit, working tree clean'

   gstatus=$(say "$gstatus" | eval "$MENU")

   test -z "$gstatus"  \
      && test $# -eq 0  \
      && {
      tmux display-popup -C
      return
   }

   IFS=${NL%?}
   for change in $gstatus ; do
      file=${change#* }
      ctype=${change%% *}

      test "${ctype%?}" != '-' && continue

      ctype=${ctype#?}
      test "$ctype" != M       \
         && test "$ctype" != U  \
         && continue

      git add "$file" 2>/dev/null || wfmux_die "'$file' Couldn't be added to the index"
   done

   git commit "$@"
}

opt_wfmux_commit () {
   commit || tmux_message "Unable to commit"
}

opt_wfmux_acommit () {
   commit --amend || tmux_message "Unable to amend"
}

git_branches () {
   IFS=${NL%?}

   for lbranch in $(git branch --list --no-color) ; do
      test "${lbranch% *}" = '*' && continue

      lbranch=${lbranch#  }
      rbranch=$(git rev-parse --abbrev-ref "$lbranch@{u}" 2>/dev/null)

      if test $? -eq 0 ; then
         printf 'L %s -> %s\n' "$lbranch" "$rbranch"
      else
         printf 'L %s\n' "$lbranch"
      fi
   done

   git branch --remote --no-color | sed -ne '2,$s/^ */R /p'
}

new_branch () {
   rbranch=$1
   lbranch=${rbranch##*/}

   git show-ref --verify --quiet refs/heads/$lbranch && {

      say "$branch: Local branch name already exists"
      printf 'New name (y/n)? '
      read input
      test "$input" != y && return

      printf ': '
      read lbranch
      test -z "$lbranch" && return

      git check-ref-format --branch "$lbranch" >/dev/null
      test $? -ne 0 && return 1
   }

   git checkout -b "$lbranch" --track "$rbranch"
}

git_checkout () {
   tmux_or_die

   requires git

   proj_dir=$(get_proj_dir "$(tmux_cur_session)")
   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   is_git_repository || return

   test "${1:-}" = '--clean-worktree' && {
      test -z "$(git_status)" || {
         wfmux_die 'Still have local changes to be commited'
      }
   }

   branch=`git_branches | eval "$MENU"`
   test -z "$branch" && return

   btype=${branch%% *}
   branch=${branch#? }
   branch=${branch%% *}

   if test "$btype" = L ; then
      git checkout "$branch"
   else
      new_branch "$branch"
   fi

   test $? -eq 0 && {
      tmux_message "Switched to '$branch'"

      git_status | grep -xq '?? \.wfmux' && {
         printf '.wfmux/' >>.gitignore
         git add .wfmux
      }
   }

   input_2_quit
   tmux display-popup -C
}

opt_wfmux_checkout  () { git_checkout --clean-worktree; }
opt_wfmux_fcheckout () { git_checkout;                  }

opt_wfmux_cbranch () {
   tmux_or_die

   requires git

   proj_dir=`get_proj_dir "$(tmux_cur_session)"`

   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   is_git_repository || return

   tmux_message "$(git branch --show-current)"
   tmux display-popup -C
}

input_2_quit () {
   init_stty=`stty -g`
   stty -echo -cooked && dd if=/dev/tty count=1 bs=1 >/dev/null 2>&1
   stty "$init_stty"
}

opt_wfmux_nremote () {
   tmux_or_die

   requires git

   proj_dir=`get_proj_dir "$(tmux_cur_session)"`
   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   is_git_repository || return

   printf 'remote name: '
   read name
   test -z "$name" && return

   printf 'url: '
   read url
   test -z "$url" && return

   git remote add "$name" "$url"
   input_2_quit
}

wfmux_push () {
   tmux_or_die

   requires git

   proj_dir=`get_proj_dir "$(tmux_cur_session)"`
   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   is_git_repository || return

   # TODO: wfmux_push
   # $GITLAB_TOK_NAME:$my_tok, --set-upstream $my_tok@...
}

spin () {
   pos=0 set -- − \\ \| /

   while true ; do 
      sleep 0.2
      pos=$(($pos + 1))
      eval 'printf "\b$'$((($pos % 4) + 1))'"'
   done
} 

opt_wfmux_push  () { wfmux_push;         }
opt_wfmux_fpush () { wfmux_push --force; }

opt_wfmux_awatch () {
   tmux_or_die

   proj_dir=`get_proj_dir "$(tmux_cur_session)"`
   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   printf 'watcher name: '
   read name
   test -z "$name" && return

   expr "$name" : '[a-zA-Z][-0-9a-zA-Z]*$' >/dev/null || {
      wfmux_die "'$name' isn't a valid watcher name"
   }

   watch_conf="$proj_dir/.wfmux/watch"

   if test -s "$watch_conf"  \
   && grep -q "^w[-+],[01],\[$name\]:" "$watch_conf" ; then
      wfmux_die "A watcher named '$name' already exists"
   fi

   printf 'one shot? (y/n) '
   read wtype
   test "$wtype" = y && wtype=1 || wtype=0

   printf 'cmd: '
   read cmd
   test -z "$cmd" && return

   files=$(get_proj_files -d "$proj_dir" | eval "$MENU")

   say "w+,$wtype,[$name]:$cmd${NL%?}$files${NL%?}end" >>"$watch_conf"

   tmux_message "Added watcher named '$name'"
}

select_watcher () {
   names=
   watch_conf=$1

   test -f "$watch_conf" || rm -f "$watch_conf"

   touch "$watch_conf"
   names=$(sed -ne 's/^w[-+],[01],\[\([^]]\+\)\]:.\+$/\1/p' "$watch_conf")

   if test -z "$names" ; then
      wfmux_die 'There are no configured watchers'
   fi

   say "$(say "$names" | eval "$MENU")"
}

check_conf () {
   name=$1
   conf=$2

   e="
      1 { s/^w[-+],[01],\[$name\]:.*[:a-zA-Z].*$/1/p; b }
      $ { s/^end$/1/p; b }
      /^\.\//p
   "
   a=$(say "$conf" | wc -l)
   b=$(say "$conf" | sed -ne "$e" | wc -l)

   test "$a" -eq "$b" || wfmux_die "watcher($name): Invalid watcher config"
}

opt_wfmux_mwatch () {
   tmux_or_die

   edit=${EDITOR:-vim}
   requires "$edit"

   proj_dir=`get_proj_dir "$(tmux_cur_session)"`
   test -z "$proj_dir" && die_not_wfmux

   watch_conf="$proj_dir/.wfmux/watch"

   name=$(select_watcher "$watch_conf")
   test -z "$name" && return

   e="
      /^w[-+],[01],\[$name\]:/ {
         p
         n
         b loop
      }
      b
      :loop
         /^\.\// { p; n; b loop }
         /^end$/ { p; q }
         n
         b loop
   "

   conf=$(sed -ne "$e" "$watch_conf")
   if test -z "$conf" ; then
      wfmux_die "There is no watcher named '$name'"
   fi

   check_conf $name "$conf"

   tmpfile=$(mktemp /tmp/wfmux.XXXXXX)
   say "$conf" >>$tmpfile
   say '# Please edit the watcher configuration. Empty lines and' >>$tmpfile
   say '# lines starting with "#" will be ignored.' >>$tmpfile

   eval "$edit" $tmpfile
   conf=$(grep -xv '[[:space:]]*\(#.*\)\?' $tmpfile)

   check_conf $name "$conf"
   del_watcher $name "$watch_conf"
   say "$conf" >>"$watch_conf"
}

del_watcher () {
   name=$1
   watch_conf=$2

   sed -i "/^w[-+],[01],\[$name\]:/,/^end$/d" "$watch_conf"
}

opt_wfmux_rwatch () {
   tmux_or_die

   proj_dir=`get_proj_dir "$(tmux_cur_session)"`
   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   watch_conf="$proj_dir/.wfmux/watch"

   name=$(select_watcher "$watch_conf")
   test -z "$name" && return

   del_watcher "$name" "$watch_conf"
}

watcher_state_edit () {
   state=${1:--e}
   test "$state" = '-e' && state=+ || state=-

   proj_dir=`get_proj_dir "$(tmux_cur_session)"`
   test -z "$proj_dir" && die_not_wfmux

   watch_conf="$proj_dir/.wfmux/watch"

   name=$(select_watcher "$watch_conf")
   test -z "$name" && return

   sed -i "s/^w[-+]\(,[01],\[$name\]:\)/w$state\1/" "$watch_conf"
   grep -q "^w$state,[01],\[$name\]:" "$watch_conf"
}

opt_wfmux_dwatch () {
   tmux_or_die

   if watcher_state_edit -d ; then
      tmux_message "Watcher successfully disabled"
   else
      wfmux_die "Couldn't disable the watcher"
   fi
}

opt_wfmux_ewatch () {
   tmux_or_die

   if watcher_state_edit -e ; then
      tmux_message "Watcher successfully enabled"
   else
      wfmux_die "Couldn't enable the watcher"
   fi
}

opt_wfmux_sawatch () {
   tmux_or_die

   command -v "$WATCHER" >/dev/null || die_conf "$watcher: command not found"

   proj_dir=`get_proj_dir "$(tmux_cur_session)"`
   test -z "$proj_dir" && die_not_wfmux

   watch_conf="$proj_dir/.wfmux/watch"

   name=$(select_watcher "$watch_conf")
   test -z "$name" && return

   pid_file="$proj_dir/.wfmux/pids/$name.pid"

   if test -s "$pid_file"                    \
   && read pid <"$pid_file"                   \
   && expr "$pid" : "\($NUM_RE\)$" >/dev/null  \
   && test -d "/proc/$pid" ; then
      tmux_message "watch($name): This watcher is already running"
      return
   fi

   start_watcher "$proj_dir" "$name"
}

opt_wfmux_sowatch () {
   tmux_or_die

   proj_dir=`get_proj_dir "$(tmux_cur_session)"`
   test -z "$proj_dir" && die_not_wfmux

   name=$(select_watcher "$watch_conf")
   test -z "$name" && return

   pid_file="$proj_dir/.wfmux/pids/$name.pid"

   if ! test -s "$pid_file" ; then
      wfmux_die "watcher($name): Unable to find the pid of the watcher"
   fi

   read pid <"$pid_file"
   if ! expr "$pid" : "\($NUM_RE\)$" >/dev/null ; then
      wfmux_die "watcher($name): Invalid value found at '$pid_file'"
   fi

   test -d "/proc/$pid" && kill -9 "$pid"
}

start_watcher () {
   proj_dir=$1
   name=${2:-}
   
   watch_conf="$proj_dir/.wfmux/watch"
   test -s "$watch_conf" || return

   efiles_dir="$proj_dir/.wfmux/efiles"
   mkdir -p "$efiles_dir"

   wname=''
   wtype=''
   cmd=''

   n=0
   dir=false
   efiles=''
   state=watcher

   while read line ; do
      n=$(($n + 1))

      if expr "$line" : '[[:space:]]*$' ; then
         continue
      elif expr "$line" : 'w+,[01],\[[^]:[:space:]]\+\]:.*[:a-zA-Z].*$' ; then

         wname="${line##w+,?,[}"
         wname="${wname%%]*}"
         wtype="${line#*,}"
         wtype="${wtype%%,*}"
         cmd="${line#w+,?,\[*\]:}"
         efiles="$efiles_dir/$wname.efiles"
         state=files

      elif test -n "$name"   \
      &&   test -n "$wname"   \
      &&   test "$name" != "$wname" ; then

         state=watcher
         continue

      elif expr "$line" : 'end$' \
      &&   test "$state" = files ; then

         say "$proj_dir" >>"$efiles"
         run_watch_cmd "$wname"    \
                             "$wtype"     \
                             "$cmd"      \
                             "$dir"         \
                             "$efiles"
         read x
         state=watcher

      elif test "$state" = files \
      &&   expr "$line" : '\./' ; then

         file=$(say "$line" | sed -e 's/[[:space:]]*$//;s/ /\\ /g')

         IFS=${NL%?}
         for efile in $(eval each "$file") ; do
            if ! test -e "$efile" ; then
               wfmux_die "watcher($wname): '$efile' does not exist"
            elif test -d "$efile" ; then
               dir=true
            fi
            say "$efile"
         done  >"$efiles"
      fi
   done <"$watch_conf"

   if test "$state" = files ; then
      wfmux_die "('$watch_conf'): Failed to parse config at line $n."
   fi
}

run_watch_cmd () {
   name=$1
   wtype=$2
   cmd='exec tmux set-buffer -b '$name' "$('"$3"' 2>&1)"'
   dir=$4
   proj_dir=$5

   pid_dir="$proj_dir/.wfmux/pids"
   pid_file="$pid_dir/$name.pid"

   echo "we are here: cmd: $cmd, name: $name, wtype: $wtype, dir: $dir, proj_dir: $proj_dir"
   read x

   mkdir -p "$pid_dir"

   efiles="$proj_dir/.wfmux/efiles/$name.efiles"

   args='-nps'
   test "$wtype" = 1 && args="${args}r"

   if test "$dir" = xfalse ; then
      printf $$ >>"$pid_file"
      exec entr $args "$cmd" <"$efiles"
   fi

   args="${args}d"
   while sleep 0.5 ; do
      test -e "$efiles"       \
         && test -s "$efiles"  \
         || {
         tmux set-buffer \
            -b "$name"    \
            "Couldn't read '$efiles', please restart the watcher!"
         break
      }
      exec entr $args "$cmd" <"$efiles" &
      printf $! >>"$pid_file"
      waitpid $!
   done
}

opt_wfmux_wtop () {
   tmux_or_die

   proj_dir=`get_proj_dir "$(tmux_cur_session)"`
   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   watch_conf="$proj_dir/.wfmux/watch"

}

#             --[ proj_name ]--
#    PID:          not running(red), running($COLOR)
#    WATCHER_NAME: disable(red), enabled($COLOR)
#    o/m         : o, not monitored by $runner otherwise m
#
#    WATCHER_NAME   PID    o/m  COMMAND
#    watcher_name_1 pid_1  o    command_1
opt_view () {
   test -z "$proj_name" && return
   proj_name=`basename "$proj_name"`

   printf "${ESC_UNDERLINE}${SUCCESS}${proj_name}${ESC_UNSET_ANSI}${ESC_UNSET_ANSI}\n"
   printf "${ESC_BOLD}PID${ESC_UNSET_ANSI}:          shotdown(${ESC_RED}red${ESC_UNSET_ANSI}), running(${SUCCESS}this color${ESC_UNSET_ANSI})\n"
   printf "${ESC_BOLD}WATCHER_NAME${ESC_UNSET_ANSI}: disable(${ESC_RED}red${ESC_UNSET_ANSI}), enabled(${SUCCESS}this color${ESC_UNSET_ANSI})\n"
   printf "${ESC_BOLD}O/M${ESC_UNSET_ANSI}         : ${ESC_BOLD}O${ESC_UNSET_ANSI} = oneshot, ${ESC_BOLD}M${ESC_UNSET_ANSI} = not oneshot\n\n"

   watcher_file="$SESSION_DIR/$proj_session/watch"
   while read watcher ; do
      watcher=$(printf "$watcher" | sed -ne "s///p")
      _name=$(printf "$watcher" | awk 'BEGIN{RS="";FS="\n"};{print $1}')
      pid_file="$SESSION_DIR/$proj_session/$_name/pid"
      test -s "$pid_file" && _pid=$(cat "$pid_file") || _pid=X
   
      test ${#pid}  -gt $j && j=${#pid}
      test ${#name} -gt $i && i=${#name}

      pid=${pid}${pid:+"\n"}$_pid
      name=${name}${name:+"\n"}$_name
      stat=${stat}${stat:+"\n"}$(printf "$watcher" | awk 'BEGIN{RS="";FS="\n"};{print $2}')
      shot=${shot}${shot:+"\n"}$(printf "$watcher" | awk 'BEGIN{RS="";FS="\n"};{print $3}')
      comm=${comm}${comm:+"\n"}$(printf "$watcher" | awk 'BEGIN{RS="";FS="\n"};{print $4}')
   done <"$watcher_file"

   printf "%${i}s |%${j}s |%-4s |%s\n" "WATCHER_NAME" "PID" "O/M" "COMMAND"
   printf "%${i}s |%${j}s |%-4s |%s\n" "" "" "" ""

   while [ 1 ] ; do
      test ${#name} -eq 0 && break
      printf "%${i}s |%${j}s |%-4s |%s\n" "$_name" "$_pid" "$_stat" "$_comm"
   done
}


opt_ksession () { :; }

# Cycle through std(out&stderr) of watchers
opt_cycle () { :; }

add_plug () {
   name=${1:-}
   test -z "$name" && return

   say "$WFMUX_OPS" | grep -xqF "$name" || {
      tmux_message "Another plugin has this name."
      return
   }

   WFMUX_OPS="${WFMUX_OPS}${NL%?}$name"
}

wfmux_load_plugins () {
   test -d "$WFMUX_PLUG_DIR" || return
   test -r "$WFMUX_PLUG_DIR" || {
      tmux_message "No read permission for '$WFMUX_PLUG_DIR'"
      return 0
   }

   for plug in "$WFMUX_PLUG_DIR"/*.wfmux.sh ; do
      . "$plug"
      test $? -eq 0 && continue
      tmux_message "load_plug('$plug') has a non-zero exit status"
      return 1
   done
}

opt_wfmux_ops () {
   tmux_or_die

   wfmux_load_plugins || return

   opt=$(say "$WFMUX_OPS" | grep -xEv 'new|ops' | eval "$MENU")
   test -z "$opt" && return

   func="opt_wfmux_$opt"

   cmd_val=`command -v "$func"`
   if test -z "$cmd_val" ; then
      tmux_message "$func: undefined wfmux operation"
   elif test "$cmd_val" != "$func" ; then
      tmux_message "$func: wfmux operation should be a function!"
   else
      eval "$func"
   fi
}

main "$@"
