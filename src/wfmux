#!/bin/dash

#set -x
set -u

readonly PROGRAM=${0##*/}

readonly ESC_ALT_SCREEN='\033[?1049h'
readonly ESC_NORMAL_SCREEN='\033[?1049l'
readonly ESC_HIDE_CUR='\033[?25l'
readonly ESC_SHOW_CUR='\033[?25h'
readonly ESC_CLEAR_SCREEN='\033[2J'
readonly ESC_BOLD='\033[1m'
readonly ESC_UNDERLINE='\033[4m'
readonly ESC_RED='\033[31m'
readonly ESC_UNSET_ANSI='\033[0m'

readonly CONFIG_DIR=${XDG_CONFIG_HOME:-"$HOME/.config"}
readonly WFMUX_CONFIG_DIR="${CONFIG_DIR%%/}/wfmux"
readonly COMMANDS="$WFMUX_CONFIG_DIR/commands"
readonly CACHE_DIR=${XDG_CACHE_HOME:-"$HOME/.cache"}
readonly CACHE="${CACHE_DIR%%/}/wfmux"
readonly SESSION_DIR="${CACHE_DIR%%/}/wfmux/sessions"
readonly TMUX_CONF="$HOME/.tmux.conf"

readonly NL=$(printf '\n_')

mkdir -p "$CONFIG_DIR" "$CACHE_DIR" "$CACHE" "$SESSION_DIR" "$WFMUX_CONFIG_DIR"

# Large size
readonly WFMUX_LS=$(cat <<EOF
                                ┌────────────
                                │
                                │                                            ┌───────
                                │                             ┌───┐          │
            ┌──┐                │                             │   │          │
            │  │                │                             │   │          │
            │  │           ┌────┼─────┬─────┬──────┬──┐       │   │    ┌─────┘
            │  │     ┌─    │    │     │     │      │  │       │   │    │
────────────┘  │     │     │    │     │     │      │  │       │   └────┼─────┐
               │     │     │    │     │     │      │  │       │        │     │
               │     │     │    │     │     └────  │  └───────┘        │     │
               ├─────┴─────┘    │     │            └──                 │     │
               │                │    ─┘                                │     │
               │                │            ──────────────────────────┘     │
               │                └─                                           │
         ──────┘                                                             │
                                                                             │
EOF
)

# Medium size
readonly WFMUX_MS=$(cat <<EOF
                     ┌─────                           ┌───
                     │                                │
        ┌─┐          │                      ┌──┐      │
        │ │       ┌──┼───┬───┬───┬────┐     │  │  ┌───┘
        │ │   ┌─  │  │   │   │   │    │     │  │  │
────────┘ │   │   │  │   │   │   │    │     │  └──┼───┐
          │   │   │  │   │   │   │    │     │     │   │
          ├───┴───┘  │  ─┘   └─  │    └─────┘     │   │
          │          └─          └──              │   │
          │                              ─────────┘   │
       ───┘                                           │
EOF
)

# Small size
readonly WFMUX_SS='WFMUX'

readonly WFMUX=$(cat<<EOL

     ┌──────────────┤ WFMUX
    ┌┴────────────────────────────────────────┐
    │                                         │
    ├─ Input a name for a new tmux session    │
    ├─ Input f⟨return⟩ to select a project    │
    ├─ Input ⟨return⟩ to drop to the terminal │
    │                                         │
    └─────────────────────────────────────────┘
EOL
)

WFMUX_CONFIG="$WFMUX_CONFIG_DIR/wfmux.conf"
WFMUX_OPS=$(cat<<END
new
tmux
dump
open
explore
nsession
switch
view
awatcher
dwatcher
ewatcher
rwatcher
push
fpush
commit
acommit
checkout
cbranch
ops
END
)

# Default configuration if external config file does not exist
COLOR=4
SUCCESS="\033[1;3${COLOR}m"

TOK=tok
GITLAB_TOK_NAME=gitlab_token_name

WATCHER='entr'
WATCHER_TEMPLATES="$HOME/.config/wfmux/commands"
FILE_MANAGER='lf'

WIN_ATTR_OTHERS='20x20+10+20'
WIN_ATTR_FILE_SELECTOR='20x20+10+20'
WIN_ATTR_INPUT_BOX='20x20+10+20'

TBIND_OPS='='
TBIND_EXPLORE='BSpace'
TBIND_SELECT='Enter'

MENU='fzf --multi --margin=25%'

PROJECT_DIRS=$(cat <<END
$HOME/projects
$HOME/oprojects
END
)

USE_XDG_OPEN=false
PROGRAMS=$(cat <<END
tty=true,text=vim '%s'
tty=true,directory=lf '%s'
tty=true,video=ffplay -hide_banner -loop 0 '%s'
tty=true,audio=ffplay -hide_banner -loop 0 '%s'
tty=false,pdf=zathura '%s'
tty=false,image=feh '%s'
END
)

usage () {
   cat <<END
Build an awesome dev workflow using tmux, fzf, nnn, and entr.

Usage: wfmux [ ( -c | --config ) CONF ] OPT_NAME
       wfmux [ -h | --help ]

Options:
     -h, --help         print this help message.
     -c, --config CONF  load CONF configuration file.

OPT_NAME:
    new          fuzzyly select a project and open a new tmux session.
    nsession     create a new project tmux session while in a tmux session.
    switch       switch between project sessions
    explore      open your favorite file manager on a popup tmux pane.
    open         fuzzyly select a file to open provided that they exist
                 a recently used tmux session which carries the name of your
                 project.   
    commit       add to the index and commit changes to local repository.
    acommit      replace the tip of the current branch by creating a new commit
    checkout     fuzzyly switch between branches of your local repository.
    fcheckout
    push         push to the remote repositories.
    fpush        force-push to the remote repositories.
    dump         dump wfmux's tmux configuration to stdout.
    tmux         update wfmux's tmux configuration at ~/.tmux.conf.
    ops          a wrapper to the above operations.
    dwatcher     disable a watcher from the watcher list
    ewatcher     enable a watcher from the watcher list
    awatcher     Add a new watcher to a project's watcher list.
    rwatcher     Remove a new watcher to a project's watcher list.
    view         Fancy view of the concerned running project watcher.

END
   exit $1
}

die () {
   printf '%s: %s\n' "$PROGRAM" "$*" >&2
   exit 1
}

main () {
   test $# -eq 0 && usage 1

   opt_name=
   while [ $# -ne 0 ] ; do
      case $1 in
         -h|--help)
            usage 0
            ;;
         -c|--config)
            test $# -eq 1 && WFMUX_CONFIG=$2 || usage 1
            test -e "$WFMUX_CONFIG" || {
               die "Config file '$WFMUX_CONFIG' does not exist."
            }
            shift
            ;;
         -*)
            die "Unknown option '$1', please try \`$PROGRAM --help'."
            ;;
         *)
            test -n "$opt_name" && usage 1
            opt_name=$1
            printf '%s' "$WFMUX_OPS" | grep -q "^$opt_name$" || {
               die "Unknown wfmux operation: $opt_name."
            }
            ;;
      esac
      shift
   done

   test -f "$WFMUX_CONFIG" && {
      test -r "$WFMUX_CONFIG" || die "No permission to read '$WFMUX_CONFIG'."
      . "$WFMUX_CONFIG"       || die "Non-zero exit status when sourcing config ."
   }

   check_config_variables
   eval "opt_wfmux_$opt_name"
}

## Check if variables are unset or null and if set then check if
## the data matches our expectations we won't have to rely on
## `set -u`, we would want to output a custom error message if
## one of these variables aren't sane.
check_config_variables () {
   var=
   is_set=

   die_conf () {
      die " ('$WFMUX_CONFIG'): $*"
   }

   val_error () {
      die_conf "Invalid value assigned to '$1'"
   }

   for var in USE_XDG_OPEN WATCHER MENU FILE_MANAGER WIN_ATTR_OTHERS \
              WIN_ATTR_INPUT_BOX WIN_ATTR_FILE_SELECTOR PROJECT_DIRS  \
              TBIND_OPS TBIND_SELECT TBIND_EXPLORE ; do

      eval "is_set=\${$var:+true}"
      test -z "$is_set" && _die_conf "'$var' isn't defined"
   done

   ## Check if we've got sane values
   {
      expr "$COLOR"        : '[0-9]$'           || val_error COLOR
      expr "$USE_XDG_OPEN" : '\(true\|false\)$' || val_error USE_XDG_OPEN

      num_reg='\([0-9]\|[1-9][0-9]\+\)'
      att_reg="${num_reg}x${num_reg}+${num_reg}+${num_reg}$"

      for var in WIN_ATTR_OTHERS        \
                 WIN_ATTR_FILE_SELECTOR  \
                 WIN_ATTR_INPUT_BOX ; do

         val=$(eval 'printf $'$var)
         expr "$val" : "$att_reg" || val_error $var
      done

      for cmd in FILE_MANAGER WATCHER MENU ; do
         if ! eval 'command' '-v' '$'"{$cmd}" ; then
            die_conf "Command '$cmd' not found"
         fi
      done

   } >/dev/null

   OIFS=$IFS IFS='
'
   project_dirs=

   for path in $PROJECT_DIRS ; do
      rpath=$(realpath -e "$path" 2>/dev/null)

      test $? -eq 0    || die_conf "'$path' does not exist"
      test -d "$rpath" || die_conf "'$rpath' is not a directory"
      test -r "$rpath" || die_conf "cannot list contents of '$rpath'"

      project_dirs="$project_dirs${project_dirs:+${NL%?}}$rpath"
   done

   IFS=$OIFS
   PROJECT_DIRS=$(printf '%s' "$project_dirs")
}

display_dashboard () {
   awk_max='
      BEGIN { len = 0 }
      {
         nlen = length($0)
         if (nlen > len)
            len = nlen
      }
      END { print len }
   '

   # Dashboard message, explains how to use wfmux on tmux.
   _dashboard_msg () {
      cat <<END
The following are tmux bindings related to wfmux.

M-$TBIND_SELECT: fuzzyly open project files
M-$TBIND_EXPLORE: open file manager
M-$TBIND_OPS: fuzzyly select other wfmux operations

input any key to exit dashboard
END
   }

   _tty_print () {
      printf '\033[%d;%df%s' "$1" "$2" "$3" >/dev/tty
   }

   # Save initial terminal setting, will set back after exiting dashboard
   init_stty=`stty -g`
   stty -cooked -echo time 0 min 1
   printf "${ESC_ALT_SCREEN}${ESC_HIDE_CUR}${ESC_CLEAR_SCREEN}"

   {
      term_h= term_w=
      while [ 1 ] ; do
         new_size=`stty -F /dev/tty size`
         if test "$new_size" = "$term_h $term_w" ; then
            sleep 1
            continue
         fi

         term_h=$(printf "$new_size\n" | cut -d' ' -f1)
         term_w=$(printf "$new_size\n" | cut -d' ' -f2)
         if test $term_h -lt 32 || test $term_w -lt 97 ; then
            _size=SS
         elif test $term_h -lt 43 || test $term_w -lt 155 ; then
            _size=MS
         else
            _size=LS
         fi
         eval 'wfmux_h=$(printf "$WFMUX_'$_size'" | wc -l)
               wfmux_w=$(printf "$WFMUX_'$_size'" | awk "$awk_max")'

         wfmux_h=$(expr $wfmux_h + `_dashboard_msg | wc -l`)

         x=$((($term_w - $wfmux_w) / 2))
         y=$((($term_h - $wfmux_h) / 2))

         msg_w=$(_dashboard_msg | awk "$awk_max")
         if test $msg_w -gt $wfmux_w ; then
            msg_x=$(($x - ($msg_w - $wfmux_w) / 2))
         else
            msg_x=$(($x + ($wfmux_w - $msg_w) / 2))
         fi

         printf "${ESC_CLEAR_SCREEN}${SUCCESS}${ESC_BOLD}"

         IFS='
'
         for line in $(eval 'printf "$WFMUX_'$_size'"') ; do
            _tty_print $y $x "$line"
            y=$(($y + 1))
         done

         printf "$ESC_UNSET_ANSI"
         for line in `_dashboard_msg` ; do
            y=$(($y + 1))
            _tty_print "$y" "$msg_x" "$line"
         done
      done
   } &

   # Get key from the standard input
   dd if=/dev/tty count=1 bs=1 >/dev/null 2>&1

   kill -KILL $! || :

   stty "$init_stty"
   printf "$ESC_UNSET_ANSI$ESC_SHOW_CUR"
   tput clear
}

tmux_cur_session () {
   tmux list-sessions -F '#S:#{session_activity}' | sort -b -t: -k2,2n | tail -n1 | cut -d: -f1
}

tmux_cur_pty () {
   tmux list-clients -F '#S:#{client_tty}' | grep -F "$(tmux_cur_session):" | cut -d: -f2
}

tmux_message () {
   tmux display-message -d 2500 "$1"
}

shrink_project_dirs () {
   sdirs=$PROJECT_DIRS

   for n in $(seq `printf '%s\n' "$sdirs" | wc -l`) ; do
      path=$(printf '%s' "$sdirs" | sed -ne "${n}p")

      # Check if it's already shrinked
      expr "$path" : / >/dev/null || continue

      name=${path#/}
      name=${name%%/*}

      # Check if $path is the only one.
      test $(printf '%s' "$sdirs" | grep "^/$name/" | wc -l) -eq 1 && continue

      path=${path#/*/}
      sdirs=$(printf '%s' "$sdirs" | sed -e "s#^/$name/#*/#")

      # Shrink more
      OIFS=$IFS IFS=/
      for name in $path ; do
         test $(printf '%s' "$sdirs" | grep "^\*/$name/" | wc -l) -eq 1 && continue

         _sdirs=$(printf '%s' "$sdirs" | sed -e "s#^\*/$name/#*/#")

         a=$(printf '%s' "$_sdirs" | sed -e 's/\*/.../')
         b=$(printf '%s' "$a"      | sort -u)
         test ${#a} -ne ${#b} && break

         sdirs=$_sdirs
      done
      IFS=$OIFS

      sdirs=$(printf '%s' "$sdirs" | sed -e 's/\*/.../')
   done

   printf '%s\n' "$sdirs"
}

get_project_list () {
   line=1
   sdirs=`shrink_project_dirs`

   IFS='
'
   for dir in $PROJECT_DIRS ; do
      cd "$dir"

      for file in * ; do
         test -d "$file" || continue
         test -x "$file" || continue

         sdir=$(printf "$sdirs" | sed -ne "${line}p")
         printf "[%d]:%s/%s\n" $line "$sdir" "$file"
      done

      line=$(($line + 1))
   done
}

new_session () {
   project=$(get_project_list | eval "$MENU")

   test -z "$project" && return

   line=${project%%]*}
   line=${line#[}
   project_ddir=$(printf "$PROJECT_DIRS" | sed -ne "${line}p")
   project_name=$(basename "$project")
   project_dir="$project_ddir/$project_name"

   cd -L "$project_dir"

   test -d .git && {
      touch .gitignore
      grep -q -- .wfmux .gitignore || {
         printf '.wfmux\n' >>.gitignore
         git add .gitignore && git commit -m 'Update .gitignore'
      } 
   }

   if test -d .wfmux      \
   && test -x .wfmux       \
   && test -s .wfmux/name   \
   && expr "$(cat .wfmux/name)" : "$project_name-.\\{6\\}$" >/dev/null ; then
      session_name=`cat .wfmux/name`
   else
      mkdir -p .wfmux
      touch .wfmux/name
      session_name=`mktemp -u $project_name-XXXXXX`
      printf "$session_name" >>.wfmux/name
      printf '.git\n'        >>.wfmux/ignore
   fi

   if [ -z "${TMUX:-}" ] ; then
      tmux has-session -t "$session_name" 2>/dev/null || {
         start_watchers "$project_dir"
         display_dashboard
         tmux new-session -s "$session_name" -d
      }
      exec tmux attach-session -t "$session_name"
   else
      pty=`tmux_cur_pty`
      tmux has-session -t "$session_name" 2>/dev/null || tmux new-session -s "$session_name" -d
      tmux switch-client -c "$pty" -t "$session_name"
   fi
}

# Create a new tmux wfmux session while in an existing session.
opt_wfmux_nsession () { new_session; }

start_watchers () {
   project_dir=$1
   watch_config="$project_dir/.wfmux/watch"

   ! test -s "$watch_config" && return

   mkdir -p "$project_dir/.wfmux/fifos"

   cat "$watch_config" | grep '^s+' | while read watcher ; do
      watcher_name=$(printf "$watcher" | sed -ne 's/^s+.\[\([^:]]\+\)\]:.*/\1/p')
      is_oneshot=$(printf "$watcher"   | sed -ne 's/^s+\(0\|1\).*/\1/p')
      watcher_cmd=$(printf "$watcher"  | sed -ne 's/^[^:]*:\(.\+\)/\1/;s/^[ \t]*//;s/[ \t]*$//p')

      if test -z "$watcher_name"  \
      || test -z "$is_oneshot"     \
      || test -z "$watcher_cmd" ; then
         die "failed to parse watcher: $watch_config'."
      fi

      start_watcher "$project_dir" $watcher_name $is_oneshot "$watcher_cmd"
   done
}

# Select a project and open a tmux session
opt_wfmux_new () {
   session_name= input=

   if tmux list-sessions >/dev/null 2>&1 ; then
      printf "Choose an existing session to attach\n\n"
      tmux list-sessions | awk '{print "["NR"] "$0}'
   fi

   printf "$WFMUX\n"
   read -p '⟩⟩ ' input
   tput clear

   test -z "$input" && return

   if expr "$input" : '\(F\|f\)$' >/dev/null ; then
      new_session
   elif expr "$input" : '\([0-9]\|[1-9][0-9]\+\)$' >/dev/null ; then
      session_name=$(tmux list-sessions -F '#S' | sed -n "${input}p")
      test -n "$session_name" && tmux attach-session -t "$session_name"
   else
      tmux new-session -s "$(printf "$input")"
   fi
}

set_whxy () {
   window_attribute=$1

   y=$(printf "$window_attribute" | sed -e 's/^.*+\([0-9]\+\)$/\1/')
   x=$(printf "$window_attribute" | sed -e 's/^.*+\([0-9]\+\)+.*/\1/')
   w=$(printf "$window_attribute" | sed -e 's/^\([0-9]\+\)x.*/\1/')
   h=$(printf "$window_attribute" | sed -e 's/^.*x\([0-9]\+\).*/\1/')
}

dump_config () {
   set_whxy $WIN_ATTR_FILE_SELECTOR
   cat <<END
unbind M-$TBIND_SELECT
bind   M-$TBIND_SELECT if-shell "command -v wfmux" {
   display-popup -w $w          \\
                 -h $h           \\
                 -x $x            \\
                 -y $y             \\
                 -E "/home/kueppo/projects/wfmux/src/wfmux select"
}
END

   set_whxy $WIN_ATTR_OTHERS
   cat <<END
unbind M-$TBIND_EXPLORE
bind   M-$TBIND_EXPLORE if-shell "command -v wfmux" {
   display-popup -w $w           \\
                 -h $h            \\
                 -x $x             \\
                 -y $y              \\
                 -E "wfmux explore"
}

unbind M-$TBIND_OPS
bind   M-$TBIND_OPS if-shell "command -v wfmux" {
   display-popup -w $w       \\
                 -h $h        \\
                 -x $x         \\
                 -y $y          \\
                 -E "wfmux ops"
}
END
}

opt_wfmux_dump () { dump_config; }
opt_wfmux_tmux () { dump_config >>"$TMUX_CONF"; }

get_project_dir () {
   test -z "$1" && return

   session_name=$1
   project_name=$(printf "$session_name" | sed -ne 's/^\([^-]\+\)-.\{6\}$/\1/p')
   test -z "$project_name" && return

   OIFS=$IFS IFS='
'
   for dir in $PROJECT_DIRS ; do
      project_dir="$dir/$project_name"

      test -d "$project_dir"       \
         && test -x "$project_dir"  \
         && cd -L "$project_dir"     \
         || continue

      if test -f ".wfmux/name" \
      && test $session_name = "$(cat .wfmux/name)" ; then
         printf "$project_dir\n"
      fi
   done

   IFS=$OIFS
}

tmux_or_die () {
   test -n "${TMUX:-}" || die "Wfmux must run in a tmux session"
}

opt_wfmux_switch () {
   tmux_or_die

   wfmux_sessions= IFS='
'
   for session in `tmux list-sessions -F '#S'` ; do
      test -z "$(get_project_dir "$session")" && continue
      wfmux_sessions="${wfmux_sessions}${session}\n"
   done

   test -z "$wfmux_sessions" && return
   session=$(printf "$wfmux_sessions" | eval "$MENU")

   if test -n "$session" ; then
      tmux switch-client -c "$(tmux_cur_pty)" -t "$session"
   fi
}

## Open tui file manager
opt_wfmux_explore () {
   tmux_or_die

   project_dir=`get_project_dir "$(tmux_cur_session)"`

   test -z "$project_dir"   \
      && not_wfmux_session   \
      || eval "$FILE_MANAGER" "$project_dir"
}

get_project_files () {
   ignore=
   project_dir=$1

   if test -s .wfmux/ignore ; then
      IFS='
'
      for pattern in `cat .wfmux/ignore` ; do
         ignore="${ignore}${ignore:+ -or}"
         ignore="${ignore} -name '${pattern}'"
      done
   fi

   if test -n "$ignore" ; then
      eval find . '\(' "$ignore" '\)' -prune -or -type f -print
   else
      find . -type f -print
   fi
}

get_filetype () {
   file=$1

   if command -v xdg-mime >/dev/null ; then
      filetype=$(xdg-mime query filetype "$file")
   elif command -v file >/dev/null ; then
      filetype=$(file --mime-type "$file")
      filetype=${filetype##*: }
   else
      tmux-message "'$file': Couldn't determine the file type"
      return
   fi

   expr "$filetype" : application >/dev/null  \
      && filetype=${filetype##*/}              \
      || filetype=${filetype%%/*}

   printf "$filetype"
}

nohup () {
   { trap '' HUP; eval "$@"; } &
}

## Open a project file
opt_wfmux_open () {
   tmux_or_die

   project_dir=`get_project_dir "$(tmux_cur_session)"`

   test -z "$project_dir" && {
      not_wfmux_session
      return 1
   }

   cd -L "$project_dir"

   files=$(get_project_files "$project_dir" | eval "$MENU")
   IFS='
'
   for file in $files ; do

      if test "$USE_XDG_OPEN" = true ; then

         command -v xdg-open >/dev/null || {
            tmux_message "xdg-utils package not installed"
            tmux display-popup -C
            exit 1
         }

         cmd="xdg-open '$file'"
      else
         filetype=`get_filetype "$file"`
         test -z "$filetype" && continue

         data=$(printf '%s' "$PROGRAMS" | grep "^tty=\(true\|false\),$filetype=" | head -n1)

         test -z "$data" && {
            tmux_message "Unable to open '$file'"
            continue
         }

         use_tty=${data%,$filetype=*}
         use_tty=${use_tty#tty=}

         cmd=${data#*,$filetype=}
         cmd=$(printf "$cmd" "$file")

         bin=${cmd%% *}
         command -v "$bin" >/dev/null || {
            tmux_message "Unable to open '$file', $bin: not found"
            continue
         }
      fi

      wfmux_run_cmd "$cmd" $use_tty
   done
}

wfmux_run_cmd () {
   cmd=$1
   use_tty=$2

   test $use_tty = true || {
      nohup "$cmd" >/dev/null 2>&1
      return 0
   }

   test -n "${SHELL:-}" || {
      tmux_message '$SHELL not defined'
      tmux display-popup -C
      return 0
   }

   panes=$(tmux list-panes -F '#{pane_current_command}:#P:#{pane_active}')

   # If possible, run the command in an idle pane.
   idle_panes=$(printf '%s' "$panes" | grep "^${SHELL##*/}:")

   if test -n "$idle_panes" ; then

      target=$(printf '%s' "$idle_panes" | grep ':1$')
      target=${target%:1}

      test -z "$target" && {
         target=$(printf '%s' "$idle_panes" | sort -t: -k1,1n | head -n1)
         target=${target%:0}
      }

      target=${target##*:}
      tmux send-keys -t "$target" "$cmd" C-m

   # Spawn off a new pane in the current window if there's only one pane
   # and that pane it's busy.
   elif test $(printf '%s' "$panes" | wc -l) -eq 0 ; then

      tmux split-window -h "$cmd"

   # In the worst case, run it in a new window.
   else
      tmux new-window "$cmd"
   fi

   return 0
}

is_git_repository () {
   git rev-parse --show-toplevel >/dev/null 2>&1 || {
      tmux_message "The project isn't a git repository"
      tmux display-popup -C
      return 1
   }
}

not_wfmux_session () {
   tmux_message "This is not a wfmux tmux session"
   tmux display-popup -C
}

requires () {
   for cmd in "$@" ; do
      command -v "$cmd" >/dev/null || {
         tmux_message "$cmd: Command not found"
         return 1
      }
   done
}

has () {
   command -v "$1" >/dev/null
}

wfmux_commit () {
   tmux_or_die

   requires git || return

   project_dir=`get_project_dir "$(tmux_cur_session)"`

   test -z "$project_dir"   \
      && not_wfmux_session   \
      && return 1

   cd -L "$project_dir"

   is_git_repository || return

   if test -z "${EDITOR:-}" ; then
      tmux_message 'Undefined $EDITOR'
      tmux display-popup -C
      return
   fi

   command -v "$EDITOR" >/dev/null || {
      tmux_message "$EDITOR: Command not found"
      tmux display-popup -C
      return
   }

   gstatus=$(git status --ignore-submodules --porcelain | sed -e 's/^ //;s/^??/U/;s/^\(.\)  /\1 /')

   test -z "$gstatus"  \
      && test $# -eq 0  \
      && {
      tmux_message "Nothing to commit, working tree clean"
      tmux display-popup -C
      return
   }

   gstatus=$(printf '%s' "$gstatus" | eval "$MENU")

   test -z "$gstatus"  \
      && test $# -eq 0  \
      && {
      tmux display-popup -C
      return
   }

   IFS='
'
   for change in $gstatus ; do
      file=${change#? }
      ctype=${change%% *}

      test $ctype != M       \
         && test $ctype != U  \
         && continue

      git add "$file" 2>/dev/null || {
         tmux_message "$file: Couldn't add file to the index"
         tmux display-popup -C
         return 1
      }
   done

   git commit "$@"
}

opt_wfmux_commit () {
   wfmux_commit || tmux-message "Unable to commit"
}

opt_wfmux_acommit () {
   wfmux_commit --amend || tmux-message "Unable to amend"
}

git_branches () {
   IFS='
'
   for lbranch in `git branch --list --no-color` ; do
      test x"${lbranch% *}" = x'*' && continue

      lbranch=${lbranch#  }
      rbranch=$(git rev-parse --abbrev-ref "$lbranch@{u}" 2>/dev/null)

      test $? -eq 0                                     \
         && printf 'L %s -> %s\n' "$lbranch" "$rbranch"  \
         || printf 'L %s\n'       "$lbranch"
   done

   git branch --remote --no-color | tail -n +2 | sed -e 's/^ */R /'
}

wfmux_new_branch () {
   rbranch=$1
   lbranch=${rbranch##*/}

   git show-ref --verify --quiet refs/heads/$lbranch && {

      printf '%s: Branch already exists\n' "$branch"
      printf 'New name (y/n)? '
      read input
      test "$input" != y && return

      printf ': '
      read lbranch
      test -z "$lbranch" && return

      git check-ref-format --branch "$lbranch" >/dev/null
      test $? -ne 0 && return 1
   }

   git checkout -b "$lbranch" --track "$rbranch"
}

wfmux_checkout () {
   tmux_or_die

   requires git || return

   project_dir=`get_project_dir "$(tmux_cur_session)"`

   test -z "$project_dir"   \
      && not_wfmux_session   \
      && return 1

   cd -L "$project_dir"

   is_git_repository || return

   test "${1:-}" = '--clean-worktree'                           \
     && test -z "$(git status --ignore-submodules --porcelain)"  \
     && {
      tmux_message "Still have local changes to be commited"
      return 1
   }

   branch=`git_branches | eval "$MENU"`
   test -z "$branch" && return

   btype=${branch%% *}
   branch=${branch#? }
   branch=${branch%% *}

   if test $btype = L ; then
      git checkout "$branch" >/dev/null
   else
      wfmux_new_branch "$branch" #>/dev/null
   fi

   test $? -eq 0 && tmux_message "Switched to '$branch'"

   input_2_quit
   tmux display-popup -C
}

opt_wfmux_checkout  () { wfmux_checkout --clean-worktree; }
opt_wfmux_fcheckout () { wfmux_checkout;                  }

opt_wfmux_cbranch () {
   tmux_or_die

   requires git || return

   project_dir=`get_project_dir "$(tmux_cur_session)"`

   test -z "$project_dir"   \
      && not_wfmux_session   \
      && return 1

   cd -L "$project_dir"

   is_git_repository || return

   tmux_message "$(git branch --show-current)"
   tmux display-popup -C
}

input_2_quit () {
   init_stty=`stty -g`

   printf '\nInput anything to quit!'
   stty -echo -cooked && dd if=/dev/tty count=1 bs=1 >/dev/null 2>&1
   stty "$init_stty"
   printf '\n'
}

wfmux_push () {
   :;
}

opt_wfmux_push ()  { wfmux_push; }
opt_wfmux_fpush () { wfmux_push --force; }

opt_push  () { __push;         }
opt_fpush () { __push --force; }

__push () {
   { command -v git    || return
     command -v "$TOK" || return
   } >/dev/null

   project_dir=`__get_project_dir`
   test -n "$project_dir" && project_name=$(basename "$project_dir")

   if [ -n "$project_name" ] ; then
      cd "$project_dir"
      if [ $? -eq 0 ] ; then
         username=
         remotes=$(printf "$WFMUX_REMOTE" | eval "$MENU")
         session_path="$SESSION_DIR/$(tmux_cur_session)"

         if [ -s "$session_path/user" ]
         then
            username=$(cat "$session_path/user")
         else
            username=$(printf "$WFMUX_USERS" | eval "$MENU")
            printf "$username" >"$session_path/user"
         fi

         if [ -n "$remotes" ]; then
            force=${1:---force}
            proto=https
            branch=$(git branch | sed -ne 's|^\* \(.\+\)|\1|p')
            git_config=$(cat .git/config)

            printf "%s\n" "$remotes" | while read remote ; do
               my_tok=$(eval "$TOK '${remote%%.*}'")

               case $remote in
                  codeberg.org|github.com|github.com) proto=https ;;
                  *) proto=https ;;
               esac
               test "$remote" = "gitlab.com" && my_tok="$GITLAB_TOK_NAME:$my_tok"

               printf "Pushing to $remote/$username  ";
               {
                  i=0
                  set -- − \\ \| /
                  while true; do 
                     sleep 0.2
                     i=$(($i+1))
                     eval "printf \"\b\$$(($(($i%4))+1))\""
                  done
               } &

               local failed=No
               git push "$force" --set-upstream "$proto://$my_tok@$remote/$username/$project_name.git" "$branch" >/dev/null 2>&1 || failed=Yes
               kill -KILL $!

               test x"$failed" = x"Yes" && c="${ESC_RED}Failed" || c="${SUCCESS}Done"
               printf "\b$c$ESC_UNSET_ANSI\n"
            done

            # To avoid saving tokens!
            printf "$git_config" > .git/config
            __input_to_exit
         fi
      fi
   fi
}

start_watcher () {
   project_session=$2 one_shot=${1%%(*} cmd=${1#?(*)} watcher_name=${1%%)*}

   watcher_name=${1#?(}

   # You will be seeing the std(out|err) of watchers via named-pipes
   local fifo="$project_session/fifos/$watcher_name.fifo"

   test -p "$fifo" || mkfifo "$fifo"
   { 
      trap '' HUP
      if [ $one_shot = 1 ] ; then
         # for self restarting programs(e.g framework developement server)
         eval "$cmd"
      else
         cat "$project_session/watch" \
         | sed -ne "/^s+0\[$watcher_name\]:/,/^e\[$watcher_name\]/p" \
         | tail -n +2 \
         | sed '$d' \
         | case $WATCHER in
            entr) entr -nr "$cmd" ;;
            *) : ;;
           esac >"$fifo"
      fi
   } >"$fifo" 2>&1 &

   printf "$!" >"$project_session/$watcher_name.pid"
}

# Add a new watcher to the watcher list
opt_awatcher () {
   watcher_name=
   watch_config="$SESSION_DIR/`tmux_cur_session`/watch"
   project_dir=`__get_project_dir`

   printf "Give a name to your watcher: "
   read watcher_name

   printf "One shot(Y/n)? "
   read one_shot

   if [ -n "$watcher_name" ] ; then
      # Check if this name already exists in the watcher list
      test -f "$watch_config" && cat "$watch_config" | grep -q "^s[-+][01]:\[$watcher_name\]" && return

      __get_files() {
         local args=$(printf "$IGNORE" | sed -e '${ s/\(.*\)/-name "\1"/; q; };1,${ s/\(.*\)/-name "\1" -or /; }' | tr '\n' ' ')
          eval "find '$project_dir' \( $args \) -prune -or -type f -print | sed -e 's,^$project_dir/,,' | $MENU"
      }

      files=`__get_files`
      if [ -n "$files" ]; then
         printf "$ESC_UNDERLINE"

         if [ -r "$COMMANDS" ]; then
            case $one_shot in
            y | Y)
               local cmd=$(cat "$COMMANDS" | grep -v '^[\t ]*\(#.*\)\?$' | eval "$MENU")
               cat <<EOF
s+0[$watcher_name]: $cmd
$files
e[$watcher_name]
EOF
               ;;
            *)
               cat <<-EOF
s+1[$watcher_name]: $cmd
e[$watcher_name]
EOF
               ;;
            esac >>"$watch_config"
            printf "$SUCCESS"
            printf "'$watcher_name' was successfully added to the list of watchers\n"
         else
            printf "$ESC_RED"
            printf "Could not find the list of commands.\n" >&2
            printf "these commands should be located at '$COMMANDS'\n" >&2
         fi
         printf "${ESC_UNSET_ANSI}${ESC_UNSET_ANSI}"

         __input_to_exit
      fi
   fi
}

# remove watchers from the watcher list
opt_rwatcher () {
   cur_session=`tmux_cur_session`
   [ -z "$cur_session" ] && return

   project_session="$SESSION_DIR/$cur_session"
   watch_config="$project_session/watch"

   test -r "$watch_config" -a -s "$watch_config" || return

   watcher_names=$(cat "$watch_config" | sed -ne 's/^s[-+]\[\(\w*\)\]:.*$/\1/p')
   if [ -n "$watcher_names" ]; then
      watcher_name=$(printf "$watcher_names" | eval "$MENU")

      if [ -n "$watcher_name" ]; then
         printf "$ESC_UNDERLINE"
         cat "$watch_config" | grep -q "^e\[$watcher_name\]"

         if [ $? -eq 0 ]; then
            sed -i "/^s..\[$watcher_name\]:/,/^e\[$watcher_name\]/d" "$watch_config"
            if [ $? -eq 0 ]; then
               if [ -r "$project_session/fifos/$watcher_name.pid" ] ; then
                  pid=$(cat "$project_session/fifos/$watcher_name.pid")
                  kill -KILL "$pid" >/dev/null 2>&1
               fi
               printf "$SUCCESS"
               printf "Watcher '$watcher_name' successfully deleted\n"
            else
               printf "$ESC_RED"
               printf "Could not delete watcher\n"
            fi
         else
            printf "$ESC_RED"
            printf "could not find scope of definition of '$watcher_name'\n"
         fi
         printf "${ESC_UNSET_ANSI}${ESC_UNSET_ANSI}"
      fi
   else
      printf "you do not have any watcher\n"
   fi

   __input_to_exit
}

__ed_watcher () {
   watch_config="$1/watch"

   if [ -r "$watch_config" -a -s "$watch_config" ] ; then
      watcher_names=$(cat "$watch_config" | sed -ne 's/^s[-+][01]\[\(\w*\)\]:.*$/\1/p')

      if [ -n "$watcher_names" ] ; then
         watcher_name=$(printf "$watcher_names" | eval "$MENU")
         if [ -n "$watcher_name" ] ; then
            sed -ie "s/^s.\(.\[$watcher_name\]\)/^s$2\1/" "$watch_config"
         fi
      else
         printf "No watcher were found\n"
      fi
   fi
}

# Enable watchers, should be runned within an existing wfmux tmux session.
# This operation sets on watchers to be runned upon session startup.
opt_ewatcher () {
   cur_session=`tmux_cur_session`
   project_session="$SESSION_DIR/$cur_session"
   watch_file="$project_session/watch"

   [ -z "$cur_session" ] && return

   printf "$ESC_UNDERLINE"

   watcher_name=$(__ed_watcher "$watch_file" +)
   if [ $? -eq 0 ] ; then
      pid_file="$project_session/fifos/$watcher_name.pid"

      if ! test -s "$pid_file" ||
         ! ps a | grep -q "^[\t ]\+$(cat "$pid_file")" ; then
         pairs=$(cat "$watch_file" | sed -ne 's/^s+\(.\)\[\(.*\)\]: *\(.\+\) *$/\1(\2)\3/p')
         __start_watcher "$pairs" "$project_session"
      fi

      printf "$SUCCESS"
      printf "Watcher '$watcher_name' enabled.\n"
      printf "${ESC_UNSET_ANSI}${ESC_UNSET_ANSI}"
   else
      printf "$ESC_RED"
      printf "Could not enable watcher '$watcher_name'\n"
   fi
   printf "${ESC_UNSET_ANSI}${ESC_UNSET_ANSI}"

   __input_to_exit
}

# Disable watchers, should be runned within an existing wfmux tmux session.
# This operation sets off watchers so that they cannot run when a new wfmux
# tmux session is initiated either via `opt_open' or `opt_nsession'
opt_rwatchers () {
   cur_session=`tmux_cur_session`
   project_session="$SESSION_DIR/$cur_session"
   watch_file="$project_session/watch"

   [ -z "$cur_session" ] && return

   printf "$ESC_UNDERLINE"

   watcher_name=$(__ed_watcher "$watch_file" -)
   if [ $? -eq 0 ] ; then
      printf "$SUCCESS"
      printf "Watcher '$watcher_name' disabled.\n"
      printf "${ESC_UNSET_ANSI}${ESC_UNSET_ANSI}"
   else
      printf "$ESC_RED"
      printf "Could not disable watcher '$watcher_name'\n"
   fi
   printf "${ESC_UNSET_ANSI}${ESC_UNSET_ANSI}"

   __input_to_exit
}

# Fancy view of all watchers belonging to the project
# Definition of the view
#             --[ project_name ]--
#    PID:          not running(red), running($COLOR)
#    WATCHER_NAME: disable(red), enabled($COLOR)
#    o/m         : o, not monitored by $runner otherwise m
#
#    WATCHER_NAME   PID    o/m  COMMAND
#    watcher_name_1 pid_1  o    command_1
#    watcher_name_2 pid_2  m    command_2
#    watcher_name_3 pid_3  m    command_3
opt_view () {
   i= j= project_name=`__get_project_dir` project_session=`tmux_cur_session`

   test -z "$project_name" && return
   project_name=`basename "$project_name"`

   printf "${ESC_UNDERLINE}${SUCCESS}${project_name}${ESC_UNSET_ANSI}${ESC_UNSET_ANSI}\n"
   printf "${ESC_BOLD}PID${ESC_UNSET_ANSI}:          shotdown(${ESC_RED}red${ESC_UNSET_ANSI}), running(${SUCCESS}this color${ESC_UNSET_ANSI})\n"
   printf "${ESC_BOLD}WATCHER_NAME${ESC_UNSET_ANSI}: disable(${ESC_RED}red${ESC_UNSET_ANSI}), enabled(${SUCCESS}this color${ESC_UNSET_ANSI})\n"
   printf "${ESC_BOLD}O/M${ESC_UNSET_ANSI}         : ${ESC_BOLD}O${ESC_UNSET_ANSI} = oneshot, ${ESC_BOLD}M${ESC_UNSET_ANSI} = not oneshot\n\n"

   watcher_file="$SESSION_DIR/$project_session/watch"
   while read watcher ; do
      watcher=$(printf "$watcher" | sed -ne "s///p")
      _name=$(printf "$watcher" | awk 'BEGIN{RS="";FS="\n"};{print $1}')
      pid_file="$SESSION_DIR/$project_session/$_name/pid"
      test -s "$pid_file" && _pid=$(cat "$pid_file") || _pid=X
   
      test ${#pid}  -gt $j && j=${#pid}
      test ${#name} -gt $i && i=${#name}

      pid=${pid}${pid:+"\n"}$_pid
      name=${name}${name:+"\n"}$_name
      stat=${stat}${stat:+"\n"}$(printf "$watcher" | awk 'BEGIN{RS="";FS="\n"};{print $2}')
      shot=${shot}${shot:+"\n"}$(printf "$watcher" | awk 'BEGIN{RS="";FS="\n"};{print $3}')
      comm=${comm}${comm:+"\n"}$(printf "$watcher" | awk 'BEGIN{RS="";FS="\n"};{print $4}')
   done <"$watcher_file"

   printf "%${i}s |%${j}s |%-4s |%s\n" "WATCHER_NAME" "PID" "O/M" "COMMAND"
   printf "%${i}s |%${j}s |%-4s |%s\n" "" "" "" ""

   while [ 1 ] ; do
      test ${#name} -eq 0 && break
      printf "%${i}s |%${j}s |%-4s |%s\n" "$_name" "$_pid" "$_stat" "$_comm"
   done
}

opt_ksession () {
   :;
}

# Cycle through std(out&stderr) of watchers
opt_cycle () {
   cur_session=`tmux_cur_session`
   project_fifos="$SESSION_DIR/$cur_session/fifos"

   watcher_name=
   test -z "$cur_session" && return

   cd "$project_fifo"
   if [ $? -eq 0 ] ; then
      for fifo in * ; do
         watcher_name=${fifo%.fifo}
         if [ -n "$watcher_name" ] ; then
            {
               printf "${SUCCESS}${watcher_name}${ESC_UNSET_ANSI}${ESC_BOLD}\n"
               cat "$fifo"
            } | less --RAW-CONTROL-CHARS
            printf "$ESC_UNSET_ANSI"
         fi
      done
   fi
}

load_plugins () { :; }

# Wrap all operations, plugins appear here
opt_ops () {
   test -z "${TMUX:-}" && return

   opt_name=$(printf "$WFMUX_OPS" | eval "$MENU")
   test -z "$opt_name" && return

   {
      trap '' HUP
      case $ops in
      select)
         set_whxy $WIN_ATTR_FILE_SELECTOR
         ;;
      *)
         set_whxy $WIN_ATTR_OTHERS
         ;;
      esac
      tmux display-popup -w $w -h $h -x $x -y $y -E "/home/kueppo/projects/wfmux/src/wfmux $ops"
   } &

   tmux display-popup -C
}

main "$@"
