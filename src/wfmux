#!/bin/bash

#set -x
set -u

readonly ESC_ALT_SCREEN='\033[?1049h'
readonly ESC_NORMAL_SCREEN='\033[?1049l'
readonly ESC_HIDE_CUR='\033[?25l'
readonly ESC_SHOW_CUR='\033[?25h'
readonly ESC_CLEAR_SCREEN='\033[2J'
readonly ESC_BOLD='\033[1m'
readonly ESC_UNDERLINE='\033[4m'
readonly ESC_RED='\033[31m'
readonly ESC_UNSET_ANSI='\033[0m'

readonly CONF_DIR="${XDG_CONFIG_HOME:-"$HOME/.config"}"
readonly WFMUX_CONF_DIR="${CONF_DIR%%/}/wfmux"
readonly WFMUX_PLUG_DIR="$WFMUX_CONF_DIR/plugins"
readonly TMUX_CONF="$HOME/.tmux.conf"

# Shell running command from `tmux display-pop' does not seem 
# to have sourced profiles.
readonly LOCAL_BIN="$HOME/.local/bin"

# Some watcher commands frequently used in some projects.
readonly WATCHER_TEMPLATES="$WFMUX_CONF_DIR/watchers"

readonly NL="$(printf '\n_')"
readonly NUM_RE='[0-9]\|[1-9][0-9]\+'

mkdir -p "$WFMUX_CONF_DIR"

# Large size
readonly WFMUX_LS=$(cat <<END
                                ┌────────────
                                │
                                │                                            ┌───────
                                │                             ┌───┐          │
            ┌──┐                │                             │   │          │
            │  │                │                             │   │          │
            │  │           ┌────┼─────┬─────┬──────┬──┐       │   │    ┌─────┘
            │  │     ┌─    │    │     │     │      │  │       │   │    │
────────────┘  │     │     │    │     │     │      │  │       │   └────┼─────┐
               │     │     │    │     │     │      │  │       │        │     │
               │     │     │    │     │     └────  │  └───────┘        │     │
               ├─────┴─────┘    │     │            └──                 │     │
               │                │    ─┘                                │     │
               │                │            ──────────────────────────┘     │
               │                └─                                           │
         ──────┘                                                             │
                                                                             │
END
)

# Medium size
readonly WFMUX_MS=$(cat <<END
                     ┌─────────                      ┌───
                     │                               │
        ┌─┐          │                     ┌──┐      │
        │ │       ┌──┼───┬───┬───┬───┐     │  │  ┌───┘
        │ │   ┌─  │  │   │   │   │   │     │  │  │
────────┘ │   │   │  │   │   │   │   │     │  └──┼───┐
          │   │   │  │   │   └─  │   │     │     │   │
          ├───┴───┘  │  ─┘       │   └─────┘     │   │
          │          └─          └──             │   │
          │                  ────────────────────┘   │
     ─────┘                                          │
                                                     │
END
)

# Small size
readonly WFMUX_SS='WFMUX'

readonly WFMUX=$(cat<<END

     ┌──────────────┤ WFMUX
    ┌┴────────────────────────────────────────┐
    │                                         │
    ├─ Input a name for a new tmux session    │
    ├─ Input f⟨return⟩ to select a project    │
    ├─ Input ⟨return⟩ to drop to the terminal │
    │                                         │
    └─────────────────────────────────────────┘
END
)

WFMUX_CONF="$WFMUX_CONF_DIR/wfmux.conf"
WFMUX_OPS=$(cat <<END
new
tmux
dump
open
explore
shell
nsession
switch
log
commit
acommit
push
fpush
checkout
fcheckout
cbranch
view
awatch
rwatch
mwatch
ewatch
dwatch
vwatch
cwatch
sawatch
sowatch
ops
END
)

# Default configuration if external config file does not exist
COLOR=4
SUCCESS="\033[1;3${COLOR}m"

WATCHER='entr'
FILE_MANAGER='lf'

WIN_ATT_OPT='20x20+10+20'

TBIND_OPEN='Enter'
TBIND_EXPLORE='BSpace'
TBIND_OPS='i'
TBIND_SWITCH='w'

MENU='fzf --multi --margin=25%'

PROJ_DIRS=$(cat <<END
$HOME/projects
$HOME/oprojects
END
)

USE_XDG_OPEN=false

PROGRAMS=$(cat <<END
tty=true,text=vim '%s'
tty=true,directory=lf '%s'
tty=false,video=ffplay -hide_banner -loop 0 '%s'
tty=true,audio=ffplay  -hide_banner -loop 0 -nodisp '%s'
tty=false,pdf=zathura '%s'
tty=false,image=feh '%s'
END
)

usage () {
   cat <<END
Build an awesome dev workflow using tmux, fzf, lf, entr and more.

Usage: wfmux [ -h | --help ]
       wfmux [ ( -c | --conf ) CONF ] OPT
       
Options:
     -h, --help         print this help message.
     -c, --conf CONF    load CONF configuration file.

OPT:
    new          Select a project, create and attach a new tmux session
                 for it. A project with an already existing tmux session
                 has that session reused.
    dump         Dump to the stdout the tmux configuration of wfmux.
    tmux         Update the tmux configuration of wfmux at ~/.tmux.conf.
    open         Select a project file to open.
    explore      In a popup tmux pane, open at the project directory the
                 configured TUI file manager.
    shell        Launch the shell on a popup tmux pane.
    nsession     Just like \`new' but does not show the already existing
                 tmux session.
    switch       Switch between different wfmux tmux sessions.

    log          View the git logs of the current project.
    commit       Select changes of the current project and commit them.
    acommit      If the working tree is clean, simply run a git amend
                 command; otherwise select changes and add them to the
                 index before running a git amend command.
    push         Push changes to the configured remote repositories if
                 any.
    fpush        Force push to the remote repository, the default push
                 wfmux operation refuses to update a remote ref that is
                 not an ancestor of the local ref used to overwrite it.

    checkout     Switch to a branch in your project.
    fcheckout    Force the checkout since the above fails if the working
                 tree is not clean.

    cbranch      Show in tmux the name of the current branch of your
                 project.

    awatch       Create a watcher and add it to the watcher registry of
                 the current project.
    rwatch       Selected a watcher from the watcher registry to delete
                 from that registry.
    mwatch       Modify the attributes of a watcher from the watcher
                 registry.
    ewatch       Enable a watcher from the watcher registry, enabled
                 watchers of a project will be started at the creation
                 of that project's tmux session.
    dwatch       Disable a watcher from the watcher registry.
    vwatch       View the stdout of a running watcher.
    cwatch       Cycle through the standard output of all the running
                 watchers of the current project.
    sawatch      Launch a watcher from the watcher registry of the
                 current project.
    sowatch      Stop a running watcher launched from the watcher
                 registry of the current project.

    vtop         View the characteristics of all registered watchers.
    ops          A wfmux operation to call other wfmux operations whether
                 built-in or gotten via wfmux plugins.
END

   exit "$1"
}

die () {
   say "$0: $*." >&2
   exit 1
}

main () {
   opt_name=

   test $# -eq 0 && usage 1
   while test $# -ne 0 ; do
      case "$1" in
      -h|--help)
         usage 0
         ;;
      -c|--conf)
         test $# -gt 2 || usage 1
         test -e "$2"  || die "Conf file '$2' does not exist"
         WFMUX_CONF=$2
         shift
         ;;
      -*)
         die "Unknown option '$1', please try \`$0 --help'"
         ;;
      *)
         test -n "$opt_name" && usage 1
         say "$WFMUX_OPS" | grep -xqF "$1"

         test $? -ne 0 && {
            emsg="'$1' is an unknown wfmux operation"

            test -n "${TMUX:-}" && tmux_message "$emsg"
            die "$emsg"
         }
         opt_name="$1"
         ;;
      esac
      shift
   done

   test -f "$WFMUX_CONF" && {
      test -r "$WFMUX_CONF" || die "No permission to read '$WFMUX_CONF'"
      . "$WFMUX_CONF"       || die "Non-zero exit status when sourcing config"
   }

   check_conf_vars
   eval "opt_wfmux_$opt_name"
}

die_conf () {
   test -z "${TMUX:-}"                   \
      && die "('$WFMUX_CONF'): $*"        \
      || wfmux_die "('$WFMUX_CONF'): $*."
}

check_conf_vars () {
   var=''
   is_set=''

   v_err () {
      die_conf "Invalid value assigned to '$1'"
   }

   # Check it all here though they aren't all used in a single wfmux opt
   for var in USE_XDG_OPEN MENU WIN_ATT_OPT PROJ_DIRS   \
              FILE_MANAGER WATCHER TBIND_OPS TBIND_OPEN  \
              TBIND_EXPLORE TBIND_SWITCH ; do

      eval 'is_set=${'$var':+true}'
      test -z "$is_set" && die_conf "'$var' isn't defined"
   done

   # Check if we've got sane values
   expr "$COLOR" : '[0-9]$' >/dev/null || v_err COLOR

   test "$USE_XDG_OPEN" = true        \
      || test "$USE_XDG_OPEN" = false  \
      || v_err USE_XDG_OPEN

   # MENU is used by most wfmux opt, so check it here!
   menu="${MENU%% *}"
   command -v "$menu" >/dev/null  \
      || die_conf '$'"MENU: '$menu': Command not found"

   proj_dirs=
   O_IFS=$IFS IFS=${NL%?}

   # This variable is used by all wfmux opts
   for path in $PROJ_DIRS ; do
      rpath=$(realpath -e "$path" 2>/dev/null)

      test $? -eq 0    || die_conf "'$path' does not exist"
      test -d "$rpath" || die_conf "'$rpath' is not a directory"
      test -r "$rpath" || die_conf "cannot list contents of '$rpath'"

      proj_dirs="$proj_dirs${proj_dirs:+${NL%?}}$rpath"
   done

   IFS=$O_IFS
   PROJ_DIRS=$(printf '%s' "$proj_dirs")
}

display_dashboard () {
   awk_max='
      BEGIN { len = 0 }
      {
         nlen = length($0)
         if (nlen > len)
            len = nlen
      }
      END { print len }
   '

   # Dashboard message, explains how to use wfmux on tmux.
   dashboard_msg () {
      cat <<END
The following are tmux bindings related to wfmux.

M-$TBIND_SELECT: fuzzyly open project files
M-$TBIND_EXPLORE: open file manager
M-$TBIND_OPS: fuzzyly select other wfmux operations

input any key to exit dashboard
END
   }

   tty_print () {
      printf '\033[%d;%df%s' "$1" "$2" "$3" >/dev/tty
   }

   # Save initial terminal setting, will set back after exiting dashboard
   init_stty=$(stty -g)
   stty -cooked -echo time 0 min 1
   printf "${ESC_ALT_SCREEN}${ESC_HIDE_CUR}${ESC_CLEAR_SCREEN}"

   {
      term_h= term_w=
      while true ; do

         new_size=$(stty -F /dev/tty size)
         test "$new_size" = "$term_h $term_w" && {
            sleep 1
            continue
         }

         term_h=$(say "$new_size" | cut -d' ' -f1)
         term_w=$(say "$new_size" | cut -d' ' -f2)
         if   test "$term_h" -lt 32 || test "$term_w" -lt 97 ; then
            _size=SS
         elif test "$term_h" -lt 43 || test "$term_w" -lt 155 ; then
            _size=MS
         else
            _size=LS
         fi
         eval 'wfmux_h=$(printf "$WFMUX_'$_size'" | wc -l)
               wfmux_w=$(printf "$WFMUX_'$_size'" | awk "$awk_max")'

         wfmux_h=$(expr "$wfmux_h" + $(dashboard_msg | wc -l))

         x=$((($term_w - $wfmux_w) / 2))
         y=$((($term_h - $wfmux_h) / 2))

         msg_w=$(dashboard_msg | awk "$awk_max")
         if test $msg_w -gt $wfmux_w ; then
            msg_x=$(($x - ($msg_w - $wfmux_w) / 2))
         else
            msg_x=$(($x + ($wfmux_w - $msg_w) / 2))
         fi

         printf "${ESC_CLEAR_SCREEN}${SUCCESS}${ESC_BOLD}"

         IFS=${NL%?}
         for line in $(eval 'printf "$WFMUX_'$_size'"') ; do
            tty_print $y $x "$line"
            y=$(($y + 1))
         done

         printf "$ESC_UNSET_ANSI"
         for line in $(dashboard_msg) ; do
            y=$(($y + 1))
            tty_print "$y" "$msg_x" "$line"
         done
      done
   } &

   # Get key from the standard input
   dd if=/dev/tty count=1 bs=1 >/dev/null 2>&1

   kill -KILL $! || :

   stty "$init_stty"
   printf "$ESC_NORMAL_SCREEN$ESC_UNSET_ANSI$ESC_SHOW_CUR"
   tput clear
}

tmux_cur_session () {
   tmux list-sessions -F '#S:#{session_activity}' | sort -b -t: -k2,2n | tail -n1 | cut -d: -f1
}

tmux_cur_pty () {
   tmux list-clients -F '#S:#{client_tty}' | grep -F "$(tmux_cur_session):" | head -n1 | cut -d: -f2
}

tmux_message () {
   tmux display-message -d 2500 -- "$*."
}

wfmux_die () {
   tmux_message "$*"
   tmux display-popup -C
   exit 1
}

shrink_proj_dirs () {
   sdirs=$PROJ_DIRS

   for n in $(seq $(say "$sdirs" | wc -l)) ; do
      path=$(say "$sdirs" | sed -ne "${n}p")

      # Check if it's already shrinked
      expr "$path" : / >/dev/null || continue

      name=${path#/}
      name=${name%%/*}

      # Check if $path is the only one.
      test $(say "$sdirs" | grep "^/$name/" | wc -l) -eq 1 && continue

      path=${path#/*/}
      sdirs=$(say "$sdirs" | sed -e "s#^/$name/#*/#")

      # Shrink more
      O_IFS=$IFS IFS=/
      for name in $path ; do
         test $(say "$sdirs" | grep "^\*/$name/" | wc -l) -eq 1 && continue

         _sdirs=$(say "$sdirs" | sed -e "s#^\*/$name/#*/#")

         a=$(say "$_sdirs" | sed -e 's/\*/.../')
         b=$(say "$a"      | sort -u)
         test ${#a} -ne ${#b} && break

         sdirs=$_sdirs
      done
      IFS=$O_IFS

      sdirs=$(say "$sdirs" | sed -e 's/\*/.../')
   done

   say "$sdirs"
}

get_proj_list () {
   line=1
   sdirs=$(shrink_proj_dirs)

   IFS=${NL%?}
   for dir in $PROJ_DIRS ; do
      cd "$dir"

      for file in * ; do
         test -d "$file" || continue
         test -x "$file" || continue

         sdir=$(say "$sdirs" | sed -ne "${line}p")
         printf "[%d]:%s/%s\n" $line "$sdir" "$file"
      done

      line=$(($line + 1))
   done
}

new_session () {
   project=$(get_proj_list | eval "$MENU")

   test -z "$project" && return

   line="${project%%]*}"
   line="${line#[}"
   proj_ddir=$(say "$PROJ_DIRS" | sed -ne "${line}p")
   proj_name=$(basename "$project")
   session=$(say "$proj_name" | sed -e 'y/-./__/')
   proj_dir="$proj_ddir/$proj_name"

   cd -L "$proj_dir"

   test -d .git && {
      touch .gitignore
      grep -q -- .wfmux .gitignore || {
         say '.wfmux' >>.gitignore
         git add .gitignore && git commit -m 'Update .gitignore'
      } 
   }

   if test -d .wfmux      \
   && test -x .wfmux       \
   && test -s .wfmux/name   \
   && expr "$(cat .wfmux/name)" : "$session-.\\{6\\}$" >/dev/null ; then
      session=$(cat .wfmux/name)
   else
      rm -rf .wfmux
      mkdir .wfmux
      touch .wfmux/name

      proj_name=$(say "$proj_name" | sed -e 'y/-./__/')
      session=$(mktemp -u $proj_name-XXXXXX)
      printf "$session" >>.wfmux/name
      say './.git' >>.wfmux/ignore
   fi

   if [ -z "${TMUX:-}" ] ; then
      tmux has-session -t "$session" 2>/dev/null || {
         id="${session##*-}"

         start_watcher "$proj_dir" "$id"
         display_dashboard
         tmux new-session -s "$session" -d
      }
      exec tmux attach-session -t "$session"
   else
      pty=$(tmux_cur_pty)
      tmux has-session -t "$session" 2>/dev/null || tmux new-session -s "$session" -d
      exec tmux switch-client -c "$pty" -t "$session"
   fi
}

# Create a new wfmux tmux session while in an existing tmux session
opt_wfmux_nsession () { new_session; }

# Select a project and open a tmux session
opt_wfmux_new () {
   input=
   session=

   if tmux list-sessions >/dev/null 2>&1 ; then
      printf "Choose an existing session to attach\n\n"
      tmux list-sessions | awk '{print "["NR"] "$0}'
   fi

   say "$WFMUX"
   printf '⟩⟩ '
   read input
   tput clear

   test -z "$input" && return

   if test "$input" = f ; then
      new_session
   elif expr "$input" : '\([0-9]\|[1-9][0-9]\+\)$' >/dev/null ; then
      session=$(tmux list-sessions -F '#S' | sed -n "${input}p")
      test -n "$session" && exec tmux attach-session -t "$session"
   else
      exec tmux new-session -s "$input"
   fi
}

set_whxy () {
   name="$1"
   win_att="$2"

   num_re="$NUM_RE"
   com_re='C\|P\|M\|W'

   x_re="\($com_re\|R\|$num_re\)"
   y_re="\($com_re\|S\|$num_re\)"

   size_re="\(\($num_re\)%\?\)"

   c=$(say "$win_att" | sed -ne "s/^${size_re}x${size_re}+${x_re}+${y_re}$/w=\1 h=\3 x=\5 y=\6/p")

   test -z "$c" && die_conf "Invalid value assigned to '$name'"
   eval "$c"
}

dump_conf () {
   set_whxy WIN_ATT_OPT "$WIN_ATT_OPT"

   cat <<END
unbind M-$TBIND_OPEN
bind   M-$TBIND_OPEN display-popup -w $w -h $h -x $x -y $y -E "$LOCAL_BIN/wfmux open"

unbind M-$TBIND_EXPLORE
bind   M-$TBIND_EXPLORE display-popup -w $w -h $h -x $x -y $y -E "$LOCAL_BIN/wfmux explore"

unbind M-$TBIND_OPS
bind   M-$TBIND_OPS display-popup -w $w -h $h -x $x -y $y -E "$LOCAL_BIN/wfmux ops"

unbind M-$TBIND_SWITCH
bind   M-$TBIND_SWITCH display-popup -w $w -h $h -x $x -y $y -E "$LOCAL_BIN/wfmux switch"
END
}

opt_wfmux_dump () { dump_conf; }
opt_wfmux_tmux () { dump_conf >>"$TMUX_CONF"; }

each () {
   for i in "$@" ; do
      say "$i"
   done
}

get_proj_dir () {
   session="$1"
   proj_name=''

   proj_name=$(say "$session" | sed -ne 's/^\([^-]\+\)-.\{6\}$/\1/p')
   test -z "$proj_name" && return

   IFS=${NL%?}
   for dir in $PROJ_DIRS ; do
      proj_dir=$(say "$dir/$proj_name" | tr '_' '?' | sed -e 's/\([^\\]\) /\1\\ /g')

      for proj_dir in $(eval each "$proj_dir") ; do
         test -d "$proj_dir"       \
            && test -x "$proj_dir"  \
            && cd -L "$proj_dir"     \
            || continue

         test -f '.wfmux/name'                        \
            && test "$session" = "$(cat .wfmux/name)"  \
            && say "$proj_dir"
      done
   done
}

tmux_or_die () {
   test -n "${TMUX:-}" || die "Wfmux must run in a tmux session"
}

opt_wfmux_switch () {
   tmux_or_die

   wfmux_sessions=

   IFS=${NL%?}
   for session in $(tmux list-sessions -F '#S') ; do
      test -z "$(get_proj_dir "$session")" && continue
      wfmux_sessions="${wfmux_sessions}${session}\n"
   done

   test -z "$wfmux_sessions" && return
   session=$(printf "$wfmux_sessions" | eval "$MENU")

   if test -n "$session" ; then
      tmux switch-client -c "$(tmux_cur_pty)" -t "$session"
   fi
}

## Open TUI file manager
opt_wfmux_explore () {
   tmux_or_die

   requires "$FILE_MANAGER"

   proj_dir=$(get_proj_dir "$(tmux_cur_session)")

   test -z "$proj_dir"     \
      && die_not_wfmux      \
      || eval "$FILE_MANAGER" "$proj_dir"
}

# Add some checks since this function is exposed as a wfmux API function.
get_proj_files () {
   ignore=''
   dir_opt=''

   test $# -eq 1       \
      || test $# -eq 2  \
      || die "get_proj_files: Invalid number of arguments"

   test "${1#-}" = "$1"         \
      && dir=     proj_dir="$1"  \
      || dir="$1" proj_dir="$2"

   test "$dir" = '-d' && dir_opt='-or -type d'

   cd -L -- "$proj_dir"
   if test -s .wfmux/ignore ; then
      IFS=${NL%?}
      for pattern in $(cat .wfmux/ignore) ; do
         ignore="${ignore}${ignore:+ -or}"
         ignore="${ignore} -path '${pattern}'"
      done
   fi

   if [ -n "$ignore" ] ; then
      eval find . '\(' "$ignore" '\)' -prune -or -type f "$dir_opt"
   else
      eval find . -type f "$dir_opt"
   fi
}

get_filetype () {
   file="$1"

   if command -v xdg-mime >/dev/null ; then
      filetype=$(xdg-mime query filetype "$file")
   elif command -v file >/dev/null ; then
      filetype=$(file --mime-type "$file")
      filetype=${filetype##*: }
   else
      tmux-message "'$file': Couldn't determine the file type"
      return
   fi

   expr "$filetype" : application >/dev/null  \
      && filetype=${filetype##*/}              \
      || filetype=${filetype%%/*}

   printf "$filetype"
}

say () {
   printf '%s\n' "$*"
}

## Open a project file
opt_wfmux_open () {
   tmux_or_die

   test "$USE_XDG_OPEN" = true && requires xdg-open

   proj_dir=$(get_proj_dir "$(tmux_cur_session)")
   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   files=$(get_proj_files "$proj_dir" | eval "$MENU")

   IFS=${NL%?}
   for file in $files ; do

      if test "$USE_XDG_OPEN" = true ; then
         cmd="xdg-open '$file'"
      else
         filetype=$(get_filetype "$file")
         test -z "$filetype" && continue

         data=$(say "$PROGRAMS" | grep "^tty=\(true\|false\),$filetype=" | head -n1)

         test -z "$data" && {
            tmux_message "Unable to open '$file'"
            continue
         }

         use_tty=${data%,$filetype=*}
         use_tty=${use_tty#tty=}

         cmd=${data#*,$filetype=}
         cmd=$(printf "$cmd" "$file")

         bin=${cmd%% *}
         command -v "$bin" >/dev/null || {
            tmux_message "Unable to open '$file', $bin: not found"
            continue
         }
      fi

      run_cmd "$cmd" $use_tty
   done
}

get_shell () {
   sh="${SHELL:-}"

   if test -z "$sh" ; then
      id=$(id -u)
      sh=$(cat '/etc/passwd' | grep "x:$id:")
      sh="${sh##*:}"
   fi
   sh="${sh##*/}"
   say "${sh:-sh}"
}

run_cmd () {
   cmd="$1"
   use_tty="$2"

   test "$use_tty" = true || {
      { trap '' HUP; eval "$cmd"; } &
      return 0
   }

   panes=$(tmux list-panes -F '#{pane_current_command}:#P:#{pane_active}')

   # If possible, run the command in an idle pane.
   sh=$(get_shell)
   idle_panes=$(say "$panes" | grep "^$sh:")

   if test -n "$idle_panes" ; then

      target=$(say "$idle_panes" | grep ':1$')
      target=${target%:1}

      test -z "$target" && {
         target=$(say "$idle_panes" | sort -t: -k1,1n | head -n1)
         target=${target%:0}
      }

      target=${target##*:}
      tmux send-keys -t "$target" "$cmd" C-m

   # Spawn off a new pane in the current window if there's only one pane
   # and that pane is busy.
   elif test $(say "$panes" | wc -l) -eq 1 ; then

      tmux split-window -h "$cmd"

   # In the worst case, run it in a new window.
   else
      tmux new-window "$cmd"
   fi

   return 0
}

opt_wfmux_shell () {
   tmux_or_die

   proj_dir=$(get_proj_dir "$(tmux_cur_session)")
   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"
   exec ${SHELL:-/bin/sh}
}

is_git_repository () {
   git rev-parse --show-toplevel >/dev/null 2>&1 || {
      wfmux_die "This project isn't a git repository"
   }
}

die_not_wfmux () {
   wfmux_die 'This is not a wfmux tmux session'
}

requires () {
   for cmd in "$@" ; do
      command -v "$cmd" >/dev/null \
         || wfmux_die "$cmd: Command not found"
   done
}

has () {
   command -v "$1" >/dev/null
}

opt_wfmux_log () {
   tmux_or_die

   requires git

   proj_dir=$(get_proj_dir "$(tmux_cur_session)")
   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   is_git_repository || return

   git log --graph
   read _
}

git_status () {
   git status --porcelain --ignore-submodules
}

commit () {
   tmux_or_die

   requires git

   proj_dir=$(get_proj_dir "$(tmux_cur_session)")
   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   is_git_repository || return

   export EDITOR="${EDITOR:-vim}"
   command -v "$EDITOR" >/dev/null || wfmux_die "$EDITOR: Command not found"

   gstatus=$(git_status | sed -e 's/^ /-/;s/^??/-U/;s/^\(.\)  /\1 /')

   test -z "$gstatus"  \
      && test $# -eq 0  \
      && wfmux_die 'Nothing to commit, working tree clean'

   test -n "$gstatus" && gstatus=$(say "$gstatus" | eval "$MENU")

   test -z "$gstatus"  \
      && test $# -eq 0  \
      && {
      tmux display-popup -C
      return
   }

   IFS=${NL%?}
   for change in $gstatus ; do
      file=${change#* }
      ctype=${change%% *}

      test "${ctype%?}" != '-' && continue

      ctype=${ctype#?}
      test "$ctype" != M       \
         && test "$ctype" != U  \
         && continue

      git add "$file" 2>/dev/null || wfmux_die "'$file' Couldn't be added to the index"
   done

   git commit "$@"
}

opt_wfmux_commit () {
   commit || tmux_message "Unable to commit"
}

opt_wfmux_acommit () {
   commit --amend || tmux_message "Unable to amend"
}

git_branches () {
   IFS=${NL%?}

   for lbranch in $(git branch --list --no-color) ; do
      test "${lbranch% *}" = '*' && continue

      lbranch=${lbranch#  }
      rbranch=$(git rev-parse --abbrev-ref "$lbranch@{u}" 2>/dev/null)

      if test $? -eq 0 ; then
         printf 'L %s -> %s\n' "$lbranch" "$rbranch"
      else
         printf 'L %s\n' "$lbranch"
      fi
   done

   git branch --remote --no-color | sed -ne '2,$s/^ */R /p'
}

new_branch () {
   rbranch="$1"
   lbranch="${rbranch##*/}"

   git show-ref --verify --quiet "refs/heads/$lbranch" && {

      say "$branch: Local branch name already exists"
      printf 'New name (y/n)? '
      read input
      test "$input" != y && return

      printf ': '
      read lbranch
      test -z "$lbranch" && return

      git check-ref-format --branch "$lbranch" >/dev/null
      test $? -ne 0 && return 1
   }

   git checkout -b "$lbranch" --track "$rbranch"
}

git_checkout () {
   tmux_or_die

   requires git

   proj_dir=$(get_proj_dir "$(tmux_cur_session)")
   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   is_git_repository || return

   test "${1:-}" = '--clean-worktree' && {
      test -z "$(git_status)" || {
         wfmux_die 'Still have local changes to be commited'
      }
   }

   branch=$(git_branches | eval "$MENU")
   test -z "$branch" && return

   btype="${branch%% *}"
   branch="${branch#? }"
   branch="${branch%% *}"

   if test "$btype" = L ; then
      git checkout "$branch"
   else
      new_branch "$branch"
   fi

   test $? -eq 0 && {
      tmux_message "Switched to '$branch'"

      git_status | grep -xq '?? \.wfmux' && {
         say '.wfmux/' >>.gitignore
         git add .wfmux
      }
   }

   input_2_quit
   tmux display-popup -C
}

opt_wfmux_checkout  () { git_checkout --clean-worktree; }
opt_wfmux_fcheckout () { git_checkout;                  }

opt_wfmux_cbranch () {
   tmux_or_die

   requires git

   proj_dir=$(get_proj_dir "$(tmux_cur_session)")

   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   is_git_repository || return

   tmux_message "$(git branch --show-current)"
   tmux display-popup -C
}

input_2_quit () {
   init_stty=$(stty -g)
   stty -echo -cooked && dd if=/dev/tty count=1 bs=1 >/dev/null 2>&1
   stty "$init_stty"
}

opt_wfmux_nremote () {
   tmux_or_die

   requires git

   proj_dir=$(get_proj_dir "$(tmux_cur_session)")
   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   is_git_repository || return

   printf 'remote name: '
   read name
   test -z "$name" && return

   printf 'url: '
   read url
   test -z "$url" && return

   git remote add "$name" "$url"
   input_2_quit
}

wfmux_push () {
   tmux_or_die

   requires git

   proj_dir=$(get_proj_dir "$(tmux_cur_session)")
   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   is_git_repository || return

   # TODO: wfmux_push
   # $GITLAB_TOK_NAME:$my_tok, --set-upstream $my_tok@...
}

spin () {
   pos=0 set -- − \\ \| /

   while true ; do 
      sleep 0.2
      pos=$(($pos + 1))
      eval 'printf "\b$'$((($pos % 4) + 1))'"'
   done
} 

opt_wfmux_push  () { wfmux_push;         }
opt_wfmux_fpush () { wfmux_push --force; }

opt_wfmux_awatch () {
   tmux_or_die

   proj_dir=$(get_proj_dir "$(tmux_cur_session)")
   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   printf 'watcher name: '
   read name
   test -z "$name" && return

   expr "$name" : '[a-zA-Z][-a-zA-Z0-9]\+$' >/dev/null || {
      wfmux_die "'$name' isn't a valid watcher name"
   }

   watch_conf="$proj_dir/.wfmux/watch"

   if test -s "$watch_conf"  \
   && grep -q "^w[-+],[01],\[$name\]:" "$watch_conf" ; then
      wfmux_die "A watcher named '$name' already exists"
   fi

   printf 'one shot? (y/n) '
   read wtype
   test "$wtype" = y && wtype=1 || wtype=0

   printf 'cmd: '
   read cmd
   test -z "$cmd" && return

   files=$(get_proj_files -d "$proj_dir" | eval "$MENU")

   say "w+,$wtype,[$name]:$cmd${NL%?}$files${NL%?}end" >>"$watch_conf"

   tmux_message "Added watcher named '$name'"
}

select_watcher () {
   names=''
   watch_conf="$1"

   test -f "$watch_conf" || rm -f "$watch_conf"

   touch "$watch_conf"
   names=$(sed -ne 's/^w[-+],[01],\[\([^]]\+\)\]:.\+$/\1/p' "$watch_conf")

   if test -z "$names" ; then
      wfmux_die 'There are no configured watchers'
   fi

   say "$(say "$names" | eval "$MENU")"
}

check_conf () {
   name="$1"
   conf="$2"

   e="
      1 { s/^w[-+],[01],\[$name\]:.*[:a-zA-Z].*$/1/p; b }
      $ { s/^end$/1/p; b }
      /^\.\//p
   "
   a=$(say "$conf" | wc -l)
   b=$(say "$conf" | sed -ne "$e" | wc -l)

   test "$a" -eq "$b" || wfmux_die "watcher($name): Invalid watcher config"
}

opt_wfmux_mwatch () {
   tmux_or_die

   edit=${EDITOR:-vim}
   requires "$edit"

   proj_dir=$(get_proj_dir "$(tmux_cur_session)")
   test -z "$proj_dir" && die_not_wfmux

   watch_conf="$proj_dir/.wfmux/watch"

   name=$(select_watcher "$watch_conf")
   test -z "$name" && return

   e="
      /^w[-+],[01],\[$name\]:/ {
         p
         n
         b loop
      }
      b
      :loop
         /^\.\// { p; n; b loop }
         /^end$/ { p; q }
         n
         b loop
   "

   conf=$(sed -ne "$e" "$watch_conf")
   if test -z "$conf" ; then
      wfmux_die "There is no watcher named '$name'"
   fi

   check_conf $name "$conf"

   tmpfile=$(mktemp /tmp/wfmux.XXXXXX)
   say "$conf" >>$tmpfile
   say '# Please edit the watcher configuration. Empty lines and' >>$tmpfile
   say '# lines starting with "#" will be ignored.' >>$tmpfile

   eval "$edit" $tmpfile
   conf=$(grep -xv '[[:space:]]*\(#.*\)\?' $tmpfile)

   check_conf $name "$conf"
   del_watcher $name "$watch_conf"
   say "$conf" >>"$watch_conf"
}

del_watcher () {
   name="$1"
   watch_conf="$2"

   sed -i "/^w[-+],[01],\[$name\]:/,/^end$/d" "$watch_conf"
}

opt_wfmux_rwatch () {
   tmux_or_die

   proj_dir=$(get_proj_dir "$(tmux_cur_session)")
   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   watch_conf="$proj_dir/.wfmux/watch"

   name=$(select_watcher "$watch_conf")
   test -z "$name" && return

   del_watcher "$name" "$watch_conf"
}

watcher_state_edit () {
   state="${1:--e}"
   test "$state" = '-e' && state=+ || state=-

   proj_dir=$(get_proj_dir "$(tmux_cur_session)")
   test -z "$proj_dir" && die_not_wfmux

   watch_conf="$proj_dir/.wfmux/watch"

   name=$(select_watcher "$watch_conf")
   test -z "$name" && return

   sed -i "s/^w[-+]\(,[01],\[$name\]:\)/w$state\1/" "$watch_conf"
   grep -q "^w$state,[01],\[$name\]:" "$watch_conf"
}

opt_wfmux_dwatch () {
   tmux_or_die

   if watcher_state_edit -d ; then
      tmux_message "Watcher successfully disabled"
   else
      wfmux_die "The watcher couldn't be disabled"
   fi
}

opt_wfmux_ewatch () {
   tmux_or_die

   if watcher_state_edit -e ; then
      tmux_message "Watcher successfully enabled"
   else
      wfmux_die "The watcher couldn't be enabled"
   fi
}

opt_wfmux_sawatch () {
   tmux_or_die

   command -v "$WATCHER" >/dev/null || die_conf "$WATCHER: command not found"

   session=$(tmux_cur_session)
   id="${session##*-}"

   proj_dir=$(get_proj_dir "$session")
   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   watch_conf="$proj_dir/.wfmux/watch"

   name=$(select_watcher "$watch_conf")
   test -z "$name" && return

   pid_file="$proj_dir/.wfmux/pids/$name.pid"

   if test -s "$pid_file"                    \
   && read pid <"$pid_file"                   \
   && expr "$pid" : "\($NUM_RE\)$" >/dev/null  \
   && test -d "/proc/$pid" ; then
      wfmux_die "watch($name): The watcher is already running"
   fi

   start_watcher "$proj_dir" "$id" "$name"
   tmux display-popup -C
}

opt_wfmux_sowatch () {
   tmux_or_die

   proj_dir=$(get_proj_dir "$(tmux_cur_session)")
   test -z "$proj_dir" && die_not_wfmux

   watch_conf="$proj_dir/.wfmux/watch"

   name=$(select_watcher "$watch_conf")
   test -z "$name" && return

   pid_file="$proj_dir/.wfmux/pids/$name.pid"

   if ! test -s "$pid_file" ; then
      wfmux_die "watcher($name): Unable to find the pid of the watcher"
   fi

   while read pid ; do
      expr "$pid" : "\($NUM_RE\)$" >/dev/null || {
         wfmux_die "watcher($name): Invalid pid found at '$pid_file'"
      }
      test -d "/proc/$pid" && kill -KILL $pid
   done <"$pid_file"
}

start_watcher () {
   proj_dir="$1"
   id="$2"
   name="${3:-}"
   
   watch_conf="$proj_dir/.wfmux/watch"
   test -s "$watch_conf" || return

   efiles_dir="$proj_dir/.wfmux/efiles"
   mkdir -p "$efiles_dir"

   cmd=''
   wtype=''
   wname=''

   n=0
   dir=false
   efiles=''
   state=watcher

   while read line ; do
      n=$(($n + 1))

      if expr "$line" : '[[:space:]]*$' ; then
         continue
      elif expr "$line" : 'w+,[01],\[[^]:[:space:]]\+\]:.*[:a-zA-Z].*$' ; then

         state=files
         wname="${line##w+,?,[}"
         wname="${wname%%]*}"
         wtype="${line#*,}"
         wtype="${wtype%%,*}"
         cmd="${line#w+,?,\[*\]:}"
         efiles="$efiles_dir/$wname.efiles"

      elif test -n "$name"   \
      &&   test -n "$wname"   \
      &&   test "$name" != "$wname" ; then

         state=watcher
         continue

      elif test $state = files \
      &&   expr "$line" : '\.\($|/.*\)' ; then

         file=$(say "$line" | sed -e 's/[[:space:]]*$//;s/ /\\ /g')

         IFS=${NL%?}
         for efile in $(eval each "$file") ; do
            test -e "$efile" || wfmux_die "watcher($wname): '$efile' does not exist"
            test -d "$efile" && dir=true
            say "$efile"
         done  >"$efiles"

      elif expr "$line" : 'end$' \
      &&   test $state = files ; then

         state=watcher
         run_watcher_cmd "$proj_dir"  \
                         "$id"         \
                         "$wname"       \
                         "$wtype"        \
                         "$cmd"           \
                         "$dir"
      else
         die_conf "('$watch_conf'): Failed to parse config at line $n"
      fi
   done <"$watch_conf"

   if test $state = files ; then
      die_conf "('$watch_conf'): Expected the 'end' token"
   fi
}

run_watcher_cmd () {
   sh=$(get_shell)
   requires "$sh"

   proj_dir="$1"
   id="$2"
   wname="$3"
   wtype="$4"
   cmd='
      tmux set-buffer -b '$wname-$id' ""
      { '"$5"'; } | while read line ; do
         tmux set-buffer -a -b '$wname-$id' "$(printf "\n$line")"
      done
   '
   dir="$6"
   efiles="$proj_dir/.wfmux/efiles/$wname.efiles"

   pid_dir="$proj_dir/.wfmux/pids"
   pid_file="$pid_dir/$wname.pid"

   mkdir -p "$pid_dir"

   entr_opts='-nps'
   test "$wtype" = 1 && entr_opts="${entr_opts}r"

   export efiles
   export pid_file
   export entr_opts
   export cmd
   if test "$dir" = true ; then
      entr_opts="${entr_opts}d"

      export wname
      export id
      watch='
        say $$ >"$pid_file"

        while sleep 0.5 ; do

           if ! test -e "$efiles"  \
           || ! test -s "$efiles" ; then
              emsg="Could not locate files, restart the watcher!"
              tmux set-buffer -b "$wname-$id" "$emsg"
           fi

           entr $entr_opts "$cmd" <"$efiles" >/dev/null 2>&1 &
           say $! >>"$pid_file"
           waitpid $!
        done
      '
   else
      watch='
         printf "$$\n" >"$pid_file"
         exec entr $entr_opts "$cmd" <"$efiles"
      '
   fi

   {
      trap '' HUP
      exec $sh -c "$watch"
   } &
}

list_buffers () {
   id="$1"
   tmux list-buffers -F '#{buffer_name}' | grep -x "[A-Za-z][-a-zA-Z0-9]\+-$id"
}

opt_wfmux_vwatch () {
   tmux_or_die

   session=$(tmux_cur_session)
   proj_dir=$(get_proj_dir "$session")

   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   id="${session##*-}"
   buf_list=$(list_buffers "$id")

   test -z "$buf_list" && {
      wfmux_die 'No wfmux buffer for this project was detected'
   }

   buf=$(say "$buf_list" | eval "$MENU") 
   test -z "$buf" && return

   # We could avoid tmux buffers and rely on pipe files which
   # offers a more efficient implementation.
   tmux new-window '
                     val="" pval=""
                     len=0  plen=0
                     while sleep 0.2 ; do
                        val=$(tmux show-buffer -b '"$buf"')
                        len=$(printf "%s\n" "$val" | wc -l)

                        if test "$len" -gt "$plen" ; then
                           pval="$val"
                           printf "%s\n" "$val" | tail -n"$(($len - $plen))"
                           plen="$len"
                        fi
                     done
                     read _
                   '
   tmux display-popup -C
   return
}

opt_wfmux_cwatch () {
   tmux_or_die

   session=$(tmux_cur_session)
   proj_dir=$(get_proj_dir "$session")

   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   id="${session##*-}"
   buf_list=$(list_buffers "$id")

   test -z "$buf_list" && {
      wfmux_die 'No wfmux buffer for this project was detected'
   }

   tmux new-window '
                     buf_list="'"$buf_list"'"
                     NL=$(printf "\n_")
                     IFS=${NL%?}
                     for buf in $buf_list ; do
                        tmux show-buffer -b "$buf"
                        read _
                     done
                   '

   tmux display-popup -C
   return
}

#    NAME: The watcher's name, color: red (disabled), blue (enabled)
#    PID: The process id of the watcher
#    STATE:  e (enabled) / d (disabled)
#    STATUS: r (running) / s (stopped)
#
#                [PROJECT_NAME]
#
#    NAME   |  PID  | STATE | STATUS | COMMAND
#   --------+-------+-------+--------+----------
#    test   | 10722 | E     | S      | make test && herbe ...
#    deploy | 10764 | D     | R      | make deploy ...
#
opt_wfmux_wtop () {
   tmux_or_die

   proj_dir=$(get_proj_dir "$(tmux_cur_session)")
   test -z "$proj_dir" && die_not_wfmux

   cd -L "$proj_dir"

   watch_conf="$proj_dir/.wfmux/watch"

   while read line ; do
      
   done <"$watch_conf"
}

opt_view () {
   printf "${ESC_UNDERLINE}${SUCCESS}${proj_name}${ESC_UNSET_ANSI}${ESC_UNSET_ANSI}\n"
   printf "${ESC_BOLD}PID${ESC_UNSET_ANSI}:          shotdown(${ESC_RED}red${ESC_UNSET_ANSI}), running(${SUCCESS}this color${ESC_UNSET_ANSI})\n"
   printf "${ESC_BOLD}WATCHER_NAME${ESC_UNSET_ANSI}: disable(${ESC_RED}red${ESC_UNSET_ANSI}), enabled(${SUCCESS}this color${ESC_UNSET_ANSI})\n"
   printf "${ESC_BOLD}O/M${ESC_UNSET_ANSI}         : ${ESC_BOLD}O${ESC_UNSET_ANSI} = oneshot, ${ESC_BOLD}M${ESC_UNSET_ANSI} = not oneshot\n\n"

   watcher_file="$SESSION_DIR/$proj_session/watch"
   while read watcher ; do
      watcher=$(printf "$watcher" | sed -ne "s///p")
      _name=$(printf "$watcher" | awk 'BEGIN{RS="";FS="\n"};{print $1}')
      pid_file="$SESSION_DIR/$proj_session/$_name/pid"
      test -s "$pid_file" && _pid=$(cat "$pid_file") || _pid=X
   
      test ${#pid}  -gt $j && j=${#pid}
      test ${#name} -gt $i && i=${#name}

      pid=${pid}${pid:+"\n"}$_pid
      name=${name}${name:+"\n"}$_name
      stat=${stat}${stat:+"\n"}$(printf "$watcher" | awk 'BEGIN{RS="";FS="\n"};{print $2}')
      shot=${shot}${shot:+"\n"}$(printf "$watcher" | awk 'BEGIN{RS="";FS="\n"};{print $3}')
      comm=${comm}${comm:+"\n"}$(printf "$watcher" | awk 'BEGIN{RS="";FS="\n"};{print $4}')
   done <"$watcher_file"

   printf "%${i}s |%${j}s |%-4s |%s\n" "WATCHER_NAME" "PID" "O/M" "COMMAND"
   printf "%${i}s |%${j}s |%-4s |%s\n" "" "" "" ""

   while [ 1 ] ; do
      test ${#name} -eq 0 && break
      printf "%${i}s |%${j}s |%-4s |%s\n" "$_name" "$_pid" "$_stat" "$_comm"
   done
}


opt_ksession () { :; }

add_plug () {
   name=${1:-}
   test -z "$name" && return

   say "$WFMUX_OPS" | grep -xqF "$name" || {
      tmux_message "Another plugin has this name."
      return
   }

   WFMUX_OPS="${WFMUX_OPS}${NL%?}$name"
}

wfmux_load_plugins () {
   test -d "$WFMUX_PLUG_DIR" || return
   test -r "$WFMUX_PLUG_DIR" || {
      tmux_message "No read permission for '$WFMUX_PLUG_DIR'"
      return 0
   }

   for plug in "$WFMUX_PLUG_DIR"/*.wfmux.sh ; do
      . "$plug"
      if test $? -ne 0 ; then
         tmux_message "load_plug('$plug') has a non-zero exit status"
         return 1
      fi
   done
}

opt_wfmux_ops () {
   tmux_or_die

   wfmux_load_plugins || return

   opt=$(say "$WFMUX_OPS" | grep -xEv 'new|ops' | eval "$MENU")
   test -z "$opt" && return

   func="opt_wfmux_$opt"

   cmd_val=$(command -v "$func")
   if test -z "$cmd_val" ; then
      tmux_message "$func: undefined wfmux operation"
   elif test "$cmd_val" != "$func" ; then
      tmux_message "$func: wfmux operation should be a function!"
   else
      eval "$func"
   fi
}

main "$@"
