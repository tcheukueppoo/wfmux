#!/bin/sh

#set -x
set -ue

readonly PROGRAM=${0##*/}

readonly ALT_SCREEN='\033[?1049h'
readonly NORMAL_SCREEN='\033[?1049l'
readonly HIDE_CUR='\033[?25l'
readonly SHOW_CUR='\033[?25h'
readonly CLEAR_SCREEN='\033[2J'
readonly BOLD='\033[1m'
readonly UNDERLINE='\033[4m'
readonly RED='\033[31m'
readonly UNSET_ANSI='\033[0m'

readonly CONFIG_DIR=${XDG_CONFIG_HOME:-"$HOME/.config"}
readonly WFMUX_CONFIG_DIR="${CONFIG_DIR%%/}/wfmux"
readonly COMMANDS="$WFMUX_CONFIG_DIR/commands"
readonly CACHE_DIR=${XDG_CACHE_HOME:-"$HOME/.cache"}
readonly CACHE="${CACHE_DIR%%/}/wfmux"
readonly CACHE_PL="${CACHE_DIR}/wfmux.pl"
readonly SESSION_DIR="${CACHE_DIR%%/}/wfmux/sessions"
readonly TMUX_CONF="$HOME/.tmux.conf"

mkdir -p "$CONFIG_DIR" "$CACHE_DIR" "$CACHE" "$SESSION_DIR" "$WFMUX_CONFIG_DIR"

readonly LOGO_LS=$(cat <<EOF
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx┌────────────
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx┌───────
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxxxxxxxxxxxxxxx┌───┐xxxxxxxxxx│
xxxxxxxxxxxx┌──┐xxxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxxxxxxxxxxxxxxx│xxx│xxxxxxxxxx│
xxxxxxxxxxxx│xx│xxxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxxxxxxxxxxxxxxx│xxx│xxxxxxxxxx│
xxxxxxxxxxxx│xx│xxxxxxxxxxx┌────┼─────┬─────┬──────┬──┐xxxxxxx│xxx│xxxx┌─────┘
xxxxxxxxxxxx│xx│xxxxx┌─xxxx│xxxx│xxxxx│xxxxx│xxxxxx│xx│xxxxxxx│xxx│xxxx│
────────────┘xx│xxxxx│xxxxx│xxxx│xxxxx│xxxxx│xxxxxx│xx│xxxxxxx│xxx└────┼─────┐
xxxxxxxxxxxxxxx│xxxxx│xxxxx│xxxx│xxxxx│xxxxx│xxxxxx│xx│xxxxxxx│xxxxxxxx│xxxxx│
xxxxxxxxxxxxxxx│xxxxx│xxxxx│xxxx│xxxxx│xxxxx└────xx│xx└───────┘xxxxxxxx│xxxxx│
xxxxxxxxxxxxxxx├─────┴─────┘xxxx│xxxxx│xxxxxxxxxxxx└──xxxxxxxxxxxxxxxxx│xxxxx│
xxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxx│xxxx─┘xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│xxxxx│
xxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxx│xxxxxxxxxxxx──────────────────────────┘xxxxx│
xxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxx└─xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│
xxxxxxxxx──────┘xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│
EOF
)
readonly LOGO_MS=$(cat <<EOF
xxxxxxxxxxxxxxxxxxxxx┌─────xxxxxxxxxxxxxxxxxxxxxxxxxxx┌───
xxxxxxxxxxxxxxxxxxxxx│xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│
xxxxxxxx┌─┐xxxxxxxxxx│xxxxxxxxxxxxxxxxxxxxxx┌──┐xxxxxx│
xxxxxxxx│x│xxxxxxx┌──┼───┬───┬───┬────┐xxxxx│xx│xx┌───┘
xxxxxxxx│x│xxx┌─xx│xx│xxx│xxx│xxx│xxxx│xxxxx│xx│xx│
────────┘x│xxx│xxx│xx│xxx│xxx│xxx│xxxx│xxxxx│xx└──┼───┐
xxxxxxxxxx│xxx│xxx│xx│xxx│xxx│xxx│xxxx│xxxxx│xxxxx│xxx│
xxxxxxxxxx├───┴───┘xx│xx─┘xxx└─xx│xxxx└─────┘xxxxx│xxx│
xxxxxxxxxx│xxxxxxxxxx└─xxxxxxxxxx└──xxxxxxxxxxxxxx│xxx│
xxxxxxxxxx│xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx─────────┘xxx│
xxxxxxx───┘xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx│
EOF
)
readonly LOGO_SS='WFMUX'

readonly WFMUX=$(cat<<EOF

     ┌──────────────┤ WFMUX
    ┌┴─────────────────────────────────────────────────┐
    │                                                  │
    ├───── Input a name for a new tmux session         │
    │                                                  │
    ├───── Input f⟨return⟩ to select a project         │
    │                                                  │
    ├───── Input ⟨return⟩ to drop to the terminal      │
    │                                                  │
    └──────────────────────────────────────────────────┘
EOF
)

WFMUX_CONFIG="$WFMUX_CONFIG_DIR/wfmux.conf"

# Default configuration if external config file does not exist
COLOR=4
SUCCESS="\033[1;3${COLOR}m"

TOK=tok
GITLAB_TOK_NAME=gitlab_token_name

RUNNER=entr
RUNNER_TEMPLATES="$HOME/.config/wfmux/commands"
EXPLORER=nnn

WINDOW_ATTRIBUTES_REST=20x20+10+20
WINDOW_ATTRIBUTES_FILE_SELECTOR=20x20+10+20
WINDOW_ATTRIBUTES_INPUT_BOX=20x20+10+20

TBIND_OPS==
TBIND_EXPLORE=BSpace
TBIND_SELECT=Enter

IGNORE=.git
SEARCHER='fzf --multi --border=bottom --margin=25%'
PROJECT_DIRECTORY=$(cat <<-EOF
	$HOME/projects
	$HOME/aprojects
	$HOME/oprojects
	EOF
)

USE_XDG=yes
PROGRAMS=$(cat <<-EOF
	pdf:      zathura
	text:     nvim
	video:    ffplay
	audio:    aplay
	image:    feh
	EOF
)

usage() {
	cat <<EOF
Build an awesome dev workflow with tmux, fzf, nnn, and entr.
usage: wfmux [ [-c|-config|--config] *config_file* ] *operation_name*
       wfmux [ -h | -help | --help ]

Options:
     -h, -help, --help             print this help message.
     -c, -config, --config *FILE*  load *FILE* configuration file.

Operation names:
    open         fuzzyly select a project and open a new tmux session.
    nsession     create a new project tmux session while in a tmux session.
    switch      switch between project sessions
    explore      open your favorite file manager on a popup tmux pane.
    select       fuzzyly select a file to open provided that they exist
                 a recently used tmux session which carries the name of your
                 project.   
    commit       add to the index and commit changes to local repository.
    acommit      replace the tip of the current branch by creating a new commit
    push         push to the remote repositories.
    fpush        force-push to the remote repositories.
    branch       fuzzyly switch between branches of your local repository.
    dump         dump wfmux's tmux configuration to stdout.
    tmux         update wfmux's tmux configuration at ~/.tmux.conf.
    ops          a wrapper to the above operations.
    dwatcher     disable a watcher from the watcher list
    ewatcher     enable a watcher from the watcher list
    awatcher     add a new watcher to the watcher list
    rwatcher     remove a new watcher to the watcher list
    view         fancy view of any existing running project watcher.

EOF
	exit "$1"
}

die() {
	printf "$*\n" >&2
	exit 1
}

func_main() {
	local operation=
	local gave_config=false

	[ $# -eq 0 ] && usage 1
	until [ $# -eq 0 ]
	do
		case "$1" in
		-h | -help | --help)
			usage 0 ;;
		-c | -config | --config)
			[ $# -eq 1 ] && WFMUX_CONFIG=$2 || usage 1
			gave_config=true
			shift ;;
		push     | \
		fpush    | \
		commit   | \
		acommit  | \
		select   | \
		explore  | \
		open     | \
		tmux     | \
		dump     | \
		ops      | \
		view     | \
		awatcher | \
		dwatcher | \
		ewatcher | \
		rwatcher | \
		branch   | \
		nsession | \
		switch)
			operation=$1
			if [ -f "$WFMUX_CONFIG" ]
			then
				[ -r "$WFMUX_CONFIG" ] || die "no permission to read '$WFMUX_CONFIG'"
				. $WFMUX_CONFIG        || die "could not source configuration file"
			fi ;;
		*)
			die "'$1' is an unrecognized option, please try \`$PROGRAM --help'" ;;
		esac
		shift
	done

	if [ x$gave_config = x"true" ]
	then
		check_config_variables
	else
		# use default config "~/.config/wfmux.conf" is possible
		if [ -f "$WFMUX_CONFIG" -a -r "$WFMUX_CONFIG" ]
		then
			check_config_variables
		fi
	fi

	eval "func_$operation"
}

## Check if variables are unset or null	and if set then
## check if the data is somehow our expectation.
## we won't have to rely on `set -u`, we would want to output a custom 
## error message if one of these variables aren't set/sane.
check_config_variables() {
	local is_set para
	local error="$PROGRAM: ('$WFMUX_CONFIG'):"

	for para in \
		         USE_XDG \
		         RUNNER \
		         SEARCHER \
		         EXPLORER \
		         WINDOW_ATTRIBUTES_REST \
		         WINDOW_ATTRIBUTES_INPUT_BOX \
		         WINDOW_ATTRIBUTES_FILE_SELECTOR \
		         PROJECT_DIRECTORY \
		         TBIND_OPS \
		         TBIND_SELECT \
		         TBIND_EXPLORE
	do
		eval "is_set=\${$para:-UNSET}"
		[ "$is_set" = UNSET ] && die "$error '$para' isn't set"
	done

	_config_die() {
		die "$error invalid value assigned to '$1'"
	}

	## Check if we got sane values
	{
		local window_regex='[[:digit:]]\+x[[:digit:]]\++[[:digit:]]\++[[:digit:]]\+$'
		expr "$WINDOW_ATTRIBUTES_REST"          : "$window_regex" || _config_die WINDOW_ATTRIBUTES_REST
		expr "$WINDOW_ATTRIBUTES_FILE_SELECTOR" : "$window_regex" || _config_die WINDOW_ATTRIBUTES_FILE_SELECTOR
		expr "$WINDOW_ATTRIBUTES_INPUT_BOX"     : "$window_regex" || _config_die WINDOW_ATTRIBUTES_INPUT_BOX
		expr "$USE_XDG"                         : 'true\|false$'  || _config_die USE_XDG
		expr "$COLOR"                           : '[0-9]$'        || _config_die COLOR
	} >/dev/null

	for i in EXPLORER RUNNER SEARCHER
	do
		eval "command -v" "\${$i} >/dev/null"
		test $? -ne 0 && die "$error '$i' not found"
	done

	# IFS=$'\n' won't expand '\n' on dash shell
	printf "$PROJECT_DIRECTORY" |
	while read i
	do
		test -d "$i" || die "$error '$i' is not a directory"
		test -r "$i" || die "$error cannot list content of '$i'"
	done
}

display_dashboard() {
	local max="awk 'BEGIN{len = 0}; {nlen = length(\$0); if (nlen > len) len = nlen;}; END{print len}'"

	# generate help message for the dashboard
	_gen_key_helper() {
		cat <<-EOF
			The following are tmux bindings related to WFMUX.

			M-$TBIND_SELECT: fuzzyly open project files
			M-$TBIND_EXPLORE: open file manager
			M-$TBIND_OPS: fuzzyly select other wfmux operations

			input any key to exit dashboard
		EOF
	}

	_print() {
		printf "\033[$1;$2f$3" >/dev/tty
	}

	# save initial terminal setting and will set it back after exiting dashboard
	local init_stty=$(stty -g)
	stty -cooked -echo time 0 min 1
	printf "${ALT_SCREEN}${HIDE_CUR}${CLEAR_SCREEN}"

	(
		term_h= term_w=
		while true; do
			if [ "$(stty -F /dev/tty size)" = "$term_h $term_w" ]
			then
				sleep 2
				continue
			fi
			term_h=$(stty -F /dev/tty size | cut -d' ' -f1)
			term_w=$(stty -F /dev/tty size | cut -d' ' -f2)
			if   [ $term_h -lt 32 -o $term_w -lt 97  ]
			then
				_size=SS
			elif [ $term_h -lt 43 -o $term_w -lt 155 ]
			then
				_size=MS
			else
				_size=LS
			fi
			eval 'logo_h=$(printf "$LOGO_'$_size'" | wc -l);
				  logo_w=$(printf "$LOGO_'$_size'" | eval "$max")'

			logo_h=$(expr $logo_h + `_gen_key_helper | wc -l`)
			gen_w=$(_gen_key_helper | eval "$max")
			x=$(expr $term_w / 2 - $logo_w / 2)
			y=$(expr $term_h / 2 - $logo_h / 2)
			if [ $gen_w -gt $logo_w ]
			then
				gen_x=$(expr $x - \( $gen_w  - $logo_w \) / 2)
			else
				gen_x=$(expr $x + \( $logo_w - $gen_w  \) / 2)
			fi

			printf "${CLEAR_SCREEN}${SUCCESS}${BOLD}"
			eval 'printf "$LOGO_'$_size'"' | {
				while read i
				do
					_print $y $x "$(printf "$i" | tr 'x' ' ')"
					y=$(($y+1))
				done

				printf "$UNSET_ANSI"
				_gen_key_helper | while read i
				do
					y=$(($y+1))
					_print "$y" "$gen_x" "$i"
				done
			}
		done
	) &

	# get key from standard input
	dd if=/dev/tty count=1 bs=1 >/dev/null 2>&1
	kill -KILL $! || : ## CAUTION: script would exit if set -e
	stty "$init_stty"
	printf "$UNSET_ANSI$SHOW_CUR"
	tput clear
}

__get_cur_session() {
	tmux list-sessions -F '#S:#{session_activity}' | sort -b -t: -k2,2n | tail -n1 | cut -d: -f1
}

__get_pty() {
	tmux list-clients -F '#S:#{client_tty}' | grep -F "$(__get_cur_session):" | cut -d: -f2
}

__new_session() {
	locate_git_repos() {
		find "$1" -mindepth 2 -type d -iname '.git' -exec expr '{}' : '\(.*\)/.git$' \;
	}

	# TODO: cache search results
	local project_list=$(printf "$PROJECT_DIRECTORY\n" | while read pdir; do locate_git_repos "$pdir"; done | tee "$CACHE_PL")
	local project_name=$(printf "$project_list" | sed -nE 's,^.*/(.*)$,\1,p' | awk '{print "["NR"]:"$0}' | eval "$SEARCHER")

	test -z "$project_name" && return

	local project_dir=$(printf "$project_list" | sed -n "$(expr "$project_name" : '\[\([0-9]\+\)\]:.*$')p")
	local session_name=`mktemp -u pr-XXXXXX`

	# Check if session already exist
	for i in "$SESSION_DIR"/*
	do
		local path="$i/path"
		if [ -f "$path" ]
		then
			if [ `cat "$path"` = "$project_dir" ]
			then
				session_name=`basename "$i"`
			fi
		fi
	done

	# Start session with all its watchers
	{
		TMUX=${TMUX:-}
		if ! tmux has-session -t "$session_name"
		then
			if [ -n "$TMUX" ]
			then
				local pty=`__get_pty`

				__setup_session "$project_dir" "$session_name"&
				tmux new-session -s "$session_name" -d
				tmux switch-client -c "$pty" -t "$session_name"
			else
				__setup_session "$project_dir" "$session_name"&
				display_dashboard
				tmux new-session -s "$session_name"
			fi
		else
			if [ -n "$TMUX" ]
			then
				local pty=`__get_pty`

				tmux switch-client -c "$pty" -t "$session_name"
			else
				tmux attach-session -t "$session_name"
			fi
		fi
	} #2>/dev/null
}

# Create a new project tmux session while in an existing session, similer to `func_open'
func_nsession() {
	__new_session
}


__setup_session() {
	local project_dir=$1
	local project_session="$SESSION_DIR/$2"

	mkdir -p "$project_session"
	printf "$project_dir" >"$project_session/path"

	if [ -f "$watch_config" ]
	then
		# Program must be runned in the project directory
		cd "$project_dir" || return

		mkdir -p "$project_session/fifos"
		for pairs in `cat "$watch_config/watch" | sed -ne 's/^s+\(.\)\[\(.*\)\]: *\(.\+\) *$/\1(\2)\3/p'`
		do
			__start_watcher "$pairs" "$project_session"
		done
	fi
}

# Select a project and open a tmux session
func_open() {
	local session_name input

	if tmux list-sessions >/dev/null 2>&1
	then
		printf "Choose an existing session to attach\n\n"
		tmux list-sessions | awk '{print "["NR"] "$0}'
	fi
	printf "$WFMUX\n"
	read -p '⟩⟩ ' input
	tput clear

	if [ -n "$(expr "$input" : '\([0-9][0-9]*\)$')" ]
	then
		session_name=$(tmux list-sessions -F '#S' | sed -n "${input}p")
		if [ -n "$session_name" ]
		then
			tmux attach-session -t "$session_name"
		fi
	else
		if [ -n "$(expr "$input" : '\(F\|f\)$')" ]
		then
			__new_session
		elif [ -z "$input" ]
		then
			return 0
		else
			tmux new-session -s "$(printf "$input")"
		fi
	fi
}

__set_whxy() {
	local window_attribute=$1

	y=$(printf "$window_attribute" | sed -e 's/^.*+\([0-9]\+\)$/\1/')
	x=$(printf "$window_attribute" | sed -e 's/^.*+\([0-9]\+\)+.*/\1/')
	w=$(printf "$window_attribute" | sed -e 's/^\([0-9]\+\)x.*/\1/')
	h=$(printf "$window_attribute" | sed -e 's/^.*x\([0-9]\+\).*/\1/')
}

_dump() {

	__set_whxy $WINDOW_ATTRIBUTES_FILE_SELECTOR
	cat <<EOTX
unbind M-$TBIND_SELECT
bind M-$TBIND_SELECT if-shell "command -v wfmux" { display-popup -w $w -h $h -x $x -y $y -E "wfmux select"; }
EOTX

	__set_whxy $WINDOW_ATTRIBUTES_REST
	cat <<EOTX
unbind M-$TBIND_EXPLORE
bind M-$TBIND_EXPLORE if-shell "command -v wfmux" { display-popup -w $w -h $h -x $x -y $y -E "wfmux explore"; }
unbind M-$TBIND_OPS
bind M-$TBIND_OPS if-shell "command -v wfmux" { display-popup -w $w -h $h -x $x -y $y -E "wfmux ops"; }
EOTX

}

func_dump() {
	_dump
}

func_tmux() {
	_dump >>"$TMUX_CONF"
}

__get_project_dir() {
	local session_name=`__get_cur_session`
	local session="$SESSION_DIR/$session_name"

	if [ -d "$session" ]
	then
		local project_dir=`cat "$session/path"`
		test -d "$project_dir" && printf "$project_dir"
	fi
}

func_switch() {
	local base_dir=$(basename `__get_project_dir`)

	__get_projects_basenames() {
		local session
		local project_dir

		tmux list-sessions -F '#S' | while read sname
		do
			session="$SESSION_DIR/$sname"
			if [ -d "$session" ]
			then
				project_dir=$(cat "$session/path")
				if [ -d "$project_dir" ]
				then
					project_dir=$(printf "%s\n" "$project_dir" | sed -e 's,.*/\([^/]*/[^/]*\),\1,')
					printf "%s\n" "$sname:$project_dir" | sed -e "s,/\($base_dir\)$,/\1*,"
				fi
			fi
		done
	}

	local session_pbase=`__get_projects_basenames`
	local pbasename=$(printf "$session_pbase" | cut -d: -f2 | eval "$SEARCHER")

	pbasename=${pbasename%*}
	if [ -n "$pbasename" ]
	then
		local pty=`__get_pty`

		# CAUTION: This is not a BUG!!! (note the head -n1)
		# The differenciation level for every projects are the names of their parent directories only, not uptil the OS's root directory.
		tmux switch-client -c "$pty" -t "$(printf "$session_pbase" | sed -ne "s,\(.*\):$pbasename,\1,p" | head -n1)"
	fi
}

## open your favorite tui file manager
func_explore() {
	local project_dir=`__get_project_dir`
	eval "$EXPLORER" "$project_dir"
}

## select project files to open
func_select() {
	local new_window=true
	local sh=${SHELL##*/}
	local project_dir=`__get_project_dir`

	test -d "$project_dir" || return

	local file=$(
		args=$(printf "$IGNORE" | sed -e '${ s/\(.*\)/-name "\1"/; q; }; 1,${ s/\(.*\)/-name "\1" -or /; }' | tr '\n' ' ')
		eval "find '$project_dir' \( $args \) -prune -or -type f -print | sed -e 's,^$project_dir/,,' | $SEARCHER"
	)

	test -n "$file" || return
	file="$project_dir/$file"

	__give_it_or_do_it() {

		if [ x"$USE_XDG" != xtrue ]
		then
			local mime
			local mime_type=$(xdg-mime query filetype "$file")

			if [ $? = 0 ] && [ -n "$mime_type" ]
			then
				# use `subtype' whenever `type' is `application' otherwise use `type'
				test x"${mime_type%/*}" = x"application" && mime=${mime_type#*/} || mime="${mime_type%/*}"

				local opener=$(printf "$PROGRAMS" | sed -ne "s/^$mime:[[:space:]]*\([^[:space:]]*\)/\1/p")
				opener=${opener:-$EDITOR}
				opener=${opener:-vim}
				{ 
					which "$opener" 1>&2
					if [ $? -eq 0 ]
					then
						# Put in list of all TUI applications that takes a $file as argument
						printf "$opener" | grep -qE '^vim|ranger|cmus|nvim|nnn|kak$'
						if [ $? -eq 0 ]
						then
							printf "$opener '$file'"
						else
							{ trap '' HUP; eval "$opener '$file'"; } &
							tmux display-popup -C
						fi
					fi
				} 2>/dev/null
			fi
		else
			printf "xdg-open '$file'"
		fi
	}

	local command=`__give_it_or_do_it`
	if [ -n "$command" ]
	then
		# start from the most active, ignore the previous one
		for window_index in `tmux list-windows -F '#I:#{window_active}' | awk -F[':'] '$2 == 1{pass = 1}; pass == 1{print $1}'`
		do
			local panes=$(tmux list-panes -t "$window_index" -F '#{pane_current_command}:#P:#{pane_active}')
			local bash_panes=$(printf "$panes" | grep "^${sh:-bash}:")

			# is it an active pane idle? if no then
			# take the most recently opened idle pane
			if [ -n "$bash_panes" ]
			then
				local bash_index=$(printf "$bash_panes" | sed -nE 's/.*:([0-9]+):1$/\1/p')
				test -z "$bash_index" && bash_index=$(printf "$bash_panes" | sort -t: -k2,2n | head -n1 | cut -d: -f2)

				tmux send-keys -t "$window_index.$bash_index" "$command" C-m
				test $? -eq 0 && new_window=false && break
			else
				if [ `printf '%s\n' "$panes" | wc -l` -eq 1 ]
				then
					tmux select-window -t "$window_index"
					tmux split-window  -h "$command"
					test $? -eq 0 && new_window=false && break
				fi
			fi
		done

		test x$new_window = x"true" && tmux new-window "$(__give_it_or_do_it)"
	fi
}

func_commit() {
	__commit
}

func_acommit() {
	__commit true
}

__commit() {
	local editor=$(printf "$PROGRAMS" | sed -ne 's/^[ \t]*text:[ \t]\+\(\w*\)$/\1/p')

	editor=${editor:-$EDITOR}
	editor=${editor:-vim}

	{ command -v git       || return
	  command -v "$editor" || return
	} >/dev/null

	local project_dir=`__get_project_dir`

	if [ -n "$project_dir" ]
	then
		cd "$project_dir"
		if [ $? = 0 ]
		then
			local amend=${1:-false}

			git add .
			if [ "$amend" = false ]
			then
				local tempfile=`mktemp /tmp/.git_XXXXXX`

				$editor "$tempfile"
				# Let git abord if we did not commit with a commit message
				# than trying to introduce a `du'-like command
				git commit --message "$(cat "$tempfile")"
				rm -f "$tempfile"
			else
				git commit --amend
			fi
		fi
	fi
}

func_branch() {
	command -v git >/dev/null || return

	local project_dir=`__get_project_dir`

	cd "$project_dir"
	if [ $? = 0 ]
	then
		if printf "%s\n" "$SEARCHER" | grep -q '^fzf'
		then
			SEARCHER="$SEARCHER --print-query"
		fi
		local branch=$(git branch --all | sed -e 's|^\(\*\?\) *\(.*\)$|\2\1|; s|^\(\([^/]\+/\)\+\)\(.\+\)$|\3|' | awk '/\*$/{ dup = substr($0, 1, length($0) - 1) }; $0 != dup{ print }' | sort | uniq | eval "$SEARCHER" | tail -n1)

		branch=${branch%*}
		if [ -n "$branch" ]
		then
			# Check if the current working branch is clean(nothing to commit)
			git status | tail -n1 | grep -q '^nothing to commit' 
			if [ $? -eq 0 ]
			then
				git checkout "$branch" || git checkout -b "$branch"
			fi
		fi
	fi
}

__input_to_exit() {
	printf "\nPress anything to quit!"
	stty -echo -cooked && dd if=/dev/tty count=1 bs=1 >/dev/null 2>&1
}

func_push() {
	__push
}

func_fpush() {
	__push --force
}

__push() {
	{ command -v git    || return
	  command -v "$TOK" || return
	} >/dev/null

	local project_dir=`__get_project_dir`
	test -n "$project_dir" && project_name=$(basename "$project_dir")

	if [ -n "$project_name" ]
	then
		cd "$project_dir"
		if [ $? -eq 0 ]
		then
			local username
			local remotes=$(printf "$WFMUX_REMOTE" | eval "$SEARCHER")
			local session_path="$SESSION_DIR/$(__get_cur_session)"

			if [ -s "$session_path/user" ]
			then
				username=$(cat "$session_path/user")
			else
				username=$(printf "$WFMUX_USERS" | eval "$SEARCHER")
				printf "$username" >"$session_path/user"
			fi

			if [ -n "$remotes" ]; then
				local force=${1:---force}
				local proto=https
				local branch=$(git branch | sed -ne 's|^\* \(.\+\)|\1|p')
				local git_config=$(cat .git/config)

				printf "%s\n" "$remotes" | while read remote
				do
					local my_tok=$(eval "$TOK '${remote%%.*}'")

					case $remote in
						codeberg.org | github.com | github.com) proto=https ;;
						*) proto=https ;;
					esac
					test "$remote" = "gitlab.com" && my_tok="$GITLAB_TOK_NAME:$my_tok"

					printf "Pushing to $remote/$username  ";
					{ i=0
					  set -- − \\ \| /
					  while true; do 
						  sleep 0.2
						  i=$(($i+1))
						  eval "printf \"\b\$$(($(($i%4))+1))\""
					  done
					} &

					local failed=No
					git push "$force" --set-upstream "$proto://$my_tok@$remote/$username/$project_name.git" "$branch" >/dev/null 2>&1 || failed=Yes
					kill -KILL $!

					test x"$failed" = x"Yes" && c="${RED}Failed" || c="${SUCCESS}Done"
					printf "\b$c$UNSET_ANSI\n"
				done

				# To avoid saving tokens!
				printf "$git_config" > .git/config
				__input_to_exit
			fi
		fi
	fi
}

__start_watcher() {
	local project_session=$2 one_shot=${1%%(*} cmd=${1#?(*)} watcher_name=${1%%)*}

	watcher_name=${1#?(}

	# You would be seeing the std(out|err) of watchers via named-pipes
	local fifo="$project_session/fifos/$watcher_name.fifo"

	test -p "$fifo" || mkfifo "$fifo"
	{ 
		trap '' HUP
		if [ $one_shot = 1 ]
		then
			# for self restarting programs(like framework developement server, etc.)
			eval "$cmd"
		else
			cat "$project_session/watch" \
			| sed -ne "/^s+0\[$watcher_name\]:/,/^e\[$watcher_name\]/p" \
			| tail -n +2 \
			| sed '$d' \
			| case $RUNNER in
			   entr) entr -nr "$cmd" ;;
			   *) : ;;
			  esac >"$fifo"
		fi
	} >"$fifo" 2>&1 &

	printf "$!" >"$project_session/$watcher_name.pid"
}

# Add a new watcher to the watcher list
func_awatcher() {
	local watcher_name watch_config="$SESSION_DIR/`__get_cur_session`/watch" project_dir=`__get_project_dir`

	printf "Give a name to your watcher: "
	read watcher_name

	printf "One shot(Y/n)? "
	read one_shot

	if [ -n "$watcher_name" ]
	then
		# Check if this name already exists in the watcher list
		if [ -f "$watch_config" ]; then
			cat "$watch_config" | grep -q "^s[-+][01]:\[$watcher_name\]" && return
		fi

		__get_files() {
			local args=$(
				printf "$IGNORE" |
				sed -e '
					${ s/\(.*\)/-name "\1"/; q; };
					1,${ s/\(.*\)/-name "\1" -or /; }
			    ' |
				tr '\n' ' '
			)
		    eval "find '$project_dir' \( $args \) -prune -or -type f -print | sed -e 's,^$project_dir/,,' | $SEARCHER"
		}

		local files=`__get_files`
		if [ -n "$files" ]; then

			printf "$UNDERLINE"
			if [ -r "$COMMANDS" ]
			then
				case $one_shot in
				y | Y)
					local cmd=$(cat "$COMMANDS" | grep -v '^[\t ]*\(#.*\)\?$' | eval "$SEARCHER")
					cat <<-EOF
						s+0[$watcher_name]: $cmd
						$files
						e[$watcher_name]
					EOF
					;;
				*)
					cat <<-EOF
					s+1[$watcher_name]: $cmd
					e[$watcher_name]
					EOF
					;;
				esac >>"$watch_config"
				printf "$SUCCESS"
				printf "'$watcher_name' was successfully added to the list of watchers\n"
			else
				printf "$RED"
				printf "Could not find the list of commands.\n" >&2
				printf "these commands should be located at '$COMMANDS'\n" >&2
			fi
			printf "${UNSET_ANSI}${UNSET_ANSI}"

			__input_to_exit
		fi
	fi
}

# remove watchers from the watcher list
func_rwatcher() {
	local cur_session=`__get_cur_session`
	[ -z "$cur_session" ] && return

	local project_session="$SESSION_DIR/$cur_session"
	local watch_config="$project_session/watch"

	test -r "$watch_config" -a -s "$watch_config" || return

	local watcher_names=$(cat "$watch_config" | sed -ne 's/^s[-+]\[\(\w*\)\]:.*$/\1/p')
	if [ -n "$watcher_names" ]
	then
		local watcher_name=$(printf "$watcher_names" | eval "$SEARCHER")
		if [ -n "$watcher_name" ]
		then
			printf "$UNDERLINE"
			cat "$watch_config" | grep -q "^e\[$watcher_name\]"

			if [ $? -eq 0 ]
			then
				sed -i "/^s..\[$watcher_name\]:/,/^e\[$watcher_name\]/d" "$watch_config"
				if [ $? -eq 0 ]
				then
					if [ -r "$project_session/fifos/$watcher_name.pid" ]
					then
						pid=$(cat "$project_session/fifos/$watcher_name.pid")
						kill -KILL "$pid" >/dev/null 2>&1
					fi
					printf "$SUCCESS"
					printf "Watcher '$watcher_name' successfully deleted\n"
				else
					printf "$RED"
					printf "Could not delete watcher\n"
				fi
			else
				printf "$RED"
				printf "Error: could not find scope of definition of '$watcher_name'\n"
			fi
			printf "${UNSET_ANSI}${UNSET_ANSI}"
		fi
	else
		printf "you do not have any watcher\n"
	fi

	__input_to_exit
}

__ed_watcher() {
	local watch_config="$1/watch"

	if [ -r "$watch_config" -a -s "$watch_config" ]
	then
		local watcher_names=$(cat "$watch_config" | sed -ne 's/^s[-+][01]\[\(\w*\)\]:.*$/\1/p')
		if [ -n "$watcher_names" ]
		then
			local watcher_name=$(printf "$watcher_names" | eval "$SEARCHER")
			if [ -n "$watcher_name" ]
			then
				sed -ie "s/^s.\(.\[$watcher_name\]\)/^s$2\1/" "$watch_config"
			fi
		else
			printf "No watcher were found\n"
		fi
	fi
}

# Enable watchers, should be runned within an existing wfmux tmux session.
# This operation sets on watchers to be runned upon session's startup.
func_ewatcher() {
	local cur_session=`__get_cur_session`
	local project_session="$SESSION_DIR/$cur_session"
	local watch_file="$project_session/watch"

	[ -z "$cur_session" ] && return

	printf "$UNDERLINE"

	local watcher_name=$(__ed_watcher "$watch_file" +)
	if [ $? -eq 0 ]
	then
		local pid_file="$project_session/fifos/$watcher_name.pid"

		if ! test -s "$pid_file" ||
		   ! ps a | grep -q "^[\t ]\+$(cat "$pid_file")"
		then
			local pairs=$(cat "$watch_file" | sed -ne 's/^s+\(.\)\[\(.*\)\]: *\(.\+\) *$/\1(\2)\3/p')
			__start_watcher "$pairs" "$project_session"
		fi

		printf "$SUCCESS"
		printf "Watcher '$watcher_name' enabled.\n"
		printf "${UNSET_ANSI}${UNSET_ANSI}"
	else
		printf "$RED"
		printf "Could not enable watcher '$watcher_name'\n"
	fi
	printf "${UNSET_ANSI}${UNSET_ANSI}"

	__input_to_exit
}

# Disable watchers, should be runned within an existing wfmux tmux session.
# This operation sets off watchers so that they cannot run when a new wfmux
# tmux session is initiated either via `func_open' or `func_nsession'
func_rwatchers() {
	local cur_session=`__get_cur_session`
	local project_session="$SESSION_DIR/$cur_session"
	local watch_file="$project_session/watch"

	[ -z "$cur_session" ] && return

	printf "$UNDERLINE"

	local watcher_name=$(__ed_watcher "$watch_file" -)
	if [ $? -eq 0 ]
	then
		printf "$SUCCESS"
		printf "Watcher '$watcher_name' disabled.\n"
		printf "${UNSET_ANSI}${UNSET_ANSI}"
	else
		printf "$RED"
		printf "Could not disable watcher '$watcher_name'\n"
	fi
	printf "${UNSET_ANSI}${UNSET_ANSI}"

	__input_to_exit
}

# Fancy view of all watchers belonging to the project in question
# Definition of the view
#             --[ project_name ]--
#    PID:          not running(red), running($COLOR)
#    WATCHER_NAME: disable(red), enabled($COLOR)
#    o/m         : o, not monitored by $runner otherwise m
#
#    WATCHER_NAME   PID    o/m  COMMAND
#    watcher_name_1 pid_1  o    command_1
#    watcher_name_2 pid_2  m    command_2
#    watcher_name_3 pid_3  m    command_3
func_view() {
	local i j project_name=`__get_project_dir` project_session=`__get_cur_session`

	[ -z "$project_name" ] && return
	project_name=$(basename "$project_name")

	printf "${UNDERLINE}${SUCCESS}"
	printf "$project_name\n\n"
	printf "${UNSET_ANSI}${UNSET_ANSI}"
	printf "${BOLD}PID${UNSET_ANSI}:          not running(${RED}red${UNSET_ANSI}), running(${SUCCESS}this color${UNSET_ANSI})\n"
	printf "${BOLD}WATCHER_NAME${UNSET_ANSI}: disable(${RED}red${UNSET_ANSI}), enabled(${SUCCESS}this color${UNSET_ANSI})\n"
	printf "${BOLD}O/M${UNSET_ANSI}         : ${BOLD}O${UNSET_ANSI} = oneshot, ${BOLD}M${UNSET_ANSI} = not oneshot\n\n"


	local watcher_file="$SESSION_DIR/`__get_cur_session`/watch"
	cat "$watcher_file" | sed -e '' | while read watcher
	do
		_name="$(printf "$watcher" | awk '{print $1}')"
		pid_file="$SESSION_DIR/$project_session/$_name/pid"
		[ -s "$pid_file" ] && _pid=$(cat "$pid_file") || _pid=X
	
		[ ${#pid}  -gt $j ] && j=${#pid}
		[ ${#name} -gt $i ] && i=${#name}

		pid="${pid}${pid:+"\n"}$_pid"
		name="${name}${name:+"\n"}$_name"
		stat="${stat}${stat:+"\n"}""$(printf "$watcher" | awk '{print $2}')"
		shot="${shot}${shot:+"\n"}""$(printf "$watcher" | awk '{print $3}')"
		comm="${comm}${comm:+"\n"}""$(printf "$watcher" | awk '{print $4}')"
	done

	printf "%${i}s |%${j}s |%-4s |%s\n" "WATCHER_NAME" "PID" "O/M" "COMMAND"
	printf "%${i}s |%${j}s |%-4s |%s\n" "" "" "" ""

	while true; do
		[ ${#name} -eq 0 ] && break
		printf "%${i}s |%${j}s |%-4s |%s\n" "$_name" "$_pid" "$_stat" "$_comm"
	done
}

func_ksession() {
	:;
}

# Cycle through std(out&stderr) of watchers
func_cycle() {
	local cur_session=`__get_cur_session`
	local project_fifos="$SESSION_DIR/$cur_session/fifos"

	[ -z "$cur_session" ] && return
	local watcher_name

	cd "$project_fifo"
	if [ $? -eq 0 ]
	then
		for fifo in *
		do
			watcher_name=${fifo%.fifo}
			if [ -n "$watcher_name" ]
			then
				{ printf "${SUCCESS}${watcher_name}${UNSET_ANSI}${BOLD}\n"
				  cat "$fifo"
				} | less --RAW-CONTROL-CHARS
				printf "$UNSET_ANSI"
			fi
		done
	fi
}

# Wrap all operations, plugins appear here
func_ops() {

	_load_plugins() {
		:;
	}

	[ -z `__get_project_dir` ] && return

	local ops=$(
	    printf "commit
acommit
branch
runner
explore
select
dwatcher
ewatcher
awatcher
rwatcher
view
cycle
nsession
switch
fpush
push" | eval "$SEARCHER")

	test -n "$ops" && {
		trap '' HUP

		case $ops in
			select)
				__set_whxy $WINDOW_ATTRIBUTES_FILE_SELECTOR ;;
			commit   | \
			acommit  | \
			runner   | \
			branch   | \
			explore  | \
			push     | \
			fpush    | \
			dwatcher | \
			ewatcher | \
			awatcher | \
			rwatcher | \
			view     | \
			cycle    | \
			nsession | \
			switch)
				__set_whxy $WINDOW_ATTRIBUTES_REST ;;
		esac

		tmux display-popup -w $w -h $h -x $x -y $y -E "/home/kueppo/projects/wfmux/src/wfmux $ops"
		#tmux display-popup -w $w -h $h -x $x -y $y -E "wfmux $ops"
	} &

	tmux display-popup -C
}

func_main "$@"
